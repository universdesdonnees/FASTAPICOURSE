{"title":"Lecture 1 - Introduction to FastAPI & Development Setup","markdown":{"yaml":{"title":"Lecture 1 - Introduction to FastAPI & Development Setup","author":"M√©nyssa Cherifa-Luron","date":"today"},"headingText":"TL;DR:","containsRefs":false,"markdown":"\n\n\nIf you're short on time, you can listen to the key takeaways from the course in this audio summary:\n\n<div style=\"text-align: center;\">\n  <figure>  \n    <figcaption>Listen to the Audio Overview:</figcaption>  \n    <audio controls src=\"01_Podcast.wav\"></audio>  \n    <br>\n    <button class=\"download-btn\" onclick=\"window.location.href='01_Podcast.wav'\">Download audio</button>  \n  </figure>\n</div>\n\nTogether, we‚Äôll dive into key concepts like asynchronous programming, data validation, and API deployment‚Äîhelping you sharpen your skills every step of the way :\n\n- **APIs** (Application Programming Interfaces) are crucial for allowing different software systems to communicate, making modern apps smarter and more interconnected.\n- **APIs serve as the link between front-end and back-end systems**, enabling seamless data exchange across various platforms like mobile apps, IoT devices, and desktop applications.\n- **HTTP** is the protocol for web communication, using requests and responses with status codes to manage data exchange.\n- **RESTful services** use HTTP methods to interact with resources, offering simplicity, flexibility, and scalability for web services.\n- **URLs** are essential for locating resources on the web, comprising components like scheme, host, path, and query parameters.\n- **FastAPI** stands out with asynchronous programming, automatic documentation, and type hinting, making it fast and suitable for API-heavy projects.\n\n---\n\nWelcome to **FastAPI 101**, where we're diving into one of the fastest-growing frameworks for building APIs‚ÄîFastAPI! üöÄ \n\n<div style=\"text-align: center;\">\n  <img src=\"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" alt=\"FastAPI logo\" style=\"width: 400px;\">\n</div>\n\nIf you've ever worked with REST APIs and thought, \"There's got to be a faster, easier way,\" then you're in the right place. \n\n**[FastAPI](https://fastapi.tiangolo.com/) is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints. It is designed to be lightning-fast (hence the name) support for automatic documentation**.\n\nIn this course, we'll get hands-on, from understanding how APIs make the modern web tick to setting up your own FastAPI environment. Whether you're new to APIs or have some experience, by the end, you'll be running your own FastAPI server and ready to build dynamic, data-driven apps.\n\n**Let‚Äôs get you up to speed!**\n\n## 1. What the Heck is an API, and Why Should You Care?\n\nAn **API (Application Programming Interface)** is the glue that holds our digital world together. It‚Äôs the bridge that lets apps and services exchange data seamlessly. \n\n<div style=\"text-align: center;\">\n  <img src=\"https://res.cloudinary.com/mailmodo/image/upload/f_auto,q_100/v1654629332/strapi/working_of_an_api_6cc55c5cd1.png\" alt=\"What is an API?\n\" style=\"width: 400px;\">\n</div>\n\nThink of it like sending a **request** to your favorite delivery app for a meal‚ÄîAPIs ensure your order is understood, processed, and delivered to the kitchen (and then to you). From social media apps to payment gateways, APIs power the connections that make modern software work.\n\nMore precisely, **an API is a set of protocols, tools, and definitions that allow different software applications to communicate with each other. It defines how requests are made between clients (users or systems) and servers (service providers) and ensures data is transferred in a structured way.**\n\n> Why are APIs so essential?\n\n- They let apps **talk** to each other, allowing you to share, pull, and push data without breaking a sweat.\n- They're the reason your **phone app** syncs with your **watch**‚Äîand why your boss can track your productivity tools. (Oops.)\n- Modern apps are like **Legos**‚Äîmodular, flexible, and built using APIs to connect their different parts.\n\n> Why APIs are crucial for data and cybersecurity experts?\n\nAPIs are the digital bridges that allow different software systems to communicate and share data. \n\n- For **data experts**, they open up a world of possibilities by enabling the integration of diverse datasets, automating workflows, and enhancing data-driven insights. Leveraging APIs allows you to seamlessly incorporate real-time data from various sources, enriching your analyses and models with up-to-date insights.\n\n- For **cybersecurity professionals**, understanding APIs is crucial for safeguarding digital assets. As APIs become more prevalent, they also become potential targets for cyber threats. Learning how to build and secure APIs ensures that sensitive data is protected and that your systems remain resilient against attacks.\n\nWhether you‚Äôre a data scientist looking to enhance your analytical capabilities or a cybersecurity expert aiming to fortify your defenses, this course will introduce you to the knowledge and tools you need to succeed. \n\n## 2. The Importance of APIs in Client-Server Architecture\n\nIn the world of applications, it‚Äôs essential to distinguish between the **Front-End** and the **Back-End**:\n\n- **Front-End**: This is what users interact with‚Äîthink of it as the stylish storefront of your application. **It includes everything the user sees and engages with, from buttons to text.** Front-end development focuses on user experience and design.\n\n- **Back-End**: This is the engine that powers the application. **It handles data storage, business logic, and server-side functionality.** Users don‚Äôt see it, but without the Back-End, nothing would work!\n\nNow, here‚Äôs where APIs come into play. **They are the vital links that connect these two worlds.** APIs allow the Front-End to request and send data to the Back-End without needing to know how the Back-End operates. \n\n<div style=\"text-align: center;\">\n  <img src=\"https://fiverr-res.cloudinary.com/images/t_main1,q_auto,f_auto,q_auto,f_auto/gigs3/272841671/original/dfbe9538898c8aeaa105f9dd0489e6259cf8472b/develop-rest-api-with-node-js-and-mongodb.png\" alt=\"API connect back-end to multiple front-end\" style=\"width: 400px;\">\n</div>\n\nBut wait! **APIs aren‚Äôt just for web services**‚Äîthey‚Äôre the backbone of various applications. Here are a few examples:\n\n- **Mobile Apps**: Think about how your favorite weather app gets real-time data. It communicates with a weather service API to fetch the latest forecasts and display them beautifully on your screen.\n\n- **IoT Devices**: Smart home devices, like thermostats or lights, use APIs to send and receive data. For instance, a smart thermostat might send temperature readings to a cloud service via an API, allowing you to control it remotely through a mobile app.\n\n- **Desktop Applications**: Applications like Microsoft Word can use APIs to integrate with online services. For example, you might use an API to fetch stock photos from a service like Unsplash directly within the app, streamlining your workflow.\n\n- **Third-Party Integrations**: E-commerce platforms often integrate payment gateways (like Stripe or PayPal) using APIs. When you check out, the platform calls the payment API to process your transaction securely.\n\nThis separation enables multiple clients‚Äîlike web apps, mobile apps, desktop applications, and even IoT devices‚Äîto communicate with the same Back-End services. **This means you can build a seamless experience across platforms, ensuring that all your applications can tap into the same data and functionality.**\n\n## 3. HTTP Basics: It's Like a Postman for the Web\n\n**HTTP** might sound fancy, but think of it as the mail service of the web‚Äîdelivering packages (requests) from clients (you) to servers (your favorite app).\n\nIt's like sending a letter to a friend. üì© \n\nYou write the letter **(create a request)**, put it in an envelope **(format it)**, address it **(specify the URL)**, and send it off **(make the request)**. The server gets your letter and responds with a package **(response)** containing your requested information.\n\n### 3.1. Requests in the Tech World\n\n> Requests are all about getting what you want, with a sprinkle of charm and a dash of politeness.\n\n- **The Friendly Ask**: Picture this‚Äîyou‚Äôre at a dinner party, and you spot the salad across the table. You lean in and say, \"Could you please pass the salad? It looks amazing!\" That's a request. It‚Äôs all about expressing your desires with a touch of grace and a hint of enthusiasm.\n  \n- **The Formal Plea**: Now, let's get a bit official. You're applying for that dream library card. You fill out a form, scribble your details, and voil√†! You've made a formal request. It's like sending a little note to the universe saying, \n\n>\"I‚Äôm ready for all the books!\"\n\nIn the tech world, requests are the stars of the digital show.  When you type a website URL into your browser and hit enter, you're basically saying, \n\n>\"Hey server, can you show me this awesome webpage?\" \n\nYour browser sends a request to the server, and the server‚Äîlike a gracious host‚Äîreturns with the webpage you asked for, often with a little note on how things went down (that's the HTTP status code, see after).\n\n<div style=\"text-align: center;\">\n  <img src=\"https://miro.medium.com/v2/resize:fit:1400/1*_BylvKonkAYtmDygRJadHg.png\" style=\"width: 400px;\">\n</div>\n\nRequests are everywhere, from the dinner table to the internet, keeping everything moving along with a polite ask every step of the way.\n\n### 3.2. HTTP Status Codes\nLike life, requests have outcomes. Some are good, some are bad, and some make you want to throw your laptop out the window. \n\n**HTTP status codes are like the traffic signals of the web, guiding the flow of data between clients and servers**. They indicate the outcome of an HTTP request, helping developers and users understand what happened during the interaction. \n\n<div style=\"text-align: center;\">\n  <img src=\"https://www.infidigit.com/wp-content/uploads/2019/12/20191227_012601_0000-768x1664.png\" style=\"width: 400px;\">\n</div>\n\nHere's a deeper dive into some of the most common and important HTTP status codes:\n\n#### **1xx: Informational Responses**\nThese codes indicate that the request was received and understood, and the process is continuing.\n\n- **100 Continue**: The server has received the request headers, and the client should proceed to send the request body.\n\n#### **2xx: Success**\nThese codes indicate that the request was successfully received, understood, and accepted.\n\n- **200 OK**: The request was successful, and the server returned the requested resource.\n- **201 Created**: The request was successful, and a new resource was created as a result.\n\n#### **3xx: Redirection**\nThese codes indicate that further action needs to be taken by the user agent to fulfill the request.\n\n- **301 Moved Permanently**: The requested resource has been permanently moved to a new URL.\n- **302 Found**: The requested resource is temporarily located at a different URL.\n\n#### **4xx: Client Errors**\nThese codes indicate that the client seems to have made an error.\n\n- **400 Bad Request**: The server could not understand the request due to invalid syntax.\n- **401 Unauthorized**: The request requires user authentication.\n- **403 Forbidden**: The server understood the request but refuses to authorize it.\n- **404 Not Found**: The server can't find the requested resource. This is often the result of a broken link or a mistyped URL.\n\n#### **5xx: Server Errors**\nThese codes indicate that the server failed to fulfill a valid request.\n\n- **500 Internal Server Error**: The server encountered an unexpected condition that prevented it from fulfilling the request.\n- **502 Bad Gateway**: The server, while acting as a gateway or proxy, received an invalid response from the upstream server.\n- **503 Service Unavailable**: The server is not ready to handle the request, often due to maintenance or overload.\n\nUnderstanding these codes is crucial for debugging and improving user experience. \n\n**For instance, too many 404 errors might indicate broken links that need fixing, while frequent 500 errors could suggest server-side issues that require attention.**\n\nBy monitoring these codes, developers can ensure smoother and more reliable web interactions.\n\nFor a [comprehensive list of HTTP status codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes ), you can refer to resources like Wikipedia or detailed guides on developer platforms.\n\nTo wrap it all up, the **Request/Response Cycle** works like this:\n\n- **Knock, Knock!**: You (the client) send a request to the server, similar to knocking on the door of your favorite restaurant, asking for your meal.\n- **Server Response**: The server opens the door and either provides the data (response) or, on a not-so-great day, might say, ‚ÄúNot today‚Äù with an error message like 404 Not Found.\n\n### 3.3. Role of HTTP Verbs in RESTful Web Services\n\n**HTTP verbs**, also known as HTTP methods, are integral to **RESTful** web services. They define the actions that can be performed on resources available on a server, forming the backbone of how clients and servers communicate over the web. \n\nLet's explore how these verbs contribute to the functionality and efficiency of RESTful services.\n\n#### What is a RESTful Service? \n\nA **RESTful service** is a web service that follows the principles of REST (Representational State Transfer), an architectural style for designing networked applications. \n\n<div style=\"text-align: center;\">\n  <img src=\"https://miro.medium.com/v2/resize:fit:720/format:webp/0*1xZszp_OqUMrfRsV.png\" style=\"width: 400px;\">\n</div>\n\nLet's explore the **core principles of RESTful services** and illustrate each concept.\n\n1. **Resource-Based**\n\nIn [REST](https://en.wikipedia.org/wiki/REST), everything is treated as a resource, identified by a unique URI (Uniform Resource Identifier). Consider an online bookstore. Each book can be a resource with a URI like `https://api.bookstore.com/books/123`, where `123` is the unique identifier for a specific book.\n\n2. **Stateless Communication**\n\nRESTful services are stateless, meaning each request from a client to a server must contain all the information needed to understand and process the request. \n\nWhen you log into a website, each request you make (like viewing your profile) includes your authentication token. The server doesn‚Äôt remember your login state between requests; it relies on the token you provide each time.\n\n3. **Use of Standard HTTP Methods**\n\nRESTful services use standard **HTTP methods** to perform operations on resources.\n\n- **GET**: Retrieve a list of books with `GET https://api.bookstore.com/books`.\n- **POST**: Add a new book with `POST https://api.bookstore.com/books` and include the book details in the request body.\n- **PUT**: Update book information with `PUT https://api.bookstore.com/books/123` and provide the updated data.\n- **DELETE**: Remove a book with `DELETE https://api.bookstore.com/books/123`.\n\n[Get more details on method here](https://en.wikipedia.org/wiki/HTTP)\n\n\n4. **Representation-Oriented**\n\nResources can be represented in various formats, such as **JSON, XML, or HTML**. When you request a book's details, you might receive the data in JSON format:\n```json\n    {\n       \"id\": 123,\n       \"title\": \"RESTful Web Services\",\n       \"author\": \"John Doe\",\n       \"price\": 29.99\n}\n```\n\n5. **Statelessness and Scalability** \n\nThe stateless nature of RESTful services allows them to scale easily. An e-commerce site can handle thousands of simultaneous users because each request is independent, allowing the server to distribute requests across multiple servers without maintaining session state.\n\n6. **Cacheable Responses**\n\nResponses from RESTful services can be cached to improve performance. A news website might cache the response for the latest headlines, so repeated requests for the same data can be served quickly without hitting the server again.\n\n#### **Benefits of RESTful Services**\n\n- **Simplicity and Flexibility**: RESTful services are straightforward to use and flexible, allowing developers to build APIs that can be easily consumed by different clients, such as web browsers, mobile apps, and other servers.\n- **Interoperability**: By using standard HTTP methods and formats, RESTful services can be accessed by any client that understands HTTP, making them highly interoperable.\n- **Scalability**: The stateless nature of RESTful services allows them to scale horizontally, handling more requests by adding more servers.\n\n### 3.4. REST, SOAP, and GraphQL: The Web's Favorite Squabble\n\nRESTful services have become a popular choice for building APIs due to their simplicity, scalability, and ability to integrate seamlessly with the web's existing infrastructure.\n\nBuilding APIs can be like debating pizza toppings‚ÄîREST, SOAP, and GraphQL are all different flavors:\n\n- **REST** is the most popular, like classic **pepperoni** pizza. Simple, reliable, and everyone loves it.\n- **SOAP** is for the serious types, like a fancy **deep-dish**. It‚Äôs packed with structure, uses a lot of XML, and is great for enterprises that need bulletproof security.\n- **GraphQL** is for the data nerds, a **custom pizza** where you choose exactly what you want on it. No more, no less. It's flexible and efficient for complex data retrieval.\n\nIf REST is the crowd-pleaser, SOAP is for the suit-and-tie folks, and GraphQL is the cool kid shaking things up with customization.\n\nNo matter which flavor of API you prefer‚Äîbe it REST, SOAP, or GraphQL‚ÄîURLs are the essential connectors that enable these technologies to function. They act as the precise coordinates that direct your API calls to the appropriate destinations on the internet, ensuring efficient and accurate data retrieval and interaction.\n\n## 4. URL Construction: What is a URL?\n\nA **URL** (Uniform Resource Locator) is essentially the **address** used to locate resources on the web. Just as a physical address directs you to a building or a house, a URL tells your browser or application where to find a specific resource, be it a webpage, image, or an API endpoint.\n\n<div style=\"text-align: center;\">\n  <img src=\"https://www.lucamussari.com/wp-content/uploads/2021/06/parts-of-a-url-luca-mussari-com.png\" style=\"width: 400px;\">\n</div>\n\nWhen working with APIs, URLs are crucial because they serve as the precise **coordinates** that direct API calls to the right destinations. Whether you‚Äôre making a simple GET request or a complex data manipulation with POST, the URL is where it all starts.\n\n### 4.1. Components of a URL\n\nA URL is made up of several key components, each serving a unique purpose. Understanding these parts helps in correctly constructing and troubleshooting API requests.\n\n**1. Scheme (or Protocol)**\n\nThis defines the protocol used to access the resource. The two most common schemes are `http` (Hypertext Transfer Protocol) and `https` (Hypertext Transfer Protocol Secure). The `https` scheme is preferred over `http` because it encrypts the data being transmitted, ensuring a secure connection.\n\n**2. Host**\n\nThe **host** specifies the domain name or IP address of the server that is hosting the resource. It essentially tells your browser where to send your request.\n\n**Example**: `www.example.com`\nIn the context of APIs, the host is often the base URL of the API provider, such as `api.openweathermap.org` or `api.example.com`.\n\n**3. Path**\n\nThe **path** points to the specific resource on the server. It acts like the directory structure in a file system, guiding the server to a particular location.\n\n**Example**: `/products`\n\nIn RESTful APIs, the path usually represents the endpoint or resource being accessed, such as `/users`, `/orders`, or `/products/123`.\n\n**4. Query Parameters**\n\n**Query parameters** are key-value pairs appended to the end of the path, prefixed by a `?` symbol. They provide extra information or filtering criteria for the request.\n\n**Example**: `?category=fruits&sort=price_asc`\n\nMultiple parameters are separated by an `&`. In the above example:\n- `category=fruits`: Filters products to show only items in the \"fruits\" category.\n- `sort=price_asc`: Orders the results by price in ascending order.\n\n**5. Fragment Identifier**:\n\nThis part of a URL points to a specific section within a webpage, often used in HTML documents.\n\n**Example**: `#section2`\n\nFor APIs, this is rarely used, but it‚Äôs helpful for navigating large documents.\n\nPutting it all together, a complete URL looks like this:\n\n```\nhttps://www.example.com/products?category=fruits&sort=price_asc\n```\n\nIn this URL:\n\n- **Scheme**: `https://`\n- **Host**: `www.example.com`\n- **Path**: `/products`\n- **Query Parameters**: `?category=fruits&sort=price_asc`\n\n### 4.2. Constructing a URL with Parameters\n\nWhen constructing URLs for API requests, query parameters are often used to **filter**, **sort**, or **modify** the returned data.\n\nFor example, consider a URL for fetching a list of products filtered by category and sorted by price:\n\n```\nGET /products?category=fruits&sort=price_asc\n```\n\nBreaking down the query parameters:\n\n- **`category=fruits`**: Specifies that only products categorized as \"fruits\" should be returned.\n- **`sort=price_asc`**: Instructs the server to sort the returned products by price in ascending order.\n\nThis method of passing parameters is especially useful for creating **dynamic queries** without modifying the underlying codebase.\n\n### 4.3. Best Practices for URL Construction\n\n1. **Use Descriptive Paths**:\n   - Use readable and meaningful paths that describe the resource.\n   - **Good**: `/users/{id}/profile`\n   - **Bad**: `/u123?details=profile`\n\n2. **Limit the Number of Query Parameters**:\n   - Overusing query parameters can make URLs long and difficult to manage.\n   - Use query parameters only when filtering or modifying the request.\n\n3. **Always Use HTTPS for Secure Data Transmission**:\n   - Never use `http` for sensitive data to prevent data interception.\n   - Always opt for `https://` when constructing your base URLs.\n\n4. **Use Proper Encodings for Special Characters**:\n   - Special characters (`?`, `&`, `=`, etc.) must be URL-encoded to prevent misinterpretation by the server.\n   - Use libraries or built-in functions to safely encode URLs, such as Python‚Äôs `urllib.parse`.\n\n### 4.4. Constructing API URLs: Example Scenarios\n\nLet‚Äôs explore a few common scenarios to see how URLs are constructed for different use cases:\n\n#### **1. Fetching User Profile Data**\nIf you want to retrieve a user‚Äôs profile data using an API:\n\n```\nGET https://api.example.com/users/123/profile\n```\n\nHere:\n\n- `https://api.example.com` is the base URL.\n- `/users/123/profile` is the path, where `123` is the user ID.\n\n#### **2. Searching for Products in an E-commerce API**\nTo search for laptops priced under $1000:\n\n```\nGET https://api.shop.com/products?category=laptops&price_max=1000\n```\n\n- The **category** parameter filters by product category (`laptops`).\n- The **price_max** parameter restricts results to products under $1000.\n\n#### 3. Paginated Results in a Large Dataset**\nTo navigate through a paginated list of items:\n\n```\nGET https://api.data.com/resources?page=2&limit=20\n```\n\n- The **page** parameter specifies the current page (`2`).\n- The **limit** parameter defines the number of items per page (`20`).\n\nIncorporating these elements properly ensures your API calls are both efficient and readable, reducing the likelihood of errors and making debugging easier.\n\nURLs are the backbone of API communication. Understanding how to construct them accurately‚Äîusing appropriate schemes, paths, and query parameters‚Äîwill help you efficiently interact with web resources and design effective API interactions.\n\n## 5. Full Architecture of an HTTP Request and Response: A Breakdown\n\nTo truly grasp how web applications function, we need to understand the full architecture of an HTTP request and response. \n\nIt's like uncovering the inner workings of a conversation between a client (like a web browser) and a server (the one holding the data). \n\nLet‚Äôs walk through a scenario where a user tries to view their profile information on a web application. This is a simplified yet typical process:\n\n**1. The Scenario: User Wants Profile Information**\n\nImagine a user logging into their favorite web app to check their profile. The magic starts when they click on the profile page. This action sends a request to the server, asking it to fetch the profile data.\n\n**2. The Client Sends a Request**\n\n- **User Action**: The user clicks their profile page.\n- **Client Side**: The front end (browser or app) constructs an HTTP request to fetch the necessary data from the server.\n\n**3. The Structure of an HTTP Request**\n\nHere‚Äôs what that request might look like:\n\n```http\nGET /api/users/profile HTTP/1.1\nHost: example.com\nContent-Type: application/json\nAuthorization: Bearer <token>\nAccept: application/json\n```\n\nEach part serves a specific purpose:\n\n- **GET**: This is the method, telling the server we're retrieving information.\n- **/api/users/profile**: This is the endpoint‚Äîthe resource (in this case, the profile) we're trying to access.\n- **HTTP/1.1**: This is the version of the HTTP protocol being used.\n\nThe headers provide additional context, such as:\n\n- **Host**: Specifies the domain (example.com).\n- **Content-Type**: Declares that the data being sent is in JSON format.\n- **Authorization**: A token that proves the user is allowed to access the data.\n- **Accept**: Specifies that the client expects a JSON response.\n\n**4. The Server Processes the Request**\n\nOnce the server receives this request, it jumps into action:\n\n- **Authentication**: First, it checks the `Authorization` token to ensure the user has permission to access the resource.\n- **Data Retrieval**: If the authentication is successful, the server dives into its database to fetch the requested user data.\n\n**5. The Server Sends Back a Response**\n\nWith the requested data in hand, the server responds to the client. Here‚Äôs an example:\n\n```http\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-cache\n\n{\n    \"username\": \"user123\",\n    \"email\": \"user123@example.com\",\n    \"fullName\": \"User OneTwoThree\"\n}\n```\n\nThis response is made up of:\n\n- **Status Line**: \n  - `HTTP/1.1 200 OK` tells the client that the request was successful.\n- **Headers**: These give additional information, such as the fact that the response contains JSON data (`Content-Type: application/json`) and that the data should not be cached (`Cache-Control: no-cache`).\n- **Response Body**: This holds the actual data‚Äîin this case, the user‚Äôs profile details.\n\nTo transition smoothly between these sections, we need to bridge the gap from the technical process of the client receiving the server's response to introducing FastAPI's standout features. Here's a natural transition:\n\n**6. The Client Receives the Response**\n\nOnce the client (the web app) gets the server‚Äôs response, it processes the information:\n\n- **Parsing**: The client reads the JSON response.\n- **Rendering**: The app updates the user interface with the profile details, like the username and email.\n\nThe request-response cycle is the bread and butter of web communication, but what if we could supercharge the way our apps handle these interactions? That‚Äôs where **FastAPI** comes in. \n\n## 6. FastAPI's Superpowers\n\nFastAPI‚Äôs key features combine to create a powerful, efficient, and developer-friendly framework for building APIs. Its focus on performance, simplicity, and modern practices makes it an excellent choice for both new and experienced developers.\n\n(image/ stats repos github /documentation)\n\n\n### 6.1. FastAPI vs. Flask vs. Django\n\nLet's explore how FastAPI compares with other popular Python web frameworks‚ÄîFlask and Django‚Äîand see why it might be the right choice for your next project.\n\n- **Flask**: Flask is a lightweight framework that offers flexibility and simplicity for building applications quickly. However, it may require additional libraries for larger projects, which can complicate development. It's great for smaller applications or prototypes but lacks the performance optimizations of FastAPI.\n\n- **Django**: Django is a comprehensive framework that includes numerous built-in features, making it suitable for complex, feature-rich applications. However, its size and structure may be overkill for simpler API projects, leading to unnecessary complexity.\n\n- **FastAPI**: FastAPI stands out as a modern framework optimized for performance and efficiency, especially for building APIs. It combines the best of both worlds by being lightweight yet powerful, making it ideal for high-performance applications.\n\n### 6.2. Key Features\n\nWhether you need high performance for I/O-bound apps or want to build robust APIs with minimal effort, FastAPI delivers with its superpowers of async support, auto-generated docs, and tight integration with Pydantic for data validation.\n\n\n| **Feature**                          | **Definition**                                                                                     | **Real-Life Example**                                                                                                           |\n|--------------------------------------|---------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|\n| **Asynchronous Programming**         | Enables non-blocking operations, allowing multiple tasks to run concurrently without waiting.    | A travel booking website retrieves flight and hotel data from various APIs simultaneously, reducing user wait times.          |\n| **Automatic Interactive Documentation** | Generates API documentation automatically, making it easy to understand and test the API.         | A developer building a payment processing API uses FastAPI‚Äôs auto-generated docs to help external developers integrate quickly.|\n| **Request and Response Models with Pydantic** | Defines the structure of incoming requests and validates them against specified models.         | An online learning platform ensures all course registration requests include valid student names and emails, preventing errors. |\n| **Path and Query Parameters**       | Simplifies the extraction of parameters from the URL, making it easy to handle dynamic requests.  | A ride-sharing app allows users to filter their ride history using path and query parameters for user IDs and ride statuses.   |\n| **Dependency Injection System**     | Facilitates the management of external dependencies in a clean and modular way.                   | A blogging platform manages user authentication and database connections through dependency injection, keeping the code organized. |\n| **Performance and ASGI Integration**| Leverages ASGI for high concurrency and efficient handling of web requests.                       | A streaming service can handle thousands of concurrent video uploads without delays, ensuring a smooth user experience.        |\n| **Handling JSON, Headers, and Forms** | Provides intuitive methods for extracting and validating JSON data, headers, and form submissions. | An online food delivery app manages order submissions and user feedback through well-structured handling of JSON and forms.    |\n| **Data Validation with Pydantic**   | Validates incoming data against defined schemas, ensuring data integrity and reducing errors.    | A financial services company verifies that loan applications meet specific criteria (e.g., income, credit score) before processing. |\n\nFastAPI stands out in the world of web frameworks, offering a unique blend of speed, efficiency, and user-friendliness.\n\nBy leveraging modern Python features, it simplifies API development while ensuring high performance and reliability. \n\nEach key feature‚Äîfrom asynchronous programming to automatic documentation‚Äîcontributes to a seamless development experience that can adapt to the growing demands of modern applications.\n\n## In Summary\n\n<div style=\"text-align: center;\">\n  <img src=\"https://gcs.vn/wp-content/uploads/2024/03/api-la-gi-4.webp\" style=\"width: 400px;\">\n</div>\n\n\n### APIs: The Digital Bridge\nAPIs are the essential link between clients and servers, enabling smooth communication. Every time you check your email or log into an app, APIs are handling the requests and responses in the background, ensuring everything works seamlessly.\n\n### HTTP: The Web‚Äôs Mail Carrier\nHTTP acts like the postman of the web, delivering requests from the client to the server and bringing responses back, complete with headers, status codes, and content. Mastering HTTP is key to mastering APIs.\n\n### FastAPI: The Supercharged Framework\n\nFastAPI takes API development to the next level:\n\n- **Speed & Performance**: Thanks to asynchronous programming with `async`/`await`, FastAPI can handle high loads of requests efficiently.\n- **Auto-Generated Documentation**: FastAPI automatically creates clear and interactive API docs with Swagger UI and ReDoc, so you don‚Äôt have to.\n- **Type Safety & Validation**: By leveraging Python‚Äôs type hints, FastAPI keeps your code clean, safe, and easy to maintain, while handling data validation without extra hassle.\n\nIn short, FastAPI is built for performance, simplicity, and productivity‚Äîespecially for API-heavy projects.\n\n---\n\nNow that we‚Äôve got the essentials covered, let‚Äôs dive into the **[Lab 1](../01_Exercises/01_Lab.qmd)**\n","srcMarkdownNoYaml":"\n\n## TL;DR:\n\nIf you're short on time, you can listen to the key takeaways from the course in this audio summary:\n\n<div style=\"text-align: center;\">\n  <figure>  \n    <figcaption>Listen to the Audio Overview:</figcaption>  \n    <audio controls src=\"01_Podcast.wav\"></audio>  \n    <br>\n    <button class=\"download-btn\" onclick=\"window.location.href='01_Podcast.wav'\">Download audio</button>  \n  </figure>\n</div>\n\nTogether, we‚Äôll dive into key concepts like asynchronous programming, data validation, and API deployment‚Äîhelping you sharpen your skills every step of the way :\n\n- **APIs** (Application Programming Interfaces) are crucial for allowing different software systems to communicate, making modern apps smarter and more interconnected.\n- **APIs serve as the link between front-end and back-end systems**, enabling seamless data exchange across various platforms like mobile apps, IoT devices, and desktop applications.\n- **HTTP** is the protocol for web communication, using requests and responses with status codes to manage data exchange.\n- **RESTful services** use HTTP methods to interact with resources, offering simplicity, flexibility, and scalability for web services.\n- **URLs** are essential for locating resources on the web, comprising components like scheme, host, path, and query parameters.\n- **FastAPI** stands out with asynchronous programming, automatic documentation, and type hinting, making it fast and suitable for API-heavy projects.\n\n---\n\nWelcome to **FastAPI 101**, where we're diving into one of the fastest-growing frameworks for building APIs‚ÄîFastAPI! üöÄ \n\n<div style=\"text-align: center;\">\n  <img src=\"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" alt=\"FastAPI logo\" style=\"width: 400px;\">\n</div>\n\nIf you've ever worked with REST APIs and thought, \"There's got to be a faster, easier way,\" then you're in the right place. \n\n**[FastAPI](https://fastapi.tiangolo.com/) is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints. It is designed to be lightning-fast (hence the name) support for automatic documentation**.\n\nIn this course, we'll get hands-on, from understanding how APIs make the modern web tick to setting up your own FastAPI environment. Whether you're new to APIs or have some experience, by the end, you'll be running your own FastAPI server and ready to build dynamic, data-driven apps.\n\n**Let‚Äôs get you up to speed!**\n\n## 1. What the Heck is an API, and Why Should You Care?\n\nAn **API (Application Programming Interface)** is the glue that holds our digital world together. It‚Äôs the bridge that lets apps and services exchange data seamlessly. \n\n<div style=\"text-align: center;\">\n  <img src=\"https://res.cloudinary.com/mailmodo/image/upload/f_auto,q_100/v1654629332/strapi/working_of_an_api_6cc55c5cd1.png\" alt=\"What is an API?\n\" style=\"width: 400px;\">\n</div>\n\nThink of it like sending a **request** to your favorite delivery app for a meal‚ÄîAPIs ensure your order is understood, processed, and delivered to the kitchen (and then to you). From social media apps to payment gateways, APIs power the connections that make modern software work.\n\nMore precisely, **an API is a set of protocols, tools, and definitions that allow different software applications to communicate with each other. It defines how requests are made between clients (users or systems) and servers (service providers) and ensures data is transferred in a structured way.**\n\n> Why are APIs so essential?\n\n- They let apps **talk** to each other, allowing you to share, pull, and push data without breaking a sweat.\n- They're the reason your **phone app** syncs with your **watch**‚Äîand why your boss can track your productivity tools. (Oops.)\n- Modern apps are like **Legos**‚Äîmodular, flexible, and built using APIs to connect their different parts.\n\n> Why APIs are crucial for data and cybersecurity experts?\n\nAPIs are the digital bridges that allow different software systems to communicate and share data. \n\n- For **data experts**, they open up a world of possibilities by enabling the integration of diverse datasets, automating workflows, and enhancing data-driven insights. Leveraging APIs allows you to seamlessly incorporate real-time data from various sources, enriching your analyses and models with up-to-date insights.\n\n- For **cybersecurity professionals**, understanding APIs is crucial for safeguarding digital assets. As APIs become more prevalent, they also become potential targets for cyber threats. Learning how to build and secure APIs ensures that sensitive data is protected and that your systems remain resilient against attacks.\n\nWhether you‚Äôre a data scientist looking to enhance your analytical capabilities or a cybersecurity expert aiming to fortify your defenses, this course will introduce you to the knowledge and tools you need to succeed. \n\n## 2. The Importance of APIs in Client-Server Architecture\n\nIn the world of applications, it‚Äôs essential to distinguish between the **Front-End** and the **Back-End**:\n\n- **Front-End**: This is what users interact with‚Äîthink of it as the stylish storefront of your application. **It includes everything the user sees and engages with, from buttons to text.** Front-end development focuses on user experience and design.\n\n- **Back-End**: This is the engine that powers the application. **It handles data storage, business logic, and server-side functionality.** Users don‚Äôt see it, but without the Back-End, nothing would work!\n\nNow, here‚Äôs where APIs come into play. **They are the vital links that connect these two worlds.** APIs allow the Front-End to request and send data to the Back-End without needing to know how the Back-End operates. \n\n<div style=\"text-align: center;\">\n  <img src=\"https://fiverr-res.cloudinary.com/images/t_main1,q_auto,f_auto,q_auto,f_auto/gigs3/272841671/original/dfbe9538898c8aeaa105f9dd0489e6259cf8472b/develop-rest-api-with-node-js-and-mongodb.png\" alt=\"API connect back-end to multiple front-end\" style=\"width: 400px;\">\n</div>\n\nBut wait! **APIs aren‚Äôt just for web services**‚Äîthey‚Äôre the backbone of various applications. Here are a few examples:\n\n- **Mobile Apps**: Think about how your favorite weather app gets real-time data. It communicates with a weather service API to fetch the latest forecasts and display them beautifully on your screen.\n\n- **IoT Devices**: Smart home devices, like thermostats or lights, use APIs to send and receive data. For instance, a smart thermostat might send temperature readings to a cloud service via an API, allowing you to control it remotely through a mobile app.\n\n- **Desktop Applications**: Applications like Microsoft Word can use APIs to integrate with online services. For example, you might use an API to fetch stock photos from a service like Unsplash directly within the app, streamlining your workflow.\n\n- **Third-Party Integrations**: E-commerce platforms often integrate payment gateways (like Stripe or PayPal) using APIs. When you check out, the platform calls the payment API to process your transaction securely.\n\nThis separation enables multiple clients‚Äîlike web apps, mobile apps, desktop applications, and even IoT devices‚Äîto communicate with the same Back-End services. **This means you can build a seamless experience across platforms, ensuring that all your applications can tap into the same data and functionality.**\n\n## 3. HTTP Basics: It's Like a Postman for the Web\n\n**HTTP** might sound fancy, but think of it as the mail service of the web‚Äîdelivering packages (requests) from clients (you) to servers (your favorite app).\n\nIt's like sending a letter to a friend. üì© \n\nYou write the letter **(create a request)**, put it in an envelope **(format it)**, address it **(specify the URL)**, and send it off **(make the request)**. The server gets your letter and responds with a package **(response)** containing your requested information.\n\n### 3.1. Requests in the Tech World\n\n> Requests are all about getting what you want, with a sprinkle of charm and a dash of politeness.\n\n- **The Friendly Ask**: Picture this‚Äîyou‚Äôre at a dinner party, and you spot the salad across the table. You lean in and say, \"Could you please pass the salad? It looks amazing!\" That's a request. It‚Äôs all about expressing your desires with a touch of grace and a hint of enthusiasm.\n  \n- **The Formal Plea**: Now, let's get a bit official. You're applying for that dream library card. You fill out a form, scribble your details, and voil√†! You've made a formal request. It's like sending a little note to the universe saying, \n\n>\"I‚Äôm ready for all the books!\"\n\nIn the tech world, requests are the stars of the digital show.  When you type a website URL into your browser and hit enter, you're basically saying, \n\n>\"Hey server, can you show me this awesome webpage?\" \n\nYour browser sends a request to the server, and the server‚Äîlike a gracious host‚Äîreturns with the webpage you asked for, often with a little note on how things went down (that's the HTTP status code, see after).\n\n<div style=\"text-align: center;\">\n  <img src=\"https://miro.medium.com/v2/resize:fit:1400/1*_BylvKonkAYtmDygRJadHg.png\" style=\"width: 400px;\">\n</div>\n\nRequests are everywhere, from the dinner table to the internet, keeping everything moving along with a polite ask every step of the way.\n\n### 3.2. HTTP Status Codes\nLike life, requests have outcomes. Some are good, some are bad, and some make you want to throw your laptop out the window. \n\n**HTTP status codes are like the traffic signals of the web, guiding the flow of data between clients and servers**. They indicate the outcome of an HTTP request, helping developers and users understand what happened during the interaction. \n\n<div style=\"text-align: center;\">\n  <img src=\"https://www.infidigit.com/wp-content/uploads/2019/12/20191227_012601_0000-768x1664.png\" style=\"width: 400px;\">\n</div>\n\nHere's a deeper dive into some of the most common and important HTTP status codes:\n\n#### **1xx: Informational Responses**\nThese codes indicate that the request was received and understood, and the process is continuing.\n\n- **100 Continue**: The server has received the request headers, and the client should proceed to send the request body.\n\n#### **2xx: Success**\nThese codes indicate that the request was successfully received, understood, and accepted.\n\n- **200 OK**: The request was successful, and the server returned the requested resource.\n- **201 Created**: The request was successful, and a new resource was created as a result.\n\n#### **3xx: Redirection**\nThese codes indicate that further action needs to be taken by the user agent to fulfill the request.\n\n- **301 Moved Permanently**: The requested resource has been permanently moved to a new URL.\n- **302 Found**: The requested resource is temporarily located at a different URL.\n\n#### **4xx: Client Errors**\nThese codes indicate that the client seems to have made an error.\n\n- **400 Bad Request**: The server could not understand the request due to invalid syntax.\n- **401 Unauthorized**: The request requires user authentication.\n- **403 Forbidden**: The server understood the request but refuses to authorize it.\n- **404 Not Found**: The server can't find the requested resource. This is often the result of a broken link or a mistyped URL.\n\n#### **5xx: Server Errors**\nThese codes indicate that the server failed to fulfill a valid request.\n\n- **500 Internal Server Error**: The server encountered an unexpected condition that prevented it from fulfilling the request.\n- **502 Bad Gateway**: The server, while acting as a gateway or proxy, received an invalid response from the upstream server.\n- **503 Service Unavailable**: The server is not ready to handle the request, often due to maintenance or overload.\n\nUnderstanding these codes is crucial for debugging and improving user experience. \n\n**For instance, too many 404 errors might indicate broken links that need fixing, while frequent 500 errors could suggest server-side issues that require attention.**\n\nBy monitoring these codes, developers can ensure smoother and more reliable web interactions.\n\nFor a [comprehensive list of HTTP status codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes ), you can refer to resources like Wikipedia or detailed guides on developer platforms.\n\nTo wrap it all up, the **Request/Response Cycle** works like this:\n\n- **Knock, Knock!**: You (the client) send a request to the server, similar to knocking on the door of your favorite restaurant, asking for your meal.\n- **Server Response**: The server opens the door and either provides the data (response) or, on a not-so-great day, might say, ‚ÄúNot today‚Äù with an error message like 404 Not Found.\n\n### 3.3. Role of HTTP Verbs in RESTful Web Services\n\n**HTTP verbs**, also known as HTTP methods, are integral to **RESTful** web services. They define the actions that can be performed on resources available on a server, forming the backbone of how clients and servers communicate over the web. \n\nLet's explore how these verbs contribute to the functionality and efficiency of RESTful services.\n\n#### What is a RESTful Service? \n\nA **RESTful service** is a web service that follows the principles of REST (Representational State Transfer), an architectural style for designing networked applications. \n\n<div style=\"text-align: center;\">\n  <img src=\"https://miro.medium.com/v2/resize:fit:720/format:webp/0*1xZszp_OqUMrfRsV.png\" style=\"width: 400px;\">\n</div>\n\nLet's explore the **core principles of RESTful services** and illustrate each concept.\n\n1. **Resource-Based**\n\nIn [REST](https://en.wikipedia.org/wiki/REST), everything is treated as a resource, identified by a unique URI (Uniform Resource Identifier). Consider an online bookstore. Each book can be a resource with a URI like `https://api.bookstore.com/books/123`, where `123` is the unique identifier for a specific book.\n\n2. **Stateless Communication**\n\nRESTful services are stateless, meaning each request from a client to a server must contain all the information needed to understand and process the request. \n\nWhen you log into a website, each request you make (like viewing your profile) includes your authentication token. The server doesn‚Äôt remember your login state between requests; it relies on the token you provide each time.\n\n3. **Use of Standard HTTP Methods**\n\nRESTful services use standard **HTTP methods** to perform operations on resources.\n\n- **GET**: Retrieve a list of books with `GET https://api.bookstore.com/books`.\n- **POST**: Add a new book with `POST https://api.bookstore.com/books` and include the book details in the request body.\n- **PUT**: Update book information with `PUT https://api.bookstore.com/books/123` and provide the updated data.\n- **DELETE**: Remove a book with `DELETE https://api.bookstore.com/books/123`.\n\n[Get more details on method here](https://en.wikipedia.org/wiki/HTTP)\n\n\n4. **Representation-Oriented**\n\nResources can be represented in various formats, such as **JSON, XML, or HTML**. When you request a book's details, you might receive the data in JSON format:\n```json\n    {\n       \"id\": 123,\n       \"title\": \"RESTful Web Services\",\n       \"author\": \"John Doe\",\n       \"price\": 29.99\n}\n```\n\n5. **Statelessness and Scalability** \n\nThe stateless nature of RESTful services allows them to scale easily. An e-commerce site can handle thousands of simultaneous users because each request is independent, allowing the server to distribute requests across multiple servers without maintaining session state.\n\n6. **Cacheable Responses**\n\nResponses from RESTful services can be cached to improve performance. A news website might cache the response for the latest headlines, so repeated requests for the same data can be served quickly without hitting the server again.\n\n#### **Benefits of RESTful Services**\n\n- **Simplicity and Flexibility**: RESTful services are straightforward to use and flexible, allowing developers to build APIs that can be easily consumed by different clients, such as web browsers, mobile apps, and other servers.\n- **Interoperability**: By using standard HTTP methods and formats, RESTful services can be accessed by any client that understands HTTP, making them highly interoperable.\n- **Scalability**: The stateless nature of RESTful services allows them to scale horizontally, handling more requests by adding more servers.\n\n### 3.4. REST, SOAP, and GraphQL: The Web's Favorite Squabble\n\nRESTful services have become a popular choice for building APIs due to their simplicity, scalability, and ability to integrate seamlessly with the web's existing infrastructure.\n\nBuilding APIs can be like debating pizza toppings‚ÄîREST, SOAP, and GraphQL are all different flavors:\n\n- **REST** is the most popular, like classic **pepperoni** pizza. Simple, reliable, and everyone loves it.\n- **SOAP** is for the serious types, like a fancy **deep-dish**. It‚Äôs packed with structure, uses a lot of XML, and is great for enterprises that need bulletproof security.\n- **GraphQL** is for the data nerds, a **custom pizza** where you choose exactly what you want on it. No more, no less. It's flexible and efficient for complex data retrieval.\n\nIf REST is the crowd-pleaser, SOAP is for the suit-and-tie folks, and GraphQL is the cool kid shaking things up with customization.\n\nNo matter which flavor of API you prefer‚Äîbe it REST, SOAP, or GraphQL‚ÄîURLs are the essential connectors that enable these technologies to function. They act as the precise coordinates that direct your API calls to the appropriate destinations on the internet, ensuring efficient and accurate data retrieval and interaction.\n\n## 4. URL Construction: What is a URL?\n\nA **URL** (Uniform Resource Locator) is essentially the **address** used to locate resources on the web. Just as a physical address directs you to a building or a house, a URL tells your browser or application where to find a specific resource, be it a webpage, image, or an API endpoint.\n\n<div style=\"text-align: center;\">\n  <img src=\"https://www.lucamussari.com/wp-content/uploads/2021/06/parts-of-a-url-luca-mussari-com.png\" style=\"width: 400px;\">\n</div>\n\nWhen working with APIs, URLs are crucial because they serve as the precise **coordinates** that direct API calls to the right destinations. Whether you‚Äôre making a simple GET request or a complex data manipulation with POST, the URL is where it all starts.\n\n### 4.1. Components of a URL\n\nA URL is made up of several key components, each serving a unique purpose. Understanding these parts helps in correctly constructing and troubleshooting API requests.\n\n**1. Scheme (or Protocol)**\n\nThis defines the protocol used to access the resource. The two most common schemes are `http` (Hypertext Transfer Protocol) and `https` (Hypertext Transfer Protocol Secure). The `https` scheme is preferred over `http` because it encrypts the data being transmitted, ensuring a secure connection.\n\n**2. Host**\n\nThe **host** specifies the domain name or IP address of the server that is hosting the resource. It essentially tells your browser where to send your request.\n\n**Example**: `www.example.com`\nIn the context of APIs, the host is often the base URL of the API provider, such as `api.openweathermap.org` or `api.example.com`.\n\n**3. Path**\n\nThe **path** points to the specific resource on the server. It acts like the directory structure in a file system, guiding the server to a particular location.\n\n**Example**: `/products`\n\nIn RESTful APIs, the path usually represents the endpoint or resource being accessed, such as `/users`, `/orders`, or `/products/123`.\n\n**4. Query Parameters**\n\n**Query parameters** are key-value pairs appended to the end of the path, prefixed by a `?` symbol. They provide extra information or filtering criteria for the request.\n\n**Example**: `?category=fruits&sort=price_asc`\n\nMultiple parameters are separated by an `&`. In the above example:\n- `category=fruits`: Filters products to show only items in the \"fruits\" category.\n- `sort=price_asc`: Orders the results by price in ascending order.\n\n**5. Fragment Identifier**:\n\nThis part of a URL points to a specific section within a webpage, often used in HTML documents.\n\n**Example**: `#section2`\n\nFor APIs, this is rarely used, but it‚Äôs helpful for navigating large documents.\n\nPutting it all together, a complete URL looks like this:\n\n```\nhttps://www.example.com/products?category=fruits&sort=price_asc\n```\n\nIn this URL:\n\n- **Scheme**: `https://`\n- **Host**: `www.example.com`\n- **Path**: `/products`\n- **Query Parameters**: `?category=fruits&sort=price_asc`\n\n### 4.2. Constructing a URL with Parameters\n\nWhen constructing URLs for API requests, query parameters are often used to **filter**, **sort**, or **modify** the returned data.\n\nFor example, consider a URL for fetching a list of products filtered by category and sorted by price:\n\n```\nGET /products?category=fruits&sort=price_asc\n```\n\nBreaking down the query parameters:\n\n- **`category=fruits`**: Specifies that only products categorized as \"fruits\" should be returned.\n- **`sort=price_asc`**: Instructs the server to sort the returned products by price in ascending order.\n\nThis method of passing parameters is especially useful for creating **dynamic queries** without modifying the underlying codebase.\n\n### 4.3. Best Practices for URL Construction\n\n1. **Use Descriptive Paths**:\n   - Use readable and meaningful paths that describe the resource.\n   - **Good**: `/users/{id}/profile`\n   - **Bad**: `/u123?details=profile`\n\n2. **Limit the Number of Query Parameters**:\n   - Overusing query parameters can make URLs long and difficult to manage.\n   - Use query parameters only when filtering or modifying the request.\n\n3. **Always Use HTTPS for Secure Data Transmission**:\n   - Never use `http` for sensitive data to prevent data interception.\n   - Always opt for `https://` when constructing your base URLs.\n\n4. **Use Proper Encodings for Special Characters**:\n   - Special characters (`?`, `&`, `=`, etc.) must be URL-encoded to prevent misinterpretation by the server.\n   - Use libraries or built-in functions to safely encode URLs, such as Python‚Äôs `urllib.parse`.\n\n### 4.4. Constructing API URLs: Example Scenarios\n\nLet‚Äôs explore a few common scenarios to see how URLs are constructed for different use cases:\n\n#### **1. Fetching User Profile Data**\nIf you want to retrieve a user‚Äôs profile data using an API:\n\n```\nGET https://api.example.com/users/123/profile\n```\n\nHere:\n\n- `https://api.example.com` is the base URL.\n- `/users/123/profile` is the path, where `123` is the user ID.\n\n#### **2. Searching for Products in an E-commerce API**\nTo search for laptops priced under $1000:\n\n```\nGET https://api.shop.com/products?category=laptops&price_max=1000\n```\n\n- The **category** parameter filters by product category (`laptops`).\n- The **price_max** parameter restricts results to products under $1000.\n\n#### 3. Paginated Results in a Large Dataset**\nTo navigate through a paginated list of items:\n\n```\nGET https://api.data.com/resources?page=2&limit=20\n```\n\n- The **page** parameter specifies the current page (`2`).\n- The **limit** parameter defines the number of items per page (`20`).\n\nIncorporating these elements properly ensures your API calls are both efficient and readable, reducing the likelihood of errors and making debugging easier.\n\nURLs are the backbone of API communication. Understanding how to construct them accurately‚Äîusing appropriate schemes, paths, and query parameters‚Äîwill help you efficiently interact with web resources and design effective API interactions.\n\n## 5. Full Architecture of an HTTP Request and Response: A Breakdown\n\nTo truly grasp how web applications function, we need to understand the full architecture of an HTTP request and response. \n\nIt's like uncovering the inner workings of a conversation between a client (like a web browser) and a server (the one holding the data). \n\nLet‚Äôs walk through a scenario where a user tries to view their profile information on a web application. This is a simplified yet typical process:\n\n**1. The Scenario: User Wants Profile Information**\n\nImagine a user logging into their favorite web app to check their profile. The magic starts when they click on the profile page. This action sends a request to the server, asking it to fetch the profile data.\n\n**2. The Client Sends a Request**\n\n- **User Action**: The user clicks their profile page.\n- **Client Side**: The front end (browser or app) constructs an HTTP request to fetch the necessary data from the server.\n\n**3. The Structure of an HTTP Request**\n\nHere‚Äôs what that request might look like:\n\n```http\nGET /api/users/profile HTTP/1.1\nHost: example.com\nContent-Type: application/json\nAuthorization: Bearer <token>\nAccept: application/json\n```\n\nEach part serves a specific purpose:\n\n- **GET**: This is the method, telling the server we're retrieving information.\n- **/api/users/profile**: This is the endpoint‚Äîthe resource (in this case, the profile) we're trying to access.\n- **HTTP/1.1**: This is the version of the HTTP protocol being used.\n\nThe headers provide additional context, such as:\n\n- **Host**: Specifies the domain (example.com).\n- **Content-Type**: Declares that the data being sent is in JSON format.\n- **Authorization**: A token that proves the user is allowed to access the data.\n- **Accept**: Specifies that the client expects a JSON response.\n\n**4. The Server Processes the Request**\n\nOnce the server receives this request, it jumps into action:\n\n- **Authentication**: First, it checks the `Authorization` token to ensure the user has permission to access the resource.\n- **Data Retrieval**: If the authentication is successful, the server dives into its database to fetch the requested user data.\n\n**5. The Server Sends Back a Response**\n\nWith the requested data in hand, the server responds to the client. Here‚Äôs an example:\n\n```http\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-cache\n\n{\n    \"username\": \"user123\",\n    \"email\": \"user123@example.com\",\n    \"fullName\": \"User OneTwoThree\"\n}\n```\n\nThis response is made up of:\n\n- **Status Line**: \n  - `HTTP/1.1 200 OK` tells the client that the request was successful.\n- **Headers**: These give additional information, such as the fact that the response contains JSON data (`Content-Type: application/json`) and that the data should not be cached (`Cache-Control: no-cache`).\n- **Response Body**: This holds the actual data‚Äîin this case, the user‚Äôs profile details.\n\nTo transition smoothly between these sections, we need to bridge the gap from the technical process of the client receiving the server's response to introducing FastAPI's standout features. Here's a natural transition:\n\n**6. The Client Receives the Response**\n\nOnce the client (the web app) gets the server‚Äôs response, it processes the information:\n\n- **Parsing**: The client reads the JSON response.\n- **Rendering**: The app updates the user interface with the profile details, like the username and email.\n\nThe request-response cycle is the bread and butter of web communication, but what if we could supercharge the way our apps handle these interactions? That‚Äôs where **FastAPI** comes in. \n\n## 6. FastAPI's Superpowers\n\nFastAPI‚Äôs key features combine to create a powerful, efficient, and developer-friendly framework for building APIs. Its focus on performance, simplicity, and modern practices makes it an excellent choice for both new and experienced developers.\n\n(image/ stats repos github /documentation)\n\n\n### 6.1. FastAPI vs. Flask vs. Django\n\nLet's explore how FastAPI compares with other popular Python web frameworks‚ÄîFlask and Django‚Äîand see why it might be the right choice for your next project.\n\n- **Flask**: Flask is a lightweight framework that offers flexibility and simplicity for building applications quickly. However, it may require additional libraries for larger projects, which can complicate development. It's great for smaller applications or prototypes but lacks the performance optimizations of FastAPI.\n\n- **Django**: Django is a comprehensive framework that includes numerous built-in features, making it suitable for complex, feature-rich applications. However, its size and structure may be overkill for simpler API projects, leading to unnecessary complexity.\n\n- **FastAPI**: FastAPI stands out as a modern framework optimized for performance and efficiency, especially for building APIs. It combines the best of both worlds by being lightweight yet powerful, making it ideal for high-performance applications.\n\n### 6.2. Key Features\n\nWhether you need high performance for I/O-bound apps or want to build robust APIs with minimal effort, FastAPI delivers with its superpowers of async support, auto-generated docs, and tight integration with Pydantic for data validation.\n\n\n| **Feature**                          | **Definition**                                                                                     | **Real-Life Example**                                                                                                           |\n|--------------------------------------|---------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|\n| **Asynchronous Programming**         | Enables non-blocking operations, allowing multiple tasks to run concurrently without waiting.    | A travel booking website retrieves flight and hotel data from various APIs simultaneously, reducing user wait times.          |\n| **Automatic Interactive Documentation** | Generates API documentation automatically, making it easy to understand and test the API.         | A developer building a payment processing API uses FastAPI‚Äôs auto-generated docs to help external developers integrate quickly.|\n| **Request and Response Models with Pydantic** | Defines the structure of incoming requests and validates them against specified models.         | An online learning platform ensures all course registration requests include valid student names and emails, preventing errors. |\n| **Path and Query Parameters**       | Simplifies the extraction of parameters from the URL, making it easy to handle dynamic requests.  | A ride-sharing app allows users to filter their ride history using path and query parameters for user IDs and ride statuses.   |\n| **Dependency Injection System**     | Facilitates the management of external dependencies in a clean and modular way.                   | A blogging platform manages user authentication and database connections through dependency injection, keeping the code organized. |\n| **Performance and ASGI Integration**| Leverages ASGI for high concurrency and efficient handling of web requests.                       | A streaming service can handle thousands of concurrent video uploads without delays, ensuring a smooth user experience.        |\n| **Handling JSON, Headers, and Forms** | Provides intuitive methods for extracting and validating JSON data, headers, and form submissions. | An online food delivery app manages order submissions and user feedback through well-structured handling of JSON and forms.    |\n| **Data Validation with Pydantic**   | Validates incoming data against defined schemas, ensuring data integrity and reducing errors.    | A financial services company verifies that loan applications meet specific criteria (e.g., income, credit score) before processing. |\n\nFastAPI stands out in the world of web frameworks, offering a unique blend of speed, efficiency, and user-friendliness.\n\nBy leveraging modern Python features, it simplifies API development while ensuring high performance and reliability. \n\nEach key feature‚Äîfrom asynchronous programming to automatic documentation‚Äîcontributes to a seamless development experience that can adapt to the growing demands of modern applications.\n\n## In Summary\n\n<div style=\"text-align: center;\">\n  <img src=\"https://gcs.vn/wp-content/uploads/2024/03/api-la-gi-4.webp\" style=\"width: 400px;\">\n</div>\n\n\n### APIs: The Digital Bridge\nAPIs are the essential link between clients and servers, enabling smooth communication. Every time you check your email or log into an app, APIs are handling the requests and responses in the background, ensuring everything works seamlessly.\n\n### HTTP: The Web‚Äôs Mail Carrier\nHTTP acts like the postman of the web, delivering requests from the client to the server and bringing responses back, complete with headers, status codes, and content. Mastering HTTP is key to mastering APIs.\n\n### FastAPI: The Supercharged Framework\n\nFastAPI takes API development to the next level:\n\n- **Speed & Performance**: Thanks to asynchronous programming with `async`/`await`, FastAPI can handle high loads of requests efficiently.\n- **Auto-Generated Documentation**: FastAPI automatically creates clear and interactive API docs with Swagger UI and ReDoc, so you don‚Äôt have to.\n- **Type Safety & Validation**: By leveraging Python‚Äôs type hints, FastAPI keeps your code clean, safe, and easy to maintain, while handling data validation without extra hassle.\n\nIn short, FastAPI is built for performance, simplicity, and productivity‚Äîespecially for API-heavy projects.\n\n---\n\nNow that we‚Äôve got the essentials covered, let‚Äôs dive into the **[Lab 1](../01_Exercises/01_Lab.qmd)**\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"01_Lecture.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.554","code-summary":"Show the code","theme":{"light":["flatly","../styles.scss"]},"title":"Lecture 1 - Introduction to FastAPI & Development Setup","author":"M√©nyssa Cherifa-Luron","date":"today"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}