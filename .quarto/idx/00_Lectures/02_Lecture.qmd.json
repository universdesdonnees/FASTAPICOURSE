{"title":"Lecture 2 - Building Scalable and Efficient FastAPI Applications","markdown":{"yaml":{"title":"Lecture 2 - Building Scalable and Efficient FastAPI Applications","author":"M√©nyssa Cherifa-Luron","date":"today"},"headingText":"TL;DR:","containsRefs":false,"markdown":"\n\n\nIf you're short on time, you can listen to the key takeaways from the course in this audio summary:\n\n\n<div style=\"text-align: center;\">\n  <figure>  \n    <figcaption>Listen to the Audio Overview:</figcaption>  \n    <audio controls src=\"02_Podcast.wav\"></audio>  \n    <br>\n    <button class=\"download-btn\" onclick=\"window.location.href='02_Podcast.wav'\">Download audio</button>  \n  </figure>\n</div>\n\nIn this lecture, we cover key concepts to enhance your FastAPI development skills:\n\n- **Asynchronous Programming** improves performance by handling multiple tasks simultaneously.\n- **Routing** maps URLs to code, ensuring easy navigation within your API.\n- **Databases** are essential for efficient data storage and retrieval in your applications.\n- **Dependency Injection** promotes modularity, making code easier to maintain and test.\n- **Testing** with tools like `pytest` ensures your application functions as expected.\n- **Security** through authentication and authorization protects your API from unauthorized access.\n- **Performance Optimization** techniques, such as caching and async enhancements, ensure efficiency under heavy load.\n---\n\n**Your API is a bustling city.**\n\nEach street represents a different route, leading to specific destinations (functions or data).\n\n<div style=\"text-align: center;\">\n  <img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT3LVsLBXvyCaICWy29iarSq2Se66DjGqj6oQ&s\" alt=\"FastAPI logo\" style=\"width: 400px;\">\n</div>\n\n**Asynchronous programming** is like having a fleet of delivery drones zipping around, handling multiple tasks at once. **Databases** are the city's bustling warehouses, storing and retrieving valuable information.\n\n**Dependency Injection** is like having a reliable supply chain. It ensures that the right components (dependencies) are always available where needed. **Testing** is your quality control department, making sure everything runs smoothly. **Security** is the vigilant police force, protecting your API from hackers and unauthorized access.\n\n**Performance optimization** is about keeping the city running smoothly, even during peak hours. Techniques like caching and async enhancements are your traffic management tools, ensuring that everything flows efficiently.\n\n> Are you ready to build your own **API metropolis**? \n\n**Let's get started!**\n\n## 1. The Magic of Asynchronicity \n\nAlright, let's dive into the world of asynchronicity, where things happen... but they don‚Äôt always wait around for you. Get ready for some tech magic!\n\n### 1.1. Synchronous vs. Asynchronous Execution\n\nIn a synchronous world, you‚Äôre the chef cooking one dish at a time. You can't start the next meal until the first is finished and delivered‚Äîslow, right?\n\n<div style=\"text-align: center;\">\n  <img src=\"https://www.astera.com/wp-content/uploads/2023/01/Async-vs-Sync-API.png\" alt=\"FastAPI logo\" style=\"width: 400px;\">\n</div>\n\nNow, welcome to the **asynchronous kitchen**! \n\nHere, while one dish is cooking (waiting on I/O*, like boiling water), you can start prepping the next one. FastAPI does this for your app‚Äîit doesn‚Äôt wait idly for the oven to preheat before taking on new tasks.\n\n::: {.callout-note title=\"Note: I/O\" collapse=\"true\"}\nI/O in computing stands for \"Input/Output\". It refers to the communication between a computer system and the outside world, or between different components within a system. Here's a brief overview:\n\n**Definition** : I/O is the process of transferring data to or from a computer system.\n\n**Types**\n\n1. **Hard I/O**: Direct transfer of data between a computer and an external physical device (e.g., keyboard, mouse).\n\n2. **Soft I/O**: Data transfer between computers or servers over a network.\n\n**Characteristics**\n\n- **Bidirectional**: Some devices can function as both input and output devices.\n\n- **Perspective-based**: Whether a device is considered input or output can depend on the perspective.\n\n**Examples**\n\n- Input devices: Keyboards, mice, scanners\n\n- Output devices: Monitors, printers, speakers\n\n- I/O devices: Hard drives, network cards\n\n**Importance** : I/O operations are crucial for user interaction, data transfer, and system performance. Understanding I/O is essential for developers and system administrators for system design, performance optimization, and troubleshooting.\n:::\n\nHere‚Äôs the technical breakdown:\n\n- **Synchronous Execution** is like cooking one meal from start to finish before even thinking about the next one. It‚Äôs linear‚Äîone task finishes, and only then does the next begin.\n\n- **Asynchronous Execution** is like juggling multiple orders at once. While one task waits for something (say, file reading or a web request), the event loop jumps to the next task, keeping everything moving!\n\n**Event loop** is the master chef in charge, making sure no task burns by hopping from one to another. \n\nAnd **coroutines** are those tasks‚Äîit‚Äôs like each dish being prepped. They tell the event loop, \n\n> I‚Äôm gonna be busy for a while, feel free to go check on the others.\n\nThe benefit? FastAPI can handle a huge number of requests quickly, without getting bogged down in waiting, making your app zippy and responsive, even when under heavy load.\n\n### 1.2. Implementing Asynchronous Endpoints\n\nOkay, let‚Äôs jump into FastAPI's version of cooking up some asynchronous magic.\n\nTo make a route **asynchronous**, we use the keywords `async` and `await`‚Äîthey‚Äôre like the VIP passes to FastAPI‚Äôs asynchronous event.\n\n- **`async`**: This tells Python that a function might take a while to complete, and it‚Äôs cool to check out other functions while waiting.\n- **`await`**: It‚Äôs like a signal flare. It tells the event loop, ‚ÄúHey, I'm waiting for this task to finish, but you don‚Äôt need to hang around! Come back later.‚Äù\n\nHere‚Äôs a sample:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/async-dish\")\nasync def cook_something():\n    await prep_ingredients()  # Might take time\n    await bake_dish()  # Another wait here\n    return {\"status\": \"Dish ready!\"}\n```\nSee how we use `await` to tell the event loop to handle other things while it waits for the cooking functions to finish? \n\n>That‚Äôs the magic sauce! \n\nLet's whip up more examples to help you better understand how to use `async` and `await` in FastAPI! \n\nThese will showcase different ways you can handle async operations in routes.\n\n1. **Simulating Multiple Async Operations in Parallel**\n\nLet‚Äôs say you're preparing different parts of a meal simultaneously. While the oven is baking the dish, you‚Äôre also mixing the salad, and getting drinks ready.\n\n```python\nfrom fastapi import FastAPI\nimport asyncio  # For running tasks concurrently\n\napp = FastAPI()\n\nasync def bake_dish():\n    await asyncio.sleep(3)  # Simulate baking time\n    return \"Dish baked\"\n\nasync def prepare_salad():\n    await asyncio.sleep(1)  # Simulate chopping veggies\n    return \"Salad ready\"\n\nasync def get_drinks():\n    await asyncio.sleep(2)  # Simulate fetching drinks\n    return \"Drinks ready\"\n\n@app.get(\"/prepare-meal\")\nasync def prepare_meal():\n    # Run all tasks at the same time using asyncio.gather\n    dish, salad, drinks = await asyncio.gather(\n        bake_dish(),\n        prepare_salad(),\n        get_drinks()\n    )\n    return {\"status\": f\"{dish}, {salad}, {drinks}!\"}\n```\n\nüî• **Explanation**: In this example, instead of waiting for each task (baking, salad prep, drinks) to finish one by one, we're using `asyncio.gather()` to run all of them in parallel. The event loop jumps between these tasks while they‚Äôre waiting for something, maximizing efficiency. \n\n2. **Using Async with External API Calls**\n\nNow,  you‚Äôre pulling recipe data from a remote service. You don‚Äôt want your server to stop everything and wait while it fetches the data, so we make that operation asynchronous.\n\n```python\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/fetch-recipe\")\nasync def fetch_recipe():\n    async with httpx.AsyncClient() as client:\n        response = await client.get('https://recipe-api.com/special-dish')\n        data = response.json()\n    return {\"recipe\": data}\n```\n\nüî• **Explanation**: With `httpx.AsyncClient()`, we‚Äôre making the API call non-blocking. While the app waits for the recipe service to respond, the event loop is free to handle other requests. This is essential when working with third-party services to prevent your application from getting ‚Äústuck‚Äù waiting. \n\n3. **Asynchronous File Reading**\n\nYou can read files asynchronously so other requests don‚Äôt have to wait in line while your server is reading a large file.\n\n```python\nimport aiofiles  # Async library for file I/O\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/read-steps\")\nasync def read_steps():\n    async with aiofiles.open('recipe.txt', mode='r') as file:\n        content = await file.read()\n    return {\"recipe_steps\": content}\n```\n\nüî• **Explanation**: Here, we‚Äôre using `aiofiles` to open and read a file asynchronously. This allows FastAPI to handle other requests while reading the file in the background. \n\n4. **Delayed Responses: Simulating Long Operations**\n\nSuppose you have a task that simulates a long operation, like slow cooking. You don‚Äôt want your app to freeze while waiting for the slow cook to finish, so you implement it asynchronously.\n\n```python\nfrom fastapi import FastAPI\nimport asyncio  # For simulating a delay\n\napp = FastAPI()\n\n@app.get(\"/slow-cook\")\nasync def slow_cook():\n    await asyncio.sleep(5)  # Simulate a long task (e.g., slow cooking)\n    return {\"status\": \"Slow-cooked meal is ready!\"}\n```\n\nüî• **Explanation**: In this case, the `asyncio.sleep(5)` simulates a task that takes time (like slow cooking). While this is happening, FastAPI doesn‚Äôt sit idle‚Äîit can handle other requests while the slow-cooked meal finishes. üê¢üî•üç≤\n\n5. **Asynchronous Error Handling in Tasks**\n\nWhat if something goes wrong during one of your asynchronous tasks? For example, you‚Äôre preparing a cake but the oven breaks down midway. Let‚Äôs handle that gracefully using `async` and `try-except`.\n\n```python\nfrom fastapi import FastAPI\nimport asyncio\n\napp = FastAPI()\n\nasync def bake_cake():\n    await asyncio.sleep(2)\n    raise Exception(\"Oven malfunctioned!\")  # Something went wrong\n\n@app.get(\"/bake-cake\")\nasync def prepare_cake():\n    try:\n        await bake_cake()\n        return {\"status\": \"Cake baked successfully!\"}\n    except Exception as e:\n        return {\"error\": f\"Oops! {e}\"}\n```\n\nüî• **Explanation**: In this example, the oven \"malfunctions\" during the cake-baking process. The `try-except` block catches the error, allowing us to return a helpful message instead of crashing the app. This is like having a backup plan in case your cake flops.\n\n6. **Handling CPU-bound Tasks with Async + Background Tasks**\n\nWhile asynchronous tasks are great for I/O-bound operations (like waiting on APIs or files), CPU-bound operations (like heavy computations) can block the event loop. To avoid this, we can offload such tasks to background workers.\n\n```python\nfrom fastapi import FastAPI, BackgroundTasks\nimport time  # Simulate CPU-bound task\n\napp = FastAPI()\n\ndef heavy_computation():\n    time.sleep(10)  # Simulate a long-running computation\n    print(\"Computation done!\")\n\n@app.get(\"/start-computation\")\nasync def start_computation(background_tasks: BackgroundTasks):\n    background_tasks.add_task(heavy_computation)\n    return {\"status\": \"Computation started in the background!\"}\n```\n\nüî• **Explanation**: Here, `BackgroundTasks` allows us to offload the heavy computation (CPU-bound) to a background task so it doesn‚Äôt block the event loop. This way, FastAPI can continue processing other requests without waiting for the long-running computation to finish. \n\nBy using `async` and `await` correctly, you make your FastAPI apps *super efficient*, like a pro chef in a fast-paced kitchen, always juggling tasks without missing a beat! \n\n### 1.3. Best Practices for Asynchronous Programming\n\nWhen it comes to asynchronous programming, it‚Äôs not just about sprinkling `async` and `await` everywhere. There‚Äôs a bit of finesse to it‚Äîjust like any good recipe.\n\n1. **Know when to go async**:\n- Use async for **I/O-bound** tasks: things that need to wait for something external, like network requests or reading files.\n- Don‚Äôt go async for **CPU-bound** tasks (heavy number crunching), because while your function is churning away, you‚Äôre not gaining any advantage from async's multitasking magic.\n\n2. **Error handling in asynchronous functions**\n\nThink of error handling as catching a wayward dish before it hits the ground. In asynchronous code, make sure to wrap tasks in `try-except` blocks, so your event loop doesn‚Äôt trip over unhandled exceptions.\n\n<div style=\"text-align: center;\">\n  <img src=\"https://helper.beedev-services.com/images/python/try_and_except.png\" alt=\"FastAPI logo\" style=\"width: 400px;\">\n</div>\n\nHere‚Äôs how to handle errors asynchronously:\n```python\nasync def serve_dish():\n    try:\n        await bake_cake()\n    except OvenFailureException:\n        return {\"status\": \"Oven exploded! Call for help!\"}\n```\n\n1. **Simple try-except in an Asynchronous Function**\n\n```python\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/get-recipe\")\nasync def get_recipe():\n    try:\n        response = await httpx.get(\"https://random-recipes.com/cake\")\n        response.raise_for_status()  # Raise an error if the request failed\n        return {\"recipe\": response.json()}\n    except httpx.HTTPStatusError as e:\n        return {\"error\": f\"Recipe not available! Error: {e}\"}\n    except Exception as e:\n        return {\"error\": f\"Unexpected error occurred: {e}\"}\n```\n\nüî• **Explanation**: Here, we‚Äôre using `httpx` to make an asynchronous HTTP request. If the recipe website is down or returns an error, the `HTTPStatusError` exception will trigger, and we handle it smoothly without crashing the app.\n\n2. **Handling Multiple Exceptions**\n\nSometimes, different errors need different solutions. Let‚Äôs say your app reads data from a file and makes an HTTP request, both of which can fail in different ways.\n\n```python\nimport aiofiles  # Asynchronous file handling\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/read-data\")\nasync def read_data():\n    try:\n        # Try reading from a file asynchronously\n        async with aiofiles.open(\"data.txt\", mode=\"r\") as file:\n            contents = await file.read()\n        \n        # Then, make a web request for additional info\n        response = await httpx.get(\"https://api.example.com/data\")\n        response.raise_for_status()\n\n        return {\"file_data\": contents, \"api_data\": response.json()}\n\n    except FileNotFoundError:\n        return {\"error\": \"File not found. Please check the file path.\"}\n    except httpx.RequestError as e:\n        return {\"error\": f\"Failed to reach API: {e}\"}\n    except Exception as e:\n        return {\"error\": f\"An unexpected error occurred: {e}\"}\n```\n\nüî• **Explanation**: \n- **FileNotFoundError**: Happens if the file doesn‚Äôt exist. We handle this separately with a user-friendly message.\n- **httpx.RequestError**: Happens if the API request fails (e.g., bad connection). We give a clear message indicating the API issue.\n\n3. **Retry Mechanism with `try-except`**\n\nLet‚Äôs say you‚Äôre dealing with flaky internet, and you want to retry a failed task a couple of times before giving up. You can create a loop with retries inside your `try-except` block.\n\n```python\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/retry-request\")\nasync def retry_request():\n    retries = 3\n    for attempt in range(retries):\n        try:\n            response = await httpx.get(\"https://api.slow-server.com/data\")\n            response.raise_for_status()\n            return {\"data\": response.json()}\n        except httpx.RequestError as e:\n            if attempt < retries - 1:  # Only retry if we haven't exhausted attempts\n                continue\n            return {\"error\": f\"Failed after {retries} attempts. Error: {e}\"}\n```\n\nüî• **Explanation**: Here, the `try-except` block runs in a loop. If the request fails, the function will retry up to 3 times before giving up and returning an error.\n\n4. **Chaining `async` Calls with `try-except`**\n\nLet‚Äôs say you need to perform several asynchronous tasks, and you want to catch errors at different points.\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nasync def get_ingredients():\n    # Simulating an asynchronous function\n    return {\"flour\": 1, \"sugar\": 2, \"eggs\": 3}\n\nasync def prepare_dough(ingredients):\n    if \"eggs\" not in ingredients:\n        raise ValueError(\"Missing eggs!\")\n    # Pretend we're making dough\n    return \"dough prepared\"\n\n@app.get(\"/make-cake\")\nasync def make_cake():\n    try:\n        ingredients = await get_ingredients()\n        dough = await prepare_dough(ingredients)\n        return {\"status\": f\"{dough}, ready for baking!\"}\n    \n    except ValueError as e:\n        return {\"error\": f\"Invalid ingredients: {e}\"}\n    except Exception as e:\n        return {\"error\": f\"An unexpected error occurred: {e}\"}\n```\n\nüî• **Explanation**: \n- We first get ingredients asynchronously.\n- Then we prepare the dough asynchronously.\n- If there‚Äôs an issue (e.g., missing ingredients), we raise a **ValueError** and catch it, returning a helpful error message.\n\n5. **Nested `try-except` for More Granular Control**\n\nLet‚Äôs get more advanced. Sometimes, you need different try-except blocks for different stages of your async workflow.\n\n```python\nfrom fastapi import FastAPI\nimport aiofiles\n\napp = FastAPI()\n\n@app.get(\"/complex-process\")\nasync def complex_process():\n    try:\n        # Stage 1: File read\n        try:\n            async with aiofiles.open(\"input.txt\", mode=\"r\") as file:\n                contents = await file.read()\n        except FileNotFoundError:\n            return {\"error\": \"Input file missing!\"}\n        \n        # Stage 2: Process data\n        try:\n            # Fake processing step\n            if not contents:\n                raise ValueError(\"File is empty!\")\n            processed_data = contents.upper()\n        except ValueError as e:\n            return {\"error\": f\"Data processing failed: {e}\"}\n\n        # Stage 3: Return response\n        return {\"processed_data\": processed_data}\n\n    except Exception as e:\n        return {\"error\": f\"An unexpected error occurred: {e}\"}\n```\n\nüî• **Explanation**\n\nHere, we have different try-except blocks:\n\n1. **File reading** (handles file errors separately).\n\n2. **Data processing** (checks content validity).\n\n3. A final catch-all to handle anything unexpected.\n\nThis allows us to give very specific error messages, depending on where things go wrong.\n\nIn the world of FastAPI, asynchronicity is like having an army of chefs helping you cook multiple meals at once. You save time, resources, and keep things running smoothly. \n\nJust remember: \n\n> use async when it makes sense, manage your I/O carefully, and make sure you‚Äôve got error-handling oven mitts at the ready!\n\n## 2. Advanced Routing: The Map of Your FastAPI World\n\nRouting is the backbone of FastAPI‚Äîlike a GPS guiding every request to its destination. \n\nIn this part, we‚Äôll dive into routers, parameters, and middleware to organize and streamline your FastAPI applications.\n\nGet ready for a journey through the ‚Äúhighways‚Äù of FastAPI! üöóüí®\n\n### 2.1. Introduction to Routers\n\nLet‚Äôs start by breaking down routers. \n\nThink of them as different sections of a city: each router is responsible for handling related endpoints, like the \"shopping district\" or \"residential zone\" of your app.\n\nIn a simple project, you might only need a single `main.py` to handle all routes. But as your app grows, it becomes necessary to group routes logically‚Äîby features or services. FastAPI provides `APIRouter` to help you do just that.\n\nHere‚Äôs a basic example:\n\n```python\nfrom fastapi import FastAPI, APIRouter\n\napp = FastAPI()\n\n# Create a new router for user-related routes\nuser_router = APIRouter()\n\n@user_router.get(\"/users/\")\nasync def get_users():\n    return {\"users\": [\"M√©nyssa\", \"Eric\", \"Paul\"]}\n\n@user_router.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    return {\"user\": user_id}\n\n# Include the user_router in the main FastAPI app\napp.include_router(user_router)\n```\n\n**Current Project Structure**\n\nRight now, you have a very simple project structure:\n\n```bash\n‚îú‚îÄ‚îÄ env/\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ requirements.txt\n```\n\nLet‚Äôs refactor it to make use of routers. Create a folder to hold all your route files:\n\n```bash\n‚îú‚îÄ‚îÄ env/\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ routers/         # New folder to store routers\n‚îÇ   ‚îî‚îÄ‚îÄ users.py     # New file for user-related routes\n‚îú‚îÄ‚îÄ requirements.txt\n```\n\nInside `users.py`:\n\n```python\nfrom fastapi import APIRouter\n\nuser_router = APIRouter()\n\n@user_router.get(\"/users/\")\nasync def get_users():\n    return {\"users\": [\"Alice\", \"Bob\", \"Charlie\"]}\n\n@user_router.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    return {\"user\": user_id}\n```\n\nThen, include this router in `main.py`:\n\n```python\nfrom fastapi import FastAPI\nfrom routers.users import user_router\n\napp = FastAPI()\n\napp.include_router(user_router)\n```\n\nNow you‚Äôve separated concerns and logically grouped your endpoints. This makes your app easier to scale and maintain!\n\n**Organizing Endpoints into Logical Groups**\n\nYou can create more routers for different areas of your app, like `products.py` for managing a product catalog or `orders.py` for processing orders. This modular approach keeps things clean, especially as the number of endpoints grows.\n\n```bash\n‚îú‚îÄ‚îÄ env/\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ routers/\n‚îÇ   ‚îú‚îÄ‚îÄ users.py\n‚îÇ   ‚îú‚îÄ‚îÄ products.py\n‚îÇ   ‚îî‚îÄ‚îÄ orders.py\n‚îú‚îÄ‚îÄ requirements.txt\n```\n\nEach router becomes a dedicated zone of your app, handling its own logic. This modularity is a huge win for maintainability and scalability.\n\n### 2.2. Path Parameters and Query Parameters\n\nParameters allow users to send extra information with requests, making them more flexible and dynamic. [See also Lecture 1](/00_Lectures/01_Lecture.qmd)\n\n**Path Parameters**\n\nPath parameters are part of the URL. They let you capture dynamic parts of a route. For example, if you have `/users/{user_id}`, `{user_id}` is a path parameter.\n\n```python\n@user_router.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    return {\"user\": user_id}\n```\n\nüî• **Explanation**: Here, `user_id` is extracted from the URL and passed as an argument to the handler function.\n\n**Query Parameters**\n\nQuery parameters are key-value pairs that follow a `?` in the URL. They‚Äôre usually used to filter or sort data.\n\nFor example, if you have `/users?name=Paul`, `name` is a query parameter:\n\n```python\n@user_router.get(\"/users/\")\nasync def get_users(name: str = None):\n    if name:\n        return {\"filtered_user\": name}\n    return {\"users\": [\"M√©nyssa\", \"Eric\", \"Paul\"]}\n```\n\nüî• **Explanation**: Here, `name` is a query parameter that filters the list of users. If no `name` is provided, it returns the full list.\n\n**Validating Parameters with Dependency Injection**\n\nFastAPI's dependency injection system allows you to validate parameters before they reach the route handler. For example, you can use `Pydantic` models to validate query parameters:\n\n```python\nfrom pydantic import BaseModel\n\nclass UserQueryParams(BaseModel):\n    name: str\n    age: int\n\n@user_router.get(\"/search/\")\nasync def search_users(params: UserQueryParams):\n    return {\"name\": params.name, \"age\": params.age}\n```\n\nWith dependency injection, FastAPI will automatically validate the query parameters based on the `UserQueryParams` schema.\n\n### 2.3. Custom Routers and Middleware\n\nLet‚Äôs now explore how to extend routers and add middleware to handle more advanced use cases.\n\n**Creating Custom Routers for Specific Use Cases**\n\nYou can create custom routers for specific sections of your app, each with its own set of routes and logic. \n\nFor instance, let‚Äôs create an admin router with custom logic:\n\n```python\nfrom fastapi import APIRouter\n\nadmin_router = APIRouter()\n\n@admin_router.get(\"/admin/reports\")\nasync def get_admin_reports():\n    return {\"report\": \"Admin report data\"}\n```\n\nüî• **Explanation**: This custom router can be used to separate admin functionality from general user functionality. It helps ensure the right people access the right routes.\n\n**Implementing Middleware for Cross-Cutting Concerns**\n\nMiddleware is code that runs **before** or **after** each request. It‚Äôs great for logging, authentication, and other cross-cutting concerns.\n\nHere‚Äôs an example of middleware that logs the time taken for each request:\n\n```python\nfrom fastapi import FastAPI\nimport time\n\napp = FastAPI()\n\n@app.middleware(\"http\")\nasync def log_requests(request, call_next):\n    start_time = time.time()\n    response = await call_next(request)\n    duration = time.time() - start_time\n    print(f\"Request: {request.url}, Duration: {duration}s\")\n    return response\n```\n\nüî• **Explanation**: With this middleware, every request gets timed and logged. Middleware is powerful because it can intercept every request and response, applying logic that affects the entire app.\n\n**Bonus: Custom Error Handling with Middleware**\nYou can even use middleware for custom error handling. For example, you might want to catch all exceptions and return a custom error message:\n\n```python\n@app.middleware(\"http\")\nasync def custom_error_handling(request, call_next):\n    try:\n        return await call_next(request)\n    except Exception as e:\n        return JSONResponse(status_code=500, content={\"error\": str(e)})\n```\n\nüî• **Explanation**: This middleware catches any unhandled exceptions and returns a consistent error response to the client.\n\nBy organizing your FastAPI app into logical pieces and implementing advanced routing techniques, you'll keep your code clean and scalable‚Äîlike a well-mapped city! \n\n## 3. Database Dynamo: Powering Your App \n\nThis is the heart of most web applications : The database. \n\nIt's the powerful engine that drives the storage and retrieval of your data, and in this section, we'll explore how to set up, manage, and interact with databases in FastAPI.\n\n### 3.1. Choosing the Right Database\n\nChoosing the right database is like choosing the right vehicle for a road trip: \n\n> Do you want a rugged SUV (NoSQL) or a precision-engineered sports car (SQL)? \n\nIt all depends on the type of data, how it‚Äôs structured, and what you need in terms of performance.\n\n**SQL vs. NoSQL Databases**\n\n- **SQL**: Think of SQL databases like Excel sheets‚Äîthey‚Äôre great for structured data with clear relationships. You can run complex queries across multiple tables, and they're backed by solid ACID compliance (Atomicity, Consistency, Isolation, Durability). Common options include **PostgreSQL**, **MySQL**, and **SQLite**.\n\n‚û°Ô∏è **Use case**: Banking systems, e-commerce platforms where data integrity and relationships matter.\n\n- **NoSQL**: NoSQL databases, on the other hand, are more like dynamic, flexible containers. They can handle semi-structured or unstructured data like JSON documents. They scale horizontally, which means they work great with massive datasets.\n\n‚û°Ô∏è **Use case**: Social networks, real-time applications, or scenarios where data structure is constantly changing (e.g., **MongoDB**, **Cassandra**).\n\n**Popular Databases for FastAPI**\n\nWhen it comes to FastAPI, the database world is your oyster. Here are some great options:\n\n- **PostgreSQL**: The SQL superstar! It‚Äôs powerful, open-source, and works smoothly with FastAPI. Great for complex queries, relational data, and transactional applications.\n\n- **MongoDB**: NoSQL king! Ideal for flexible, large-scale applications where the structure isn‚Äôt rigid. Use it if you‚Äôre dealing with JSON-like data or want to easily scale horizontally.\n\n- **SQLite**: Lightweight and portable SQL option. Best for smaller applications or quick prototypes. It‚Äôs built into Python, so no additional setup required.\n\n**Analogy Time**: \n\n- **SQL databases** are like libraries, neatly organized with sections, rows, and books that reference other books (relational).\n\n- **NoSQL databases** are like a garage sale where things might not be perfectly organized, but you can grab what you need quickly (flexibility).\n\n### 3.2. SQLAlchemy and SQLModel\n\nFastAPI makes working with databases easy, thanks to **[SQLAlchemy](https://fastapi.tiangolo.com/tutorial/sql-databases/)** and **[SQLModel](https://sqlmodel.tiangolo.com/)**. \n\nLet‚Äôs break them down and see how they power up your database interactions.\n\n#### 3.2.1. Using SQLAlchemy for Database Interactions\n\nSQLAlchemy is one of the most powerful and flexible libraries for working with relational databases in Python. It gives you fine-grained control over every aspect of database interaction. \n\n<div style=\"text-align: center;\">\n  <img src=\"https://miro.medium.com/v2/resize:fit:720/format:webp/0*2gcZYBv6jmcbRtnY\" alt=\"FastAPI logo\" style=\"width: 400px;\">\n</div>\n\nIt‚Äôs an **ORM*** (Object Relational Mapper) that lets you work with databases in a Pythonic way‚Äîno more raw SQL queries unless you want to.\n\n::: {.callout-note title=\"Note: ORM\" collapse=\"true\"}\n**ORM stands for Object-Relational Mapper.** It's a programming technique that bridges the gap between object-oriented programming (OOP) and relational databases.\n\n**In simpler terms, an ORM allows you to interact with database tables as if they were objects in your programming language.** This means you can use familiar OOP concepts like classes, objects, and methods to create, read, update, and delete data in your database.\n\n**Here's how it works:**\n\n1. **Mapping:** The ORM defines a mapping between your object classes and database tables. This mapping specifies how properties of your objects correspond to columns in the database table.\n2. **Data Access:** You can use your object's methods to perform database operations. For example, to save an object, you might call a `save()` method. The ORM will automatically translate this into the appropriate SQL query to insert data into the database.\n3. **Data Retrieval:** To retrieve data from the database, you can query for objects based on certain criteria. The ORM will translate your query into SQL and return the results as objects.\n\n**Benefits of using ORMs:**\n\n* **Simplified development:** ORMs can significantly reduce the amount of boilerplate code needed to interact with databases.\n\n* **Improved productivity:** By using familiar OOP concepts, developers can work more efficiently and make fewer errors.\n\n* **Portability:** ORMs can often be used with different databases, making it easier to switch between systems.\n\n* **Abstraction:** ORMs provide a layer of abstraction between your application and the database, making your code more maintainable and easier to test.\n\n**Popular ORMs include:**\n\n* SQLAlchemy for Python\n* Hibernate for Java\n* Entity Framework for .NET\n* ActiveRecord for Ruby\n\n**By using an ORM, you can focus on building your application's logic without having to worry about the intricacies of SQL and database interactions.**\n\n:::\n\nLet's break this down step by step to make it super clear. We‚Äôll start with the basics of creating a table and then move into interacting with that table using SQLAlchemy.\n\n**1. Define a SQLAlchemy Model (Table Representation)**\n\nIn a database, a **table** stores data in rows and columns. In SQLAlchemy, we create a **model** that acts like a blueprint for a database table.\n\nWhat‚Äôs happening in the code:\n\n```python\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n```\n- **`create_engine`**: Think of this as your connection to the database. In this example, we‚Äôre using **SQLite**, which is a lightweight, file-based SQL database (though this could be PostgreSQL, MySQL, etc.). The engine is the bridge between SQLAlchemy and the actual database.\n- **`declarative_base`**: This is the starting point for any model in SQLAlchemy. We use it to define tables. The `Base` class lets SQLAlchemy know which classes (tables) should be mapped to the database.\n- **`sessionmaker`**: This is a factory for creating sessions, which are used to talk to the database (we‚Äôll get to sessions later).\n\n```python\n# Connect to a SQLite database (or PostgreSQL)\nengine = create_engine(\"sqlite:///mydb.db\")\nBase = declarative_base()\n```\n- **`engine = create_engine(\"sqlite:///mydb.db\")`**: This line creates the connection to the SQLite database, which is stored in a file called `mydb.db`. If you were using PostgreSQL, the string would look something like this:\n  ```python\n  engine = create_engine(\"postgresql://username:password@localhost/dbname\")\n  ```\n\n- **`Base = declarative_base()`**: This creates the base class `Base`, which we‚Äôll use to define all our tables (models) in the future.\n\n**2. Defining the `User` Table**\n\nNow, let‚Äôs create the **User** table:\n\n```python\n# Define a model representing a table\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True)\n```\nüî• **Explanation**: \n\n- **`class User(Base)`** defines a class `User` that inherits from `Base`. Each class in SQLAlchemy is mapped to a table in the database, so this class is our blueprint for the `users` table.\n- **`__tablename__ = \"users\"`** sets the table name to `\"users\"`. Whenever we query or modify data, this table name is used in the background.\n\nInside this class, we define **columns**, which are the fields in our table:\n- **`id = Column(Integer, primary_key=True, index=True)`** creates an `id` column in the table, which is an **integer**, the **primary key** (unique for each row), and indexed for fast lookups.\n- **`name = Column(String, index=True)`** creates a `name` column that stores **strings** (text) and is also indexed.\n\n**3. Create the Table in the Database**\n\nNow that we‚Äôve defined our `User` model, we need to actually create the table in the database:\n\n```python\n# Create the table in the database\nBase.metadata.create_all(bind=engine)\n```\nüî• **Explanation**: **`Base.metadata.create_all(bind=engine)`** tells SQLAlchemy to take all the models we‚Äôve defined (in this case, the `User` model) and create the corresponding tables in the database connected to `engine`. This will create the `users` table in `mydb.db`.\n\n**4.Interacting with the Database (CRUD Operations)**\n\nOnce our table is created, we can start performing **CRUD operations** (Create, Read, Update, Delete) to interact with our data.\n\nTo communicate with the database, we need a **session**. A session is like a temporary workspace where we can make changes to the database, and once we‚Äôre done, we can **commit** (save) those changes.\n\n```python\n# Create a session to interact with the database\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n```\nüî• **Explanation**: Here, we define **SessionLocal**, a session factory that will let us create sessions when we need them.\n\n**5. Adding Data to the Database**\n\nLet‚Äôs use this session to add a new user to the `users` table:\n\n```python\n# Create a session and add a new user\ndb = SessionLocal()\nnew_user = User(name=\"M√©nyssa\")\ndb.add(new_user)\ndb.commit()\ndb.close()\n```\nüî• **Explanation**: \n\n- **`db = SessionLocal()`**create a new session using `SessionLocal()`. This session allows us to interact with the database.\n- **`new_user = User(name=\"M√©nyssa\")`** create a new instance of the `User` model. In this case, we‚Äôre adding a user with the name **M√©nyssa**. The `id` column will be automatically generated because it‚Äôs a primary key.\n- **`db.add(new_user)`** add this new user to our session (this step only adds it to the session, not the database yet).\n- **`db.commit()`** saves (commits) the changes to the database. The new user is now stored in the `users` table.\n- **`db.close()`** close the session to free up resources.\n\n**Summary of CRUD Operations**\n\n1. **Define a SQLAlchemy Model** (This represents a table in your database):\n\n```python\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\n# Connect to a SQLite database (or PostgreSQL)\nengine = create_engine(\"sqlite:///mydb.db\")\nBase = declarative_base()\n\n# Define a model representing a table\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True)\n\n# Create the table in the database\nBase.metadata.create_all(bind=engine)\n\n# Create a session to interact with the database\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n```\n\n2. **Interacting with the Database**: Now that we‚Äôve created a table, let‚Äôs add some users:\n\n```python\n# Create a session and add a new user\ndb = SessionLocal()\nnew_user = User(name=\"Pierre\")\ndb.add(new_user)\ndb.commit()\ndb.close()\n```\n\nSQLAlchemy simplifies database interactions by letting you work with Python objects rather than raw SQL queries, making it easier to manage your app's data.\n\n#### 3.2.2. SQLModel: The Best of Both Worlds (SQLAlchemy + Pydantic)\n\nWhile SQLAlchemy is powerful, **SQLModel** takes things a step further by combining the simplicity of **Pydantic** (for data validation) and the power of SQLAlchemy.\n\nSQLModel is built on top of SQLAlchemy but introduces **Pydantic-style validation**. It takes the best parts of both worlds:\n- The powerful ORM capabilities of SQLAlchemy\n- The data validation magic of Pydantic\n\n> So, what does this mean? \nYou get to use SQLAlchemy‚Äôs robust features while reducing the boilerplate code, **and** you get automatic data validation.\n\n**1. Key Differences with SQLAlchemy:**\n\n- **Data Validation Built-In**: SQLModel integrates Pydantic‚Äôs data validation. This means that every time you define a model, it automatically validates the data for you.\n- **Less Boilerplate**: SQLModel cuts down on repetitive code. You don‚Äôt need to define columns manually like in SQLAlchemy; you can use Python‚Äôs type hints, making your code cleaner and easier to maintain.\n- **Declarative Syntax**: You define your models in a more **Pythonic** way, without needing to write repetitive column definitions.\n- **Pydantic + SQLAlchemy Integration**: SQLModel works seamlessly with FastAPI, because FastAPI is already built on Pydantic for data validation.\n\n**2. SQLModel Example Breakdown**\n\n```python\nfrom sqlmodel import SQLModel, Field, create_engine\n\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n```\nüî• **Explanation**: \n\n- **`SQLModel`** is the base class for all your models. It inherits from both **Pydantic** and **SQLAlchemy**, so it does the heavy lifting for you.\n\n- **`table=True`** tells SQLModel to treat this class as a **database table**. Without it, the class would just be a data model for validation purposes.\n\n- **Fields**:\n  - **`id: int = Field(default=None, primary_key=True)`**: Instead of defining the column type manually (like in SQLAlchemy), we use type hints (`int` for `id` and `str` for `name`) and the `Field` function from Pydantic for additional options like `primary_key=True`.\n  - **`name: str`**: This defines a simple `name` column with a `string` type.\n\nAlready, this feels cleaner and more Pythonic.\n\nHere‚Äôs a full script using **SQLModel** to create a SQLite database, define a `User` model, and perform basic CRUD operations.\n\nThis will give you a complete picture of how SQLModel works in practice:\n\n```python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom sqlmodel import SQLModel, Field, create_engine, Session, select\nimport uvicorn  # Import uvicorn to run the application\n\napp = FastAPI()\n\n# 1. Define the User model using SQLModel\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n\n# 2. Create the SQLite database engine\nDATABASE_URL = \"sqlite:///./mydb.db\"\nengine = create_engine(DATABASE_URL, echo=True)\n\n# 3. Create the database tables\nSQLModel.metadata.create_all(engine)\n\n# 4. Create a session to interact with the database\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n# Add a root route to prevent the 404 error\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Welcome to the User Management API!\"}\n\n# 5. Add a new user to the database\n@app.post(\"/users/\", response_model=User)\ndef create_user(name: str, session: Session = Depends(get_session)):\n    new_user = User(name=name)\n    session.add(new_user)\n    session.commit()\n    session.refresh(new_user)\n    return new_user\n\n# 6. Fetch all users from the database\n@app.get(\"/users/\", response_model=list[User])\ndef get_users(session: Session = Depends(get_session)):\n    statement = select(User)\n    results = session.exec(statement)\n    users = results.all()\n    return users\n\n# 7. Update a user in the database\n@app.put(\"/users/{user_id}\", response_model=User)\ndef update_user(user_id: int, new_name: str, session: Session = Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    user.name = new_name\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n    return user\n\n# 8. Delete a user from the database\n@app.delete(\"/users/{user_id}\")\ndef delete_user(user_id: int, session: Session = Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    session.delete(user)\n    session.commit()\n    return {\"detail\": \"User deleted\"}\n```\n\nüî• **Big, big Explanation**\n\nLet's break down the key parts of your FastAPI script to provide a clear understanding of its structure and functionality:\n\n1. **Imports**\n```python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom sqlmodel import SQLModel, Field, create_engine, Session, select\nimport uvicorn  # Import uvicorn to run the application\n```\n- **FastAPI**: The main framework used to create the API.\n- **Depends**: A helper to declare dependencies for your path operations (like database sessions).\n- **HTTPException**: Used to raise HTTP errors with a specified status code and message.\n- **SQLModel**: A library that combines Pydantic and SQLAlchemy for data modeling and database operations.\n- **Field**: A function to define the fields of a SQLModel class.\n- **create_engine**: Used to create a database engine.\n- **Session**: Represents a workspace for interacting with the database.\n- **select**: A function used to create SQL SELECT statements.\n- **uvicorn**: An ASGI server used to run your FastAPI application.\n\n2. **Creating the FastAPI App**\n```python\napp = FastAPI()\n```\n- **FastAPI Instance**: This line initializes the FastAPI application. This instance will handle all the incoming requests.\n\n3. **Defining the User Model**\n```python\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n```\n- **User Class**: This class defines the `User` model as a database table.\n- **`table=True`**: Indicates that this class should be treated as a database table.\n- **Fields**:\n  - **`id`**: An integer that serves as the primary key (automatically incremented).\n  - **`name`**: A string representing the user's name.\n\n4. **Creating the Database Engine**\n```python\nDATABASE_URL = \"sqlite:///./mydb.db\"\nengine = create_engine(DATABASE_URL, echo=True)\n```\n- **DATABASE_URL**: Specifies the connection string for the SQLite database (using a file named `mydb.db`).\n- **`create_engine`**: Creates the database engine that allows the application to interact with the database. The `echo=True` flag enables logging of all the generated SQL statements.\n\n5. **Creating Database Tables**\n```python\nSQLModel.metadata.create_all(engine)\n```\n- This line creates all tables defined in the SQLModel classes in the database. If the table already exists, it will not be recreated.\n\n6. **Creating a Database Session**\n```python\ndef get_session():\n    with Session(engine) as session:\n        yield session\n```\n- **`get_session` function**: A generator function that creates a database session for each request. It ensures that the session is properly managed (opened and closed).\n\n7. **Root Route**\n```python\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Welcome to the User Management API!\"}\n```\n- **Root Endpoint**: A simple GET endpoint that returns a welcome message. This prevents the 404 error when accessing the root URL.\n\n8. **Adding a New User**\n```python\n@app.post(\"/users/\", response_model=User)\ndef create_user(name: str, session: Session = Depends(get_session)):\n    new_user = User(name=name)\n    session.add(new_user)\n    session.commit()\n    session.refresh(new_user)\n    return new_user\n```\n- **POST Endpoint**: Adds a new user to the database.\n- **`name: str`**: The name of the user is received as a path parameter.\n- **`session: Session = Depends(get_session)`**: Injects a session dependency into the function.\n- **Creating and Committing**: The new user is created, added to the session, committed to the database, and returned as a response.\n\n9. **Fetching All Users**\n```python\n@app.get(\"/users/\", response_model=list[User])\ndef get_users(session: Session = Depends(get_session)):\n    statement = select(User)\n    results = session.exec(statement)\n    users = results.all()\n    return users\n```\n- **GET Endpoint**: Fetches all users from the database.\n- **SQL Select Statement**: Uses the `select` function to create a query and executes it.\n- **Returns**: A list of all user records.\n\n10. **Updating a User**\n```python\n@app.put(\"/users/{user_id}\", response_model=User)\ndef update_user(user_id: int, new_name: str, session: Session = Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    user.name = new_name\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n    return user\n```\n- **PUT Endpoint**: Updates the name of an existing user identified by `user_id`.\n- **Error Handling**: If the user is not found, raises a 404 HTTP exception.\n- **Session Management**: Updates the user object, commits changes, and returns the updated user.\n\n11. **Deleting a User**\n```python\n@app.delete(\"/users/{user_id}\")\ndef delete_user(user_id: int, session: Session = Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    session.delete(user)\n    session.commit()\n    return {\"detail\": \"User deleted\"}\n```\n- **DELETE Endpoint**: Deletes the user identified by `user_id`.\n- **Error Handling**: If the user is not found, raises a 404 HTTP exception.\n- **Session Management**: Deletes the user and commits the changes.\n\nThe use of FastAPI's dependency injection for database sessions and structured error handling ensures a robust application. Each endpoint is clearly defined and returns data in a structured format, making it easy to use and extend.\n\n**5. Why Use SQLModel in FastAPI Projects?**\n\nSQLModel was designed with **FastAPI** in mind. Here‚Äôs why it‚Äôs a great fit for FastAPI projects:\n\n- **Seamless Integration with FastAPI**: Both FastAPI and SQLModel use **Pydantic** under the hood, so the models you define in SQLModel work perfectly with FastAPI‚Äôs request/response validation system.\n- **Automatic Data Validation**: SQLModel automatically validates incoming and outgoing data, which fits beautifully with FastAPI‚Äôs validation-first philosophy.\n- **Reduced Boilerplate**: You write less code compared to raw SQLAlchemy. For example, you don‚Äôt need to specify columns explicitly, and everything integrates smoothly with FastAPI.\n\n#### 3.2.3 Summary: SQLAlchemy vs. SQLModel\n\n| Feature                    | SQLAlchemy                              | SQLModel                                      |\n|----------------------------|-----------------------------------------|-----------------------------------------------|\n| **Data Validation**         | Separate (manually or with Pydantic)    | Built-in with Pydantic                       |\n| **Syntax**                  | More verbose (manually define columns)  | Simpler, using Python type hints             |\n| **FastAPI Integration**     | Works, but not designed for it          | Seamlessly integrated                        |\n| **Boilerplate Code**        | More boilerplate (defining columns)     | Less boilerplate (uses type hints + Pydantic)|\n| **Primary Use Case**        | Large, complex applications             | FastAPI apps, quick development              |\n\nIn essence, **SQLAlchemy** gives you more control for complex applications, but if you‚Äôre working with **FastAPI**, **SQLModel** makes everything cleaner, simpler, and faster‚Äî**without sacrificing power**. It's like having a Swiss Army knife that's perfectly sharpened for FastAPI's needs.\n\n### 3.3 Database Migrations (Optional)\n\nDatabase migrations are crucial for managing changes to your database schema as your application evolves. \n\n#### 3.1. Managing Database Schema Changes\n\n**[Alembic](https://jod35.github.io/fastapi-beyond-crud-docs/site/chapter7/?h=alembic#database-migrations-with-alembic)** is a lightweight database migration tool for use with SQLAlchemy. It helps you version control your database schema changes and makes it easier to apply these changes across different environments.\n\n**Key Features of Alembic:**\n\n1. **Version Control**: Each migration script is like a **bookmark** in your tree‚Äôs growth. It tells you exactly how the branches have changed over time. You can easily look back to see when a new feature was added or an old one was removed.\n\n2. **Autogeneration**: With Alembic, you don‚Äôt have to manually write every migration script. It‚Äôs like having a **smart assistant** who automatically detects changes in your models and drafts the migration scripts for you. Imagine saying, ‚ÄúHey Alembic, I added a new leaf!‚Äù and it responds with a complete plan to incorporate that leaf into your tree.\n\n3. **Consistent Environments**: Alembic ensures that whether you‚Äôre working in your cozy development environment or the bustling production stage, everyone is looking at the same beautiful tree. It keeps all developers and environments in sync, avoiding those dreaded ‚ÄúIt works on my machine!‚Äù moments.\n\n**The Power of Alembic in Your Hands**\n\nWhile Alembic might feel optional for small projects, it‚Äôs like having a **safety net** when you decide to jump into more complex applications. \n\nImagine you‚Äôve planted a tiny sapling today, but a year later, it‚Äôs a full-fledged tree with multiple branches‚Äîsome may need to be reshaped or removed. \n\nBy implementing Alembic from the start, you save yourself from headaches down the line as your application grows.\n\nSo, whether you're just starting out or scaling to new heights, think of Alembic as your trusty tool to manage database changes, keeping everything neat, organized, and growing beautifully! \n\n#### 3.2. Step-by-Step Guide\n\n**1. Installing Alembic**\n\nFirst, install Alembic via pip:\n\n```bash\npip install alembic\n```\n\n**2. Setting Up Alembic**\n\nInitialize Alembic in your FastAPI project. Run this command in your terminal:\n\n```bash\nalembic init alembic\n```\n\nThis creates a new directory called `alembic`, which contains configuration files and a folder for your migration scripts.\n\n**3. Configuring Alembic**\n\nIn the `alembic.ini` file, set the database URL to match your FastAPI project:\n\n```ini\n[alembic]\n# A generic, single database configuration.\nsqlalchemy.url = sqlite:///./mydb.db\n```\nYou should also modify the `env.py` file in the `alembic` folder to work with SQLModel. Replace the line:\n\n```python\nfrom myapp import mymodel\n```\n\nwith:\n\n```python\nfrom myapp.models import User  # Import your SQLModel classes here\n```\n\nMake sure to import the base metadata:\n\n```python\nfrom sqlmodel import SQLModel\n\ntarget_metadata = SQLModel.metadata\n```\n\n**4. Creating a Migration**\n\nWhen you modify your models (for example, adding a new column), create a migration script:\n\n```bash\nalembic revision --autogenerate -m \"Add email column to users\"\n```\n\nThis command creates a new migration file in the `alembic/versions` directory with the changes detected by Alembic.\n\n**Example: Adding an Email Column to User Model**\n\nLet‚Äôs say you want to add an `email` column to your `User` model. Update your `User` model like this:\n\n```python\nfrom sqlmodel import SQLModel, Field\n\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n    email: str = Field(default=None)  # New email field\n```\n\nAfter saving this change, run the Alembic command to generate a migration:\n\n```bash\nalembic revision --autogenerate -m \"Add email column to users\"\n```\n\nAlembic generates a migration script similar to the following:\n\n```python\n\"\"\"Add email column to users\n\nRevision ID: 123456789abc\nRevises: previous_revision_id\nCreate Date: 2024-10-11 12:00:00.000000\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\nfrom sqlmodel import SQLModel\n\n# revision identifiers, used by Alembic.\nrevision = '123456789abc'\ndown_revision = 'previous_revision_id'\nbranch_labels = None\ndepends_on = None\n\ndef upgrade():\n    # Adding the email column\n    op.add_column('user', sa.Column('email', sa.String(), nullable=True))\n\ndef downgrade():\n    # Dropping the email column\n    op.drop_column('user', 'email')\n```\n\n**5. Applying the Migration**\n\nOnce you‚Äôve created the migration script, apply it to your database:\n\n```bash\nalembic upgrade head\n```\n\nThis command runs the `upgrade` function in your migration script, applying the changes to your database.\n\nBy following these steps, you can effectively manage your database schema changes as your application grows and evolves. Now that we have a robust migration strategy in place, it‚Äôs time to delve into more advanced topics that enhance our application‚Äôs architecture and functionality.\n\n\n## 4. Advanced Topics Toolbox (Very advanced, so very optional)\n\nYou‚Äôve made it this far‚Äîwell done! üéâ\n\nNow we‚Äôre diving into the supercharged section, where we tackle some **seriously advanced topics** in FastAPI. \n\nThese are the power tools that can turn you from a solid developer into a FastAPI **wizard**. \n\nThey‚Äôre optional, but if you‚Äôre up for the challenge, you‚Äôll come out with a toolbox of knowledge that will let you **build, secure, and optimize** APIs like a pro.\n\nLet‚Äôs open the toolbox:\n\n### 4.1. Dependency Injection\n> \"Why do we need it?\"  \nThink of **dependency injection** like getting a superpower to \"inject\" exactly what your code needs, when it needs it, without unnecessary clutter! It‚Äôs all about clean, maintainable code that scales with your project. \n\n- **Understanding Dependency Injection in FastAPI**  \nYou‚Äôll see how FastAPI makes managing dependencies a breeze. Instead of cluttering up your logic with repetitive calls, you inject them cleanly.\n\n- **Using `fastapi.Depends` for Dependency Injection**  \nYou‚Äôll learn how to simplify your code by using the `Depends` method‚Äîlike ordering takeout for your app‚Äôs resources instead of cooking every time.\n\n- **Creating Custom Dependencies**  \nWhy stop at the basics? Learn to create your own custom dependencies, from database connections to third-party API calls.\n\n#### 4.1.1 What is Dependency Injection (DI)?\n\nIn FastAPI, DI helps you inject dependencies into your routes and functions without having to create them manually each time.\n\nThe magic happens using **`Depends`**.\n\n#### 4.1.2 FastAPI's `Depends` in Action\n\nFastAPI uses **`Depends`** to handle dependency injection in a clean and Pythonic way. Let's look at how it works:\n\n```python\nfrom fastapi import FastAPI, Depends\n\napp = FastAPI()\n\n# Define a dependency\ndef get_db_connection():\n    return {\"db\": \"connected\"}\n\n# Use the dependency in an endpoint\n@app.get(\"/items/\")\ndef read_items(db_conn = Depends(get_db_connection)):\n    return {\"message\": f\"Database status: {db_conn['db']}\"}\n```\n\nüî• **Explanation**:\n\n- **`get_db_connection()`**: This function simulates connecting to a database.\n- **`Depends(get_db_connection)`**: The `Depends()` function calls our dependency and \"injects\" its return value into the route.\n- Now, the `db_conn` variable has access to the database connection without having to create it inside the route.\n\n#### 4.1.3 Custom Dependencies\n\nFastAPI isn‚Äôt just limited to database connections! You can create your own custom dependencies to manage **authentication**, **logging**, **configuration**, and more.\n\nLet's build a simple *authorization* dependency:\n\n```python\nfrom fastapi import HTTPException, Header\n\ndef verify_token(x_token: str = Header(...)):\n    if x_token != \"supersecrettoken\":\n        raise HTTPException(status_code=403, detail=\"Invalid token\")\n    return True\n\n@app.get(\"/secure-data/\")\ndef secure_data(token = Depends(verify_token)):\n    return {\"message\": \"You have access to secure data!\"}\n```\n\nüî• **Explanation**:\n\n- **`verify_token()`**: This function checks if the token provided in the `x_token` header is correct.\n\n- **`Depends(verify_token)`**: If the token is valid, the user can access the secure route. If not, it raises an error.\n\n### 4.2. Testing FastAPI Applications\n> \"Your code works... but does it really?\"  \nTesting is like **proofreading** for developers. Sure, your app runs on your machine, but what about production? What about edge cases? ü§î\n\n- **Unit Testing, Integration Testing, and API Testing**  \nGet familiar with different types of tests and when to use them. Unit tests are like checking individual LEGO bricks, while integration tests check the full LEGO model.\n\n- **Using Tools like pytest for Testing**  \nLearn the magic of `pytest`‚Äîyour testing buddy! From simple tests to mocking dependencies, we‚Äôll cover it all.\n\n#### 4.2.1 Why is Testing Important?\n\nImagine launching a rocket without checking if all the parts work‚Äîscary, right?\nIn development, it‚Äôs the same! Testing ensures that your code behaves as expected, so you don‚Äôt end up with unexpected bugs in production.\n\n**Types of Testing** :\n\n1. **Unit Testing**: Test individual components of your code (e.g., a function or a class) to make sure they behave correctly in isolation.\n2. **Integration Testing**: Test how different parts of your application work together (e.g., database, API, external services).\n3. **API Testing**: Specifically focus on testing the endpoints of your FastAPI app to ensure they return the right responses and handle errors gracefully.\n\n#### 4.2.2 Setting Up Pytest\n\nFastAPI plays well with **pytest**, one of the most popular testing frameworks in Python. It‚Äôs simple, powerful, and easy to integrate.\n\n1. **Install pytest**:\n```bash\npip install pytest\n```\n\n2. **Install TestClient from FastAPI**:\nFastAPI has a built-in **TestClient** (powered by Starlette) that you can use to send HTTP requests during testing.\n\n```bash\npip install httpx\n```\n\n#### 4.2.3 Writing Your First Unit Test\n\nLet‚Äôs start small by writing a unit test for a simple FastAPI route.\n\n**Here‚Äôs your API:**\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/hello/\")\ndef read_hello():\n    return {\"message\": \"Hello, World!\"}\n```\n\n**Writing the Test:**\n\n```python\nfrom fastapi.testclient import TestClient\nfrom myapp import app  # Assuming your app is defined in 'myapp.py'\n\nclient = TestClient(app)\n\ndef test_read_hello():\n    response = client.get(\"/hello/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello, World!\"}\n```\n\nüî• **Explanation**:\n\n- **TestClient**: This allows us to simulate HTTP requests to the FastAPI app during tests.\n- **`client.get(\"/hello/\")`**: We send a GET request to the `/hello/` route.\n- **Assertions**: We check if the response‚Äôs status code is 200 (OK) and if the response data matches `{\"message\": \"Hello, World!\"}`.\n\n\n#### 4.2.4 Writing Integration Tests\n\nNow, let‚Äôs take things up a notch. We‚Äôll write an integration test for an endpoint that interacts with a database.\n\n**API to Test:**\n\n```python\nfrom fastapi import FastAPI, Depends\nfrom sqlmodel import SQLModel, Session, create_engine, Field, select\n\napp = FastAPI()\n\nclass User(SQLModel, table=True):\n    id: int = Field(primary_key=True)\n    name: str\n\nengine = create_engine(\"sqlite:///./test.db\")\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n@app.post(\"/users/\")\ndef create_user(name: str, session: Session = Depends(get_session)):\n    user = User(name=name)\n    session.add(user)\n    session.commit()\n    return user\n```\n\n**Writing the Integration Test**:\n\n```python\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlmodel import SQLModel, Session\nfrom myapp import app, engine\n\nclient = TestClient(app)\n\n@pytest.fixture\ndef setup_db():\n    # Set up the database before each test\n    SQLModel.metadata.create_all(engine)\n    yield\n    # Tear down the database after each test\n    SQLModel.metadata.drop_all(engine)\n\ndef test_create_user(setup_db):\n    response = client.post(\"/users/\", json={\"name\": \"Alice\"})\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"name\"] == \"Alice\"\n    assert \"id\" in data  # Check that the user has an id\n```\n\nüî• **Explanation**:\n\n- **`setup_db()`**: A pytest fixture that sets up and tears down the database for each test. This ensures that your tests always start with a clean slate.\n- **Integration Test**: We simulate a POST request to create a new user and verify that the response data contains the expected user name and a generated ID.\n\n#### 4.2.5 Mocking Dependencies in Tests\n\nSometimes, you don‚Äôt want to test every part of your app during unit tests. Maybe you don‚Äôt want to hit the actual database but want to **mock** the database connection instead. Here‚Äôs how you can do it:\n\n```python\nfrom unittest.mock import MagicMock\nfrom fastapi import Depends\n\ndef fake_get_session():\n    db = MagicMock()  # Mocked database session\n    yield db\n\n@app.post(\"/fake-user/\")\ndef create_fake_user(name: str, session = Depends(fake_get_session)):\n    session.add(name)  # Add a name to the mocked session\n    return {\"message\": f\"User {name} added\"}\n```\n\nüî• **Explanation**:\n\n- **`MagicMock()`**: A utility from the `unittest` library that allows us to mock dependencies like database connections.\n- **Fake Dependency**: We use the fake session during testing to ensure we don‚Äôt interact with the real database.\n\n#### 4.2.6 Testing Summary\n\n- **Unit tests**: Test individual components in isolation.\n- **Integration tests**: Ensure that different parts of your app work well together.\n- **TestClient**: Allows you to simulate HTTP requests to your FastAPI app.\n- **Pytest**: A powerful testing framework that integrates seamlessly with FastAPI.\n- **Mocking**: Helps you isolate your tests from real dependencies.\n\n### 4.3. Security in FastAPI\n> \"Locks on the door, security cameras on the house.\"  \nSecurity is **non-negotiable**. No one wants their API hacked or misused! You‚Äôll learn how to **protect** your FastAPI app from common vulnerabilities.\n\n> > \"Who are you? And what are you allowed to do?\"  \nFastAPI makes handling **authentication** and **authorization** simple, but don‚Äôt be fooled‚Äîit‚Äôs a crucial topic.\n\n\n- **Authentication and Authorization**  \nKeep the wrong people out and make sure the right people can only do what they‚Äôre supposed to do.\n\n- **Protecting Against Common Vulnerabilities**  \nWe‚Äôll go over real-world threats like **SQL injection**, **XSS**, and **CSRF**, and how to defend against them. Think of it as locking all the windows before leaving your house. \n\n- **Input Validation and Sanitization**  \nClean your data like you‚Äôd wash your hands‚Äîalways! No messy, untrusted input allowed.\n\n- **Secure Coding Practices**  \nIt‚Äôs like learning to cook without burning your kitchen down. Follow best practices to keep your app safe.\n\n#### 4.3.1 The Importance of Security in APIs \n\nYour API is like the front door to your application, and just like your house, you want to make sure it's locked and secure. Poor security practices can expose sensitive data, compromise user privacy, and leave your app vulnerable to attacks. With FastAPI, implementing security features is not only crucial but also relatively straightforward.\n\n#### 4.3.2 **Authentication vs. Authorization**\n\n- **Authentication**: Who are you? Authentication is the process of verifying the identity of a user or system.\n- **Authorization**: What are you allowed to do? Authorization is about determining what actions a verified user can perform.\n\nThink of authentication as checking a ticket at a concert and authorization as making sure you can access the VIP lounge.\n\n**Authentication in FastAPI**\n\nFastAPI provides several methods for authentication. One of the most popular and secure ways is **token-based authentication** using JWT (JSON Web Tokens). Let's dive into an example:\n\n1. **Installing the Required Package**:\n    ```bash\n    pip install pyjwt\n    ```\n\n2. **Creating the Token**:\nHere's how you can generate and validate a JWT for user authentication.\n\n```python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\napp = FastAPI()\n\n# Secret key to encode/decode JWT\nSECRET_KEY = \"mysecretkey\"\nALGORITHM = \"HS256\"\n\n# Mock user database\nfake_users_db = {\n    \"user1\": {\"username\": \"user1\", \"hashed_password\": \"fakehashedpassword\"}\n}\n\n# OAuth2 scheme\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\ndef create_access_token(data: dict):\n    \"\"\"Create JWT token.\"\"\"\n    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)\n\n@app.post(\"/token\")\ndef login(form_data: OAuth2PasswordRequestForm = Depends()):\n    \"\"\"Login and return JWT token.\"\"\"\n    user = fake_users_db.get(form_data.username)\n    if not user:\n        raise HTTPException(status_code=400, detail=\"Invalid credentials\")\n        \n        # Generate token with user data\n    token = create_access_token({\"sub\": form_data.username})\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n\n@app.get(\"/users/me\")\ndef get_user(token: str = Depends(oauth2_scheme)):\n    \"\"\"Get current user based on JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n        return {\"username\": username}\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n```\nüî• **Explanation**:\n\n- **JWT Token**: A JWT token is generated when a user logs in, and this token is used to authenticate the user in future requests.\n- **OAuth2PasswordBearer**: FastAPI's built-in method to handle OAuth2-based authentication, which works perfectly with JWT.\n- **Token Endpoint**: `/token` is where users will exchange their credentials for a token.\n- **Token Validation**: The token is decoded on subsequent requests to validate the user‚Äôs identity.\n\n**Authorization: Controlling Access**\n\nOnce you have authentication in place, the next step is**authorization‚Äîmaking sure users can only access what they are allowed to**.\n\nLet‚Äôs add some roles to our users and restrict certain routes based on these roles:\n\n```python\nfrom fastapi import Depends\n\nroles_db = {\n    \"user1\": {\"role\": \"admin\"},\n    \"user2\": {\"role\": \"user\"}\n}\n\ndef get_current_user(token: str = Depends(oauth2_scheme)):\n    payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n    username: str = payload.get(\"sub\")\n    return roles_db.get(username)\n\n@app.get(\"/admin/\")\ndef admin_area(user: dict = Depends(get_current_user)):\n    if user[\"role\"] != \"admin\":\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    return {\"message\": \"Welcome to the admin area\"}\n```\n\nüî• **Explanation**:\n\n- **Roles**: We've assigned roles (e.g., \"admin\", \"user\") to each user.\n- **Authorization Check**: We use the user‚Äôs role to allow or deny access to specific routes like `/admin/`.\n\n#### 4.3.3 Protecting Against Common Vulnerabilities\n\nIn addition to authentication and authorization, it's important to protect your FastAPI app against common security threats:\n\n- **SQL Injection**: Use parameterized queries or an ORM like SQLModel to avoid exposing your app to malicious SQL injection attacks.\n\n```python\n@app.get(\"/users/\")\ndef get_users(name: str, session: Session = Depends(get_session)):\n    statement = select(User).where(User.name == name)\n    return session.exec(statement).all()\n```\n\n- **Cross-Site Scripting (XSS)**: Always sanitize user inputs that are rendered back in the UI, especially if you're interacting with frontend components.\n- **Cross-Site Request Forgery (CSRF)**: FastAPI doesn‚Äôt include CSRF protection by default, but you can integrate external packages or implement custom middleware to guard against CSRF attacks.\n\n- **Input Validation**: FastAPI‚Äôs **Pydantic** models help you validate and sanitize inputs automatically. You should always ensure that the data users submit conforms to the expected format.\n\n```python\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr  # This ensures a valid email format\n```\n#### 4.3.4 Secure Coding Practices\n\nFollow these best practices to keep your code secure:\n\n1. **Limit Exposure**: Only expose the routes that are necessary and avoid allowing external access to sensitive routes (e.g., admin areas).\n2. **Use HTTPS**: Always deploy your FastAPI application with HTTPS in production to encrypt all data between the client and server.\n3. **Update Dependencies**: Regularly update your dependencies to ensure you‚Äôre using the latest security patches.\n4. **Environment Variables**: Store sensitive information (like database credentials and secret keys) in environment variables, not in your codebase.\n5. **Logging**: Set up proper logging to monitor and detect suspicious activity.\n\n\n### 4.4. Performance Optimization\n> \"Faster is always better, right?\"  \nSpeed is **key** when building APIs. Let‚Äôs make sure your FastAPI app can handle the pressure‚Äîwhether it's 10 users or 10,000.\n\nNow that you've built a secure and functional FastAPI app, it's time to make it *fly* by focusing on performance optimization! Whether your app is running a high-traffic API, managing real-time data, or simply needs to be more responsive, performance optimization can make a big difference in user experience.\n\n#### 4.4.1 Why Optimize?\n\nImagine you‚Äôre using a writing app that checks your spelling and grammar in real time.\n\nAs you type, you expect instant feedback‚Äîcorrections popping up seamlessly as you go. But what if there‚Äôs a lag? \n\nYou write a sentence, and the corrections take five seconds to appear. It throws off your rhythm, you lose focus, and eventually, you might give up on the app altogether.\n\nThat‚Äôs how your users feel when your FastAPI app is slow.\n\nThey expect things to work instantly, especially for real-time features. If your app can‚Äôt keep up with the demand, they‚Äôll find another tool that can. This lesson will teach you how to optimize your FastAPI app so it stays responsive, even when it's processing a lot of requests at once.\n\n#### 4.4.2. Caching Strategies: Save Time, Repeat Less\n\nWhen your app processes the same requests repeatedly, caching can be a lifesaver. Instead of recalculating or re-fetching data for every request, caching lets you store previously computed responses and serve them up super fast.\n\n**Example: Caching with `fastapi-cache`**\n\n1. **Installing the Required Package**:\n```bash\npip install fastapi-cache2\n```\n\n2. **Implementing Basic Caching**:\nHere's a simple way to cache the response of an endpoint using `fastapi-cache2`:\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi_cache import FastAPICache\nfrom fastapi_cache.backends.redis import RedisBackend\nimport redis\n\napp = FastAPI()\n\n@app.on_event(\"startup\")\nasync def startup():\n    redis_client = redis.Redis(host=\"localhost\", port=6379)\n    FastAPICache.init(RedisBackend(redis_client), prefix=\"fastapi-cache\")\n\n@app.get(\"/items/{item_id}\")\n@FastAPICache(expire=60)  # Cache this response for 60 seconds\nasync def get_item(item_id: int):\n# Imagine this is an expensive operation like a database call\n    return {\"item_id\": item_id, \"description\": \"This is an item.\"}\n```\n\nüî• **Explanation**:\n- **Redis**: We use Redis as a caching backend. Redis is a super fast in-memory data structure store, perfect for caching.\n- **FastAPICache**: This decorator caches the response of the `/items/{item_id}` endpoint for 60 seconds.\n\n**Why Caching Matters**:\n\n- **Faster Responses**: By storing responses, you reduce the time it takes to fetch data.\n- **Reduced Server Load**: You‚Äôre not hitting your database or performing expensive operations on every request.\n\n#### 4.4.3. Asynchronous Optimization: Handling Many Requests Like a Champ\n\nFastAPI shines when it comes to asynchronous programming. Unlike traditional synchronous frameworks, FastAPI can handle multiple requests concurrently, which means it‚Äôs great for high-performance use cases. [See in section 1. The magic of Asynchronicity](#the-magic-of-asynchronicity)\n\n#### 4.4.4. Profiling and Benchmarking: Measure Before You Improve\n\nYou can‚Äôt improve what you don‚Äôt measure! Profiling and benchmarking tools help you identify performance bottlenecks in your application so you know exactly where optimizations are needed.\n\n**Tools for Profiling**:\n- **cProfile**: Python‚Äôs built-in profiler.\n- **py-spy**: A sampling profiler that can show you where your app is spending most of its time, even in production.\n\n**Example: Using `py-spy`**\n\n1. **Installing `py-spy`**:\n    ```bash\n    pip install py-spy\n    ```\n\n2. **Profiling your FastAPI app**:\n    ```bash\n    py-spy top -- python3 -m uvicorn main:app\n    ```\n\nThis will show you a live breakdown of where your app is spending its CPU time. You can use this information to pinpoint slow parts of your code, like that unoptimized database query or the slow for-loop.\n\n**Example: Measuring Latency with `timeit`**\n\nHere‚Äôs a quick way to measure the latency of an endpoint using the `timeit` module:\n\n```python\nimport timeit\n\ndef measure():\n    return requests.get(\"http://localhost:8000/some-endpoint\")\n\nprint(timeit.timeit(measure, number=10))  # Run the request 10 times\n```\nRemember, this section is optional but packed with advanced, exciting tools to supercharge your FastAPI skills! \n\n## In Summary \n\n### Asynchronicity: The Key to Responsiveness\nUnderstanding asynchronous programming allows your FastAPI applications to handle multiple requests simultaneously, making them faster and more efficient. By leveraging `async` and `await`, your app can juggle tasks like a seasoned performer!\n\n### Routing: Navigating the API Landscape\nRouting is crucial for directing requests to the appropriate endpoints. You‚Äôve learned how to set up routes effectively, ensuring your users can access the functionality they need without a hitch.\n\n### Database Integration: Persistence Made Easy\nWe explored how to connect your FastAPI app with a database using SQLModel. By mastering CRUD operations, you can create, read, update, and delete data effortlessly, paving the way for dynamic applications.\n\n### Advanced Topics Toolbox: Powering Up Your Skills\nWe touched on various advanced topics, including dependency injection, testing, security measures, and performance optimization. These tools are essential for creating robust, secure, and high-performing applications that can handle the demands of modern users.\n\nNow that we‚Äôve covered the advanced topics, let‚Äôs dive into **[Lab 2](../01_Exercises/02_Lab.qmd)** and make your FastAPI apps **secure, fast, and scalable**! üí™\n","srcMarkdownNoYaml":"\n\n## TL;DR:\n\nIf you're short on time, you can listen to the key takeaways from the course in this audio summary:\n\n\n<div style=\"text-align: center;\">\n  <figure>  \n    <figcaption>Listen to the Audio Overview:</figcaption>  \n    <audio controls src=\"02_Podcast.wav\"></audio>  \n    <br>\n    <button class=\"download-btn\" onclick=\"window.location.href='02_Podcast.wav'\">Download audio</button>  \n  </figure>\n</div>\n\nIn this lecture, we cover key concepts to enhance your FastAPI development skills:\n\n- **Asynchronous Programming** improves performance by handling multiple tasks simultaneously.\n- **Routing** maps URLs to code, ensuring easy navigation within your API.\n- **Databases** are essential for efficient data storage and retrieval in your applications.\n- **Dependency Injection** promotes modularity, making code easier to maintain and test.\n- **Testing** with tools like `pytest` ensures your application functions as expected.\n- **Security** through authentication and authorization protects your API from unauthorized access.\n- **Performance Optimization** techniques, such as caching and async enhancements, ensure efficiency under heavy load.\n---\n\n**Your API is a bustling city.**\n\nEach street represents a different route, leading to specific destinations (functions or data).\n\n<div style=\"text-align: center;\">\n  <img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT3LVsLBXvyCaICWy29iarSq2Se66DjGqj6oQ&s\" alt=\"FastAPI logo\" style=\"width: 400px;\">\n</div>\n\n**Asynchronous programming** is like having a fleet of delivery drones zipping around, handling multiple tasks at once. **Databases** are the city's bustling warehouses, storing and retrieving valuable information.\n\n**Dependency Injection** is like having a reliable supply chain. It ensures that the right components (dependencies) are always available where needed. **Testing** is your quality control department, making sure everything runs smoothly. **Security** is the vigilant police force, protecting your API from hackers and unauthorized access.\n\n**Performance optimization** is about keeping the city running smoothly, even during peak hours. Techniques like caching and async enhancements are your traffic management tools, ensuring that everything flows efficiently.\n\n> Are you ready to build your own **API metropolis**? \n\n**Let's get started!**\n\n## 1. The Magic of Asynchronicity \n\nAlright, let's dive into the world of asynchronicity, where things happen... but they don‚Äôt always wait around for you. Get ready for some tech magic!\n\n### 1.1. Synchronous vs. Asynchronous Execution\n\nIn a synchronous world, you‚Äôre the chef cooking one dish at a time. You can't start the next meal until the first is finished and delivered‚Äîslow, right?\n\n<div style=\"text-align: center;\">\n  <img src=\"https://www.astera.com/wp-content/uploads/2023/01/Async-vs-Sync-API.png\" alt=\"FastAPI logo\" style=\"width: 400px;\">\n</div>\n\nNow, welcome to the **asynchronous kitchen**! \n\nHere, while one dish is cooking (waiting on I/O*, like boiling water), you can start prepping the next one. FastAPI does this for your app‚Äîit doesn‚Äôt wait idly for the oven to preheat before taking on new tasks.\n\n::: {.callout-note title=\"Note: I/O\" collapse=\"true\"}\nI/O in computing stands for \"Input/Output\". It refers to the communication between a computer system and the outside world, or between different components within a system. Here's a brief overview:\n\n**Definition** : I/O is the process of transferring data to or from a computer system.\n\n**Types**\n\n1. **Hard I/O**: Direct transfer of data between a computer and an external physical device (e.g., keyboard, mouse).\n\n2. **Soft I/O**: Data transfer between computers or servers over a network.\n\n**Characteristics**\n\n- **Bidirectional**: Some devices can function as both input and output devices.\n\n- **Perspective-based**: Whether a device is considered input or output can depend on the perspective.\n\n**Examples**\n\n- Input devices: Keyboards, mice, scanners\n\n- Output devices: Monitors, printers, speakers\n\n- I/O devices: Hard drives, network cards\n\n**Importance** : I/O operations are crucial for user interaction, data transfer, and system performance. Understanding I/O is essential for developers and system administrators for system design, performance optimization, and troubleshooting.\n:::\n\nHere‚Äôs the technical breakdown:\n\n- **Synchronous Execution** is like cooking one meal from start to finish before even thinking about the next one. It‚Äôs linear‚Äîone task finishes, and only then does the next begin.\n\n- **Asynchronous Execution** is like juggling multiple orders at once. While one task waits for something (say, file reading or a web request), the event loop jumps to the next task, keeping everything moving!\n\n**Event loop** is the master chef in charge, making sure no task burns by hopping from one to another. \n\nAnd **coroutines** are those tasks‚Äîit‚Äôs like each dish being prepped. They tell the event loop, \n\n> I‚Äôm gonna be busy for a while, feel free to go check on the others.\n\nThe benefit? FastAPI can handle a huge number of requests quickly, without getting bogged down in waiting, making your app zippy and responsive, even when under heavy load.\n\n### 1.2. Implementing Asynchronous Endpoints\n\nOkay, let‚Äôs jump into FastAPI's version of cooking up some asynchronous magic.\n\nTo make a route **asynchronous**, we use the keywords `async` and `await`‚Äîthey‚Äôre like the VIP passes to FastAPI‚Äôs asynchronous event.\n\n- **`async`**: This tells Python that a function might take a while to complete, and it‚Äôs cool to check out other functions while waiting.\n- **`await`**: It‚Äôs like a signal flare. It tells the event loop, ‚ÄúHey, I'm waiting for this task to finish, but you don‚Äôt need to hang around! Come back later.‚Äù\n\nHere‚Äôs a sample:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/async-dish\")\nasync def cook_something():\n    await prep_ingredients()  # Might take time\n    await bake_dish()  # Another wait here\n    return {\"status\": \"Dish ready!\"}\n```\nSee how we use `await` to tell the event loop to handle other things while it waits for the cooking functions to finish? \n\n>That‚Äôs the magic sauce! \n\nLet's whip up more examples to help you better understand how to use `async` and `await` in FastAPI! \n\nThese will showcase different ways you can handle async operations in routes.\n\n1. **Simulating Multiple Async Operations in Parallel**\n\nLet‚Äôs say you're preparing different parts of a meal simultaneously. While the oven is baking the dish, you‚Äôre also mixing the salad, and getting drinks ready.\n\n```python\nfrom fastapi import FastAPI\nimport asyncio  # For running tasks concurrently\n\napp = FastAPI()\n\nasync def bake_dish():\n    await asyncio.sleep(3)  # Simulate baking time\n    return \"Dish baked\"\n\nasync def prepare_salad():\n    await asyncio.sleep(1)  # Simulate chopping veggies\n    return \"Salad ready\"\n\nasync def get_drinks():\n    await asyncio.sleep(2)  # Simulate fetching drinks\n    return \"Drinks ready\"\n\n@app.get(\"/prepare-meal\")\nasync def prepare_meal():\n    # Run all tasks at the same time using asyncio.gather\n    dish, salad, drinks = await asyncio.gather(\n        bake_dish(),\n        prepare_salad(),\n        get_drinks()\n    )\n    return {\"status\": f\"{dish}, {salad}, {drinks}!\"}\n```\n\nüî• **Explanation**: In this example, instead of waiting for each task (baking, salad prep, drinks) to finish one by one, we're using `asyncio.gather()` to run all of them in parallel. The event loop jumps between these tasks while they‚Äôre waiting for something, maximizing efficiency. \n\n2. **Using Async with External API Calls**\n\nNow,  you‚Äôre pulling recipe data from a remote service. You don‚Äôt want your server to stop everything and wait while it fetches the data, so we make that operation asynchronous.\n\n```python\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/fetch-recipe\")\nasync def fetch_recipe():\n    async with httpx.AsyncClient() as client:\n        response = await client.get('https://recipe-api.com/special-dish')\n        data = response.json()\n    return {\"recipe\": data}\n```\n\nüî• **Explanation**: With `httpx.AsyncClient()`, we‚Äôre making the API call non-blocking. While the app waits for the recipe service to respond, the event loop is free to handle other requests. This is essential when working with third-party services to prevent your application from getting ‚Äústuck‚Äù waiting. \n\n3. **Asynchronous File Reading**\n\nYou can read files asynchronously so other requests don‚Äôt have to wait in line while your server is reading a large file.\n\n```python\nimport aiofiles  # Async library for file I/O\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/read-steps\")\nasync def read_steps():\n    async with aiofiles.open('recipe.txt', mode='r') as file:\n        content = await file.read()\n    return {\"recipe_steps\": content}\n```\n\nüî• **Explanation**: Here, we‚Äôre using `aiofiles` to open and read a file asynchronously. This allows FastAPI to handle other requests while reading the file in the background. \n\n4. **Delayed Responses: Simulating Long Operations**\n\nSuppose you have a task that simulates a long operation, like slow cooking. You don‚Äôt want your app to freeze while waiting for the slow cook to finish, so you implement it asynchronously.\n\n```python\nfrom fastapi import FastAPI\nimport asyncio  # For simulating a delay\n\napp = FastAPI()\n\n@app.get(\"/slow-cook\")\nasync def slow_cook():\n    await asyncio.sleep(5)  # Simulate a long task (e.g., slow cooking)\n    return {\"status\": \"Slow-cooked meal is ready!\"}\n```\n\nüî• **Explanation**: In this case, the `asyncio.sleep(5)` simulates a task that takes time (like slow cooking). While this is happening, FastAPI doesn‚Äôt sit idle‚Äîit can handle other requests while the slow-cooked meal finishes. üê¢üî•üç≤\n\n5. **Asynchronous Error Handling in Tasks**\n\nWhat if something goes wrong during one of your asynchronous tasks? For example, you‚Äôre preparing a cake but the oven breaks down midway. Let‚Äôs handle that gracefully using `async` and `try-except`.\n\n```python\nfrom fastapi import FastAPI\nimport asyncio\n\napp = FastAPI()\n\nasync def bake_cake():\n    await asyncio.sleep(2)\n    raise Exception(\"Oven malfunctioned!\")  # Something went wrong\n\n@app.get(\"/bake-cake\")\nasync def prepare_cake():\n    try:\n        await bake_cake()\n        return {\"status\": \"Cake baked successfully!\"}\n    except Exception as e:\n        return {\"error\": f\"Oops! {e}\"}\n```\n\nüî• **Explanation**: In this example, the oven \"malfunctions\" during the cake-baking process. The `try-except` block catches the error, allowing us to return a helpful message instead of crashing the app. This is like having a backup plan in case your cake flops.\n\n6. **Handling CPU-bound Tasks with Async + Background Tasks**\n\nWhile asynchronous tasks are great for I/O-bound operations (like waiting on APIs or files), CPU-bound operations (like heavy computations) can block the event loop. To avoid this, we can offload such tasks to background workers.\n\n```python\nfrom fastapi import FastAPI, BackgroundTasks\nimport time  # Simulate CPU-bound task\n\napp = FastAPI()\n\ndef heavy_computation():\n    time.sleep(10)  # Simulate a long-running computation\n    print(\"Computation done!\")\n\n@app.get(\"/start-computation\")\nasync def start_computation(background_tasks: BackgroundTasks):\n    background_tasks.add_task(heavy_computation)\n    return {\"status\": \"Computation started in the background!\"}\n```\n\nüî• **Explanation**: Here, `BackgroundTasks` allows us to offload the heavy computation (CPU-bound) to a background task so it doesn‚Äôt block the event loop. This way, FastAPI can continue processing other requests without waiting for the long-running computation to finish. \n\nBy using `async` and `await` correctly, you make your FastAPI apps *super efficient*, like a pro chef in a fast-paced kitchen, always juggling tasks without missing a beat! \n\n### 1.3. Best Practices for Asynchronous Programming\n\nWhen it comes to asynchronous programming, it‚Äôs not just about sprinkling `async` and `await` everywhere. There‚Äôs a bit of finesse to it‚Äîjust like any good recipe.\n\n1. **Know when to go async**:\n- Use async for **I/O-bound** tasks: things that need to wait for something external, like network requests or reading files.\n- Don‚Äôt go async for **CPU-bound** tasks (heavy number crunching), because while your function is churning away, you‚Äôre not gaining any advantage from async's multitasking magic.\n\n2. **Error handling in asynchronous functions**\n\nThink of error handling as catching a wayward dish before it hits the ground. In asynchronous code, make sure to wrap tasks in `try-except` blocks, so your event loop doesn‚Äôt trip over unhandled exceptions.\n\n<div style=\"text-align: center;\">\n  <img src=\"https://helper.beedev-services.com/images/python/try_and_except.png\" alt=\"FastAPI logo\" style=\"width: 400px;\">\n</div>\n\nHere‚Äôs how to handle errors asynchronously:\n```python\nasync def serve_dish():\n    try:\n        await bake_cake()\n    except OvenFailureException:\n        return {\"status\": \"Oven exploded! Call for help!\"}\n```\n\n1. **Simple try-except in an Asynchronous Function**\n\n```python\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/get-recipe\")\nasync def get_recipe():\n    try:\n        response = await httpx.get(\"https://random-recipes.com/cake\")\n        response.raise_for_status()  # Raise an error if the request failed\n        return {\"recipe\": response.json()}\n    except httpx.HTTPStatusError as e:\n        return {\"error\": f\"Recipe not available! Error: {e}\"}\n    except Exception as e:\n        return {\"error\": f\"Unexpected error occurred: {e}\"}\n```\n\nüî• **Explanation**: Here, we‚Äôre using `httpx` to make an asynchronous HTTP request. If the recipe website is down or returns an error, the `HTTPStatusError` exception will trigger, and we handle it smoothly without crashing the app.\n\n2. **Handling Multiple Exceptions**\n\nSometimes, different errors need different solutions. Let‚Äôs say your app reads data from a file and makes an HTTP request, both of which can fail in different ways.\n\n```python\nimport aiofiles  # Asynchronous file handling\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/read-data\")\nasync def read_data():\n    try:\n        # Try reading from a file asynchronously\n        async with aiofiles.open(\"data.txt\", mode=\"r\") as file:\n            contents = await file.read()\n        \n        # Then, make a web request for additional info\n        response = await httpx.get(\"https://api.example.com/data\")\n        response.raise_for_status()\n\n        return {\"file_data\": contents, \"api_data\": response.json()}\n\n    except FileNotFoundError:\n        return {\"error\": \"File not found. Please check the file path.\"}\n    except httpx.RequestError as e:\n        return {\"error\": f\"Failed to reach API: {e}\"}\n    except Exception as e:\n        return {\"error\": f\"An unexpected error occurred: {e}\"}\n```\n\nüî• **Explanation**: \n- **FileNotFoundError**: Happens if the file doesn‚Äôt exist. We handle this separately with a user-friendly message.\n- **httpx.RequestError**: Happens if the API request fails (e.g., bad connection). We give a clear message indicating the API issue.\n\n3. **Retry Mechanism with `try-except`**\n\nLet‚Äôs say you‚Äôre dealing with flaky internet, and you want to retry a failed task a couple of times before giving up. You can create a loop with retries inside your `try-except` block.\n\n```python\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/retry-request\")\nasync def retry_request():\n    retries = 3\n    for attempt in range(retries):\n        try:\n            response = await httpx.get(\"https://api.slow-server.com/data\")\n            response.raise_for_status()\n            return {\"data\": response.json()}\n        except httpx.RequestError as e:\n            if attempt < retries - 1:  # Only retry if we haven't exhausted attempts\n                continue\n            return {\"error\": f\"Failed after {retries} attempts. Error: {e}\"}\n```\n\nüî• **Explanation**: Here, the `try-except` block runs in a loop. If the request fails, the function will retry up to 3 times before giving up and returning an error.\n\n4. **Chaining `async` Calls with `try-except`**\n\nLet‚Äôs say you need to perform several asynchronous tasks, and you want to catch errors at different points.\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nasync def get_ingredients():\n    # Simulating an asynchronous function\n    return {\"flour\": 1, \"sugar\": 2, \"eggs\": 3}\n\nasync def prepare_dough(ingredients):\n    if \"eggs\" not in ingredients:\n        raise ValueError(\"Missing eggs!\")\n    # Pretend we're making dough\n    return \"dough prepared\"\n\n@app.get(\"/make-cake\")\nasync def make_cake():\n    try:\n        ingredients = await get_ingredients()\n        dough = await prepare_dough(ingredients)\n        return {\"status\": f\"{dough}, ready for baking!\"}\n    \n    except ValueError as e:\n        return {\"error\": f\"Invalid ingredients: {e}\"}\n    except Exception as e:\n        return {\"error\": f\"An unexpected error occurred: {e}\"}\n```\n\nüî• **Explanation**: \n- We first get ingredients asynchronously.\n- Then we prepare the dough asynchronously.\n- If there‚Äôs an issue (e.g., missing ingredients), we raise a **ValueError** and catch it, returning a helpful error message.\n\n5. **Nested `try-except` for More Granular Control**\n\nLet‚Äôs get more advanced. Sometimes, you need different try-except blocks for different stages of your async workflow.\n\n```python\nfrom fastapi import FastAPI\nimport aiofiles\n\napp = FastAPI()\n\n@app.get(\"/complex-process\")\nasync def complex_process():\n    try:\n        # Stage 1: File read\n        try:\n            async with aiofiles.open(\"input.txt\", mode=\"r\") as file:\n                contents = await file.read()\n        except FileNotFoundError:\n            return {\"error\": \"Input file missing!\"}\n        \n        # Stage 2: Process data\n        try:\n            # Fake processing step\n            if not contents:\n                raise ValueError(\"File is empty!\")\n            processed_data = contents.upper()\n        except ValueError as e:\n            return {\"error\": f\"Data processing failed: {e}\"}\n\n        # Stage 3: Return response\n        return {\"processed_data\": processed_data}\n\n    except Exception as e:\n        return {\"error\": f\"An unexpected error occurred: {e}\"}\n```\n\nüî• **Explanation**\n\nHere, we have different try-except blocks:\n\n1. **File reading** (handles file errors separately).\n\n2. **Data processing** (checks content validity).\n\n3. A final catch-all to handle anything unexpected.\n\nThis allows us to give very specific error messages, depending on where things go wrong.\n\nIn the world of FastAPI, asynchronicity is like having an army of chefs helping you cook multiple meals at once. You save time, resources, and keep things running smoothly. \n\nJust remember: \n\n> use async when it makes sense, manage your I/O carefully, and make sure you‚Äôve got error-handling oven mitts at the ready!\n\n## 2. Advanced Routing: The Map of Your FastAPI World\n\nRouting is the backbone of FastAPI‚Äîlike a GPS guiding every request to its destination. \n\nIn this part, we‚Äôll dive into routers, parameters, and middleware to organize and streamline your FastAPI applications.\n\nGet ready for a journey through the ‚Äúhighways‚Äù of FastAPI! üöóüí®\n\n### 2.1. Introduction to Routers\n\nLet‚Äôs start by breaking down routers. \n\nThink of them as different sections of a city: each router is responsible for handling related endpoints, like the \"shopping district\" or \"residential zone\" of your app.\n\nIn a simple project, you might only need a single `main.py` to handle all routes. But as your app grows, it becomes necessary to group routes logically‚Äîby features or services. FastAPI provides `APIRouter` to help you do just that.\n\nHere‚Äôs a basic example:\n\n```python\nfrom fastapi import FastAPI, APIRouter\n\napp = FastAPI()\n\n# Create a new router for user-related routes\nuser_router = APIRouter()\n\n@user_router.get(\"/users/\")\nasync def get_users():\n    return {\"users\": [\"M√©nyssa\", \"Eric\", \"Paul\"]}\n\n@user_router.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    return {\"user\": user_id}\n\n# Include the user_router in the main FastAPI app\napp.include_router(user_router)\n```\n\n**Current Project Structure**\n\nRight now, you have a very simple project structure:\n\n```bash\n‚îú‚îÄ‚îÄ env/\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ requirements.txt\n```\n\nLet‚Äôs refactor it to make use of routers. Create a folder to hold all your route files:\n\n```bash\n‚îú‚îÄ‚îÄ env/\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ routers/         # New folder to store routers\n‚îÇ   ‚îî‚îÄ‚îÄ users.py     # New file for user-related routes\n‚îú‚îÄ‚îÄ requirements.txt\n```\n\nInside `users.py`:\n\n```python\nfrom fastapi import APIRouter\n\nuser_router = APIRouter()\n\n@user_router.get(\"/users/\")\nasync def get_users():\n    return {\"users\": [\"Alice\", \"Bob\", \"Charlie\"]}\n\n@user_router.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    return {\"user\": user_id}\n```\n\nThen, include this router in `main.py`:\n\n```python\nfrom fastapi import FastAPI\nfrom routers.users import user_router\n\napp = FastAPI()\n\napp.include_router(user_router)\n```\n\nNow you‚Äôve separated concerns and logically grouped your endpoints. This makes your app easier to scale and maintain!\n\n**Organizing Endpoints into Logical Groups**\n\nYou can create more routers for different areas of your app, like `products.py` for managing a product catalog or `orders.py` for processing orders. This modular approach keeps things clean, especially as the number of endpoints grows.\n\n```bash\n‚îú‚îÄ‚îÄ env/\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ routers/\n‚îÇ   ‚îú‚îÄ‚îÄ users.py\n‚îÇ   ‚îú‚îÄ‚îÄ products.py\n‚îÇ   ‚îî‚îÄ‚îÄ orders.py\n‚îú‚îÄ‚îÄ requirements.txt\n```\n\nEach router becomes a dedicated zone of your app, handling its own logic. This modularity is a huge win for maintainability and scalability.\n\n### 2.2. Path Parameters and Query Parameters\n\nParameters allow users to send extra information with requests, making them more flexible and dynamic. [See also Lecture 1](/00_Lectures/01_Lecture.qmd)\n\n**Path Parameters**\n\nPath parameters are part of the URL. They let you capture dynamic parts of a route. For example, if you have `/users/{user_id}`, `{user_id}` is a path parameter.\n\n```python\n@user_router.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    return {\"user\": user_id}\n```\n\nüî• **Explanation**: Here, `user_id` is extracted from the URL and passed as an argument to the handler function.\n\n**Query Parameters**\n\nQuery parameters are key-value pairs that follow a `?` in the URL. They‚Äôre usually used to filter or sort data.\n\nFor example, if you have `/users?name=Paul`, `name` is a query parameter:\n\n```python\n@user_router.get(\"/users/\")\nasync def get_users(name: str = None):\n    if name:\n        return {\"filtered_user\": name}\n    return {\"users\": [\"M√©nyssa\", \"Eric\", \"Paul\"]}\n```\n\nüî• **Explanation**: Here, `name` is a query parameter that filters the list of users. If no `name` is provided, it returns the full list.\n\n**Validating Parameters with Dependency Injection**\n\nFastAPI's dependency injection system allows you to validate parameters before they reach the route handler. For example, you can use `Pydantic` models to validate query parameters:\n\n```python\nfrom pydantic import BaseModel\n\nclass UserQueryParams(BaseModel):\n    name: str\n    age: int\n\n@user_router.get(\"/search/\")\nasync def search_users(params: UserQueryParams):\n    return {\"name\": params.name, \"age\": params.age}\n```\n\nWith dependency injection, FastAPI will automatically validate the query parameters based on the `UserQueryParams` schema.\n\n### 2.3. Custom Routers and Middleware\n\nLet‚Äôs now explore how to extend routers and add middleware to handle more advanced use cases.\n\n**Creating Custom Routers for Specific Use Cases**\n\nYou can create custom routers for specific sections of your app, each with its own set of routes and logic. \n\nFor instance, let‚Äôs create an admin router with custom logic:\n\n```python\nfrom fastapi import APIRouter\n\nadmin_router = APIRouter()\n\n@admin_router.get(\"/admin/reports\")\nasync def get_admin_reports():\n    return {\"report\": \"Admin report data\"}\n```\n\nüî• **Explanation**: This custom router can be used to separate admin functionality from general user functionality. It helps ensure the right people access the right routes.\n\n**Implementing Middleware for Cross-Cutting Concerns**\n\nMiddleware is code that runs **before** or **after** each request. It‚Äôs great for logging, authentication, and other cross-cutting concerns.\n\nHere‚Äôs an example of middleware that logs the time taken for each request:\n\n```python\nfrom fastapi import FastAPI\nimport time\n\napp = FastAPI()\n\n@app.middleware(\"http\")\nasync def log_requests(request, call_next):\n    start_time = time.time()\n    response = await call_next(request)\n    duration = time.time() - start_time\n    print(f\"Request: {request.url}, Duration: {duration}s\")\n    return response\n```\n\nüî• **Explanation**: With this middleware, every request gets timed and logged. Middleware is powerful because it can intercept every request and response, applying logic that affects the entire app.\n\n**Bonus: Custom Error Handling with Middleware**\nYou can even use middleware for custom error handling. For example, you might want to catch all exceptions and return a custom error message:\n\n```python\n@app.middleware(\"http\")\nasync def custom_error_handling(request, call_next):\n    try:\n        return await call_next(request)\n    except Exception as e:\n        return JSONResponse(status_code=500, content={\"error\": str(e)})\n```\n\nüî• **Explanation**: This middleware catches any unhandled exceptions and returns a consistent error response to the client.\n\nBy organizing your FastAPI app into logical pieces and implementing advanced routing techniques, you'll keep your code clean and scalable‚Äîlike a well-mapped city! \n\n## 3. Database Dynamo: Powering Your App \n\nThis is the heart of most web applications : The database. \n\nIt's the powerful engine that drives the storage and retrieval of your data, and in this section, we'll explore how to set up, manage, and interact with databases in FastAPI.\n\n### 3.1. Choosing the Right Database\n\nChoosing the right database is like choosing the right vehicle for a road trip: \n\n> Do you want a rugged SUV (NoSQL) or a precision-engineered sports car (SQL)? \n\nIt all depends on the type of data, how it‚Äôs structured, and what you need in terms of performance.\n\n**SQL vs. NoSQL Databases**\n\n- **SQL**: Think of SQL databases like Excel sheets‚Äîthey‚Äôre great for structured data with clear relationships. You can run complex queries across multiple tables, and they're backed by solid ACID compliance (Atomicity, Consistency, Isolation, Durability). Common options include **PostgreSQL**, **MySQL**, and **SQLite**.\n\n‚û°Ô∏è **Use case**: Banking systems, e-commerce platforms where data integrity and relationships matter.\n\n- **NoSQL**: NoSQL databases, on the other hand, are more like dynamic, flexible containers. They can handle semi-structured or unstructured data like JSON documents. They scale horizontally, which means they work great with massive datasets.\n\n‚û°Ô∏è **Use case**: Social networks, real-time applications, or scenarios where data structure is constantly changing (e.g., **MongoDB**, **Cassandra**).\n\n**Popular Databases for FastAPI**\n\nWhen it comes to FastAPI, the database world is your oyster. Here are some great options:\n\n- **PostgreSQL**: The SQL superstar! It‚Äôs powerful, open-source, and works smoothly with FastAPI. Great for complex queries, relational data, and transactional applications.\n\n- **MongoDB**: NoSQL king! Ideal for flexible, large-scale applications where the structure isn‚Äôt rigid. Use it if you‚Äôre dealing with JSON-like data or want to easily scale horizontally.\n\n- **SQLite**: Lightweight and portable SQL option. Best for smaller applications or quick prototypes. It‚Äôs built into Python, so no additional setup required.\n\n**Analogy Time**: \n\n- **SQL databases** are like libraries, neatly organized with sections, rows, and books that reference other books (relational).\n\n- **NoSQL databases** are like a garage sale where things might not be perfectly organized, but you can grab what you need quickly (flexibility).\n\n### 3.2. SQLAlchemy and SQLModel\n\nFastAPI makes working with databases easy, thanks to **[SQLAlchemy](https://fastapi.tiangolo.com/tutorial/sql-databases/)** and **[SQLModel](https://sqlmodel.tiangolo.com/)**. \n\nLet‚Äôs break them down and see how they power up your database interactions.\n\n#### 3.2.1. Using SQLAlchemy for Database Interactions\n\nSQLAlchemy is one of the most powerful and flexible libraries for working with relational databases in Python. It gives you fine-grained control over every aspect of database interaction. \n\n<div style=\"text-align: center;\">\n  <img src=\"https://miro.medium.com/v2/resize:fit:720/format:webp/0*2gcZYBv6jmcbRtnY\" alt=\"FastAPI logo\" style=\"width: 400px;\">\n</div>\n\nIt‚Äôs an **ORM*** (Object Relational Mapper) that lets you work with databases in a Pythonic way‚Äîno more raw SQL queries unless you want to.\n\n::: {.callout-note title=\"Note: ORM\" collapse=\"true\"}\n**ORM stands for Object-Relational Mapper.** It's a programming technique that bridges the gap between object-oriented programming (OOP) and relational databases.\n\n**In simpler terms, an ORM allows you to interact with database tables as if they were objects in your programming language.** This means you can use familiar OOP concepts like classes, objects, and methods to create, read, update, and delete data in your database.\n\n**Here's how it works:**\n\n1. **Mapping:** The ORM defines a mapping between your object classes and database tables. This mapping specifies how properties of your objects correspond to columns in the database table.\n2. **Data Access:** You can use your object's methods to perform database operations. For example, to save an object, you might call a `save()` method. The ORM will automatically translate this into the appropriate SQL query to insert data into the database.\n3. **Data Retrieval:** To retrieve data from the database, you can query for objects based on certain criteria. The ORM will translate your query into SQL and return the results as objects.\n\n**Benefits of using ORMs:**\n\n* **Simplified development:** ORMs can significantly reduce the amount of boilerplate code needed to interact with databases.\n\n* **Improved productivity:** By using familiar OOP concepts, developers can work more efficiently and make fewer errors.\n\n* **Portability:** ORMs can often be used with different databases, making it easier to switch between systems.\n\n* **Abstraction:** ORMs provide a layer of abstraction between your application and the database, making your code more maintainable and easier to test.\n\n**Popular ORMs include:**\n\n* SQLAlchemy for Python\n* Hibernate for Java\n* Entity Framework for .NET\n* ActiveRecord for Ruby\n\n**By using an ORM, you can focus on building your application's logic without having to worry about the intricacies of SQL and database interactions.**\n\n:::\n\nLet's break this down step by step to make it super clear. We‚Äôll start with the basics of creating a table and then move into interacting with that table using SQLAlchemy.\n\n**1. Define a SQLAlchemy Model (Table Representation)**\n\nIn a database, a **table** stores data in rows and columns. In SQLAlchemy, we create a **model** that acts like a blueprint for a database table.\n\nWhat‚Äôs happening in the code:\n\n```python\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n```\n- **`create_engine`**: Think of this as your connection to the database. In this example, we‚Äôre using **SQLite**, which is a lightweight, file-based SQL database (though this could be PostgreSQL, MySQL, etc.). The engine is the bridge between SQLAlchemy and the actual database.\n- **`declarative_base`**: This is the starting point for any model in SQLAlchemy. We use it to define tables. The `Base` class lets SQLAlchemy know which classes (tables) should be mapped to the database.\n- **`sessionmaker`**: This is a factory for creating sessions, which are used to talk to the database (we‚Äôll get to sessions later).\n\n```python\n# Connect to a SQLite database (or PostgreSQL)\nengine = create_engine(\"sqlite:///mydb.db\")\nBase = declarative_base()\n```\n- **`engine = create_engine(\"sqlite:///mydb.db\")`**: This line creates the connection to the SQLite database, which is stored in a file called `mydb.db`. If you were using PostgreSQL, the string would look something like this:\n  ```python\n  engine = create_engine(\"postgresql://username:password@localhost/dbname\")\n  ```\n\n- **`Base = declarative_base()`**: This creates the base class `Base`, which we‚Äôll use to define all our tables (models) in the future.\n\n**2. Defining the `User` Table**\n\nNow, let‚Äôs create the **User** table:\n\n```python\n# Define a model representing a table\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True)\n```\nüî• **Explanation**: \n\n- **`class User(Base)`** defines a class `User` that inherits from `Base`. Each class in SQLAlchemy is mapped to a table in the database, so this class is our blueprint for the `users` table.\n- **`__tablename__ = \"users\"`** sets the table name to `\"users\"`. Whenever we query or modify data, this table name is used in the background.\n\nInside this class, we define **columns**, which are the fields in our table:\n- **`id = Column(Integer, primary_key=True, index=True)`** creates an `id` column in the table, which is an **integer**, the **primary key** (unique for each row), and indexed for fast lookups.\n- **`name = Column(String, index=True)`** creates a `name` column that stores **strings** (text) and is also indexed.\n\n**3. Create the Table in the Database**\n\nNow that we‚Äôve defined our `User` model, we need to actually create the table in the database:\n\n```python\n# Create the table in the database\nBase.metadata.create_all(bind=engine)\n```\nüî• **Explanation**: **`Base.metadata.create_all(bind=engine)`** tells SQLAlchemy to take all the models we‚Äôve defined (in this case, the `User` model) and create the corresponding tables in the database connected to `engine`. This will create the `users` table in `mydb.db`.\n\n**4.Interacting with the Database (CRUD Operations)**\n\nOnce our table is created, we can start performing **CRUD operations** (Create, Read, Update, Delete) to interact with our data.\n\nTo communicate with the database, we need a **session**. A session is like a temporary workspace where we can make changes to the database, and once we‚Äôre done, we can **commit** (save) those changes.\n\n```python\n# Create a session to interact with the database\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n```\nüî• **Explanation**: Here, we define **SessionLocal**, a session factory that will let us create sessions when we need them.\n\n**5. Adding Data to the Database**\n\nLet‚Äôs use this session to add a new user to the `users` table:\n\n```python\n# Create a session and add a new user\ndb = SessionLocal()\nnew_user = User(name=\"M√©nyssa\")\ndb.add(new_user)\ndb.commit()\ndb.close()\n```\nüî• **Explanation**: \n\n- **`db = SessionLocal()`**create a new session using `SessionLocal()`. This session allows us to interact with the database.\n- **`new_user = User(name=\"M√©nyssa\")`** create a new instance of the `User` model. In this case, we‚Äôre adding a user with the name **M√©nyssa**. The `id` column will be automatically generated because it‚Äôs a primary key.\n- **`db.add(new_user)`** add this new user to our session (this step only adds it to the session, not the database yet).\n- **`db.commit()`** saves (commits) the changes to the database. The new user is now stored in the `users` table.\n- **`db.close()`** close the session to free up resources.\n\n**Summary of CRUD Operations**\n\n1. **Define a SQLAlchemy Model** (This represents a table in your database):\n\n```python\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\n# Connect to a SQLite database (or PostgreSQL)\nengine = create_engine(\"sqlite:///mydb.db\")\nBase = declarative_base()\n\n# Define a model representing a table\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True)\n\n# Create the table in the database\nBase.metadata.create_all(bind=engine)\n\n# Create a session to interact with the database\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n```\n\n2. **Interacting with the Database**: Now that we‚Äôve created a table, let‚Äôs add some users:\n\n```python\n# Create a session and add a new user\ndb = SessionLocal()\nnew_user = User(name=\"Pierre\")\ndb.add(new_user)\ndb.commit()\ndb.close()\n```\n\nSQLAlchemy simplifies database interactions by letting you work with Python objects rather than raw SQL queries, making it easier to manage your app's data.\n\n#### 3.2.2. SQLModel: The Best of Both Worlds (SQLAlchemy + Pydantic)\n\nWhile SQLAlchemy is powerful, **SQLModel** takes things a step further by combining the simplicity of **Pydantic** (for data validation) and the power of SQLAlchemy.\n\nSQLModel is built on top of SQLAlchemy but introduces **Pydantic-style validation**. It takes the best parts of both worlds:\n- The powerful ORM capabilities of SQLAlchemy\n- The data validation magic of Pydantic\n\n> So, what does this mean? \nYou get to use SQLAlchemy‚Äôs robust features while reducing the boilerplate code, **and** you get automatic data validation.\n\n**1. Key Differences with SQLAlchemy:**\n\n- **Data Validation Built-In**: SQLModel integrates Pydantic‚Äôs data validation. This means that every time you define a model, it automatically validates the data for you.\n- **Less Boilerplate**: SQLModel cuts down on repetitive code. You don‚Äôt need to define columns manually like in SQLAlchemy; you can use Python‚Äôs type hints, making your code cleaner and easier to maintain.\n- **Declarative Syntax**: You define your models in a more **Pythonic** way, without needing to write repetitive column definitions.\n- **Pydantic + SQLAlchemy Integration**: SQLModel works seamlessly with FastAPI, because FastAPI is already built on Pydantic for data validation.\n\n**2. SQLModel Example Breakdown**\n\n```python\nfrom sqlmodel import SQLModel, Field, create_engine\n\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n```\nüî• **Explanation**: \n\n- **`SQLModel`** is the base class for all your models. It inherits from both **Pydantic** and **SQLAlchemy**, so it does the heavy lifting for you.\n\n- **`table=True`** tells SQLModel to treat this class as a **database table**. Without it, the class would just be a data model for validation purposes.\n\n- **Fields**:\n  - **`id: int = Field(default=None, primary_key=True)`**: Instead of defining the column type manually (like in SQLAlchemy), we use type hints (`int` for `id` and `str` for `name`) and the `Field` function from Pydantic for additional options like `primary_key=True`.\n  - **`name: str`**: This defines a simple `name` column with a `string` type.\n\nAlready, this feels cleaner and more Pythonic.\n\nHere‚Äôs a full script using **SQLModel** to create a SQLite database, define a `User` model, and perform basic CRUD operations.\n\nThis will give you a complete picture of how SQLModel works in practice:\n\n```python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom sqlmodel import SQLModel, Field, create_engine, Session, select\nimport uvicorn  # Import uvicorn to run the application\n\napp = FastAPI()\n\n# 1. Define the User model using SQLModel\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n\n# 2. Create the SQLite database engine\nDATABASE_URL = \"sqlite:///./mydb.db\"\nengine = create_engine(DATABASE_URL, echo=True)\n\n# 3. Create the database tables\nSQLModel.metadata.create_all(engine)\n\n# 4. Create a session to interact with the database\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n# Add a root route to prevent the 404 error\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Welcome to the User Management API!\"}\n\n# 5. Add a new user to the database\n@app.post(\"/users/\", response_model=User)\ndef create_user(name: str, session: Session = Depends(get_session)):\n    new_user = User(name=name)\n    session.add(new_user)\n    session.commit()\n    session.refresh(new_user)\n    return new_user\n\n# 6. Fetch all users from the database\n@app.get(\"/users/\", response_model=list[User])\ndef get_users(session: Session = Depends(get_session)):\n    statement = select(User)\n    results = session.exec(statement)\n    users = results.all()\n    return users\n\n# 7. Update a user in the database\n@app.put(\"/users/{user_id}\", response_model=User)\ndef update_user(user_id: int, new_name: str, session: Session = Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    user.name = new_name\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n    return user\n\n# 8. Delete a user from the database\n@app.delete(\"/users/{user_id}\")\ndef delete_user(user_id: int, session: Session = Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    session.delete(user)\n    session.commit()\n    return {\"detail\": \"User deleted\"}\n```\n\nüî• **Big, big Explanation**\n\nLet's break down the key parts of your FastAPI script to provide a clear understanding of its structure and functionality:\n\n1. **Imports**\n```python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom sqlmodel import SQLModel, Field, create_engine, Session, select\nimport uvicorn  # Import uvicorn to run the application\n```\n- **FastAPI**: The main framework used to create the API.\n- **Depends**: A helper to declare dependencies for your path operations (like database sessions).\n- **HTTPException**: Used to raise HTTP errors with a specified status code and message.\n- **SQLModel**: A library that combines Pydantic and SQLAlchemy for data modeling and database operations.\n- **Field**: A function to define the fields of a SQLModel class.\n- **create_engine**: Used to create a database engine.\n- **Session**: Represents a workspace for interacting with the database.\n- **select**: A function used to create SQL SELECT statements.\n- **uvicorn**: An ASGI server used to run your FastAPI application.\n\n2. **Creating the FastAPI App**\n```python\napp = FastAPI()\n```\n- **FastAPI Instance**: This line initializes the FastAPI application. This instance will handle all the incoming requests.\n\n3. **Defining the User Model**\n```python\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n```\n- **User Class**: This class defines the `User` model as a database table.\n- **`table=True`**: Indicates that this class should be treated as a database table.\n- **Fields**:\n  - **`id`**: An integer that serves as the primary key (automatically incremented).\n  - **`name`**: A string representing the user's name.\n\n4. **Creating the Database Engine**\n```python\nDATABASE_URL = \"sqlite:///./mydb.db\"\nengine = create_engine(DATABASE_URL, echo=True)\n```\n- **DATABASE_URL**: Specifies the connection string for the SQLite database (using a file named `mydb.db`).\n- **`create_engine`**: Creates the database engine that allows the application to interact with the database. The `echo=True` flag enables logging of all the generated SQL statements.\n\n5. **Creating Database Tables**\n```python\nSQLModel.metadata.create_all(engine)\n```\n- This line creates all tables defined in the SQLModel classes in the database. If the table already exists, it will not be recreated.\n\n6. **Creating a Database Session**\n```python\ndef get_session():\n    with Session(engine) as session:\n        yield session\n```\n- **`get_session` function**: A generator function that creates a database session for each request. It ensures that the session is properly managed (opened and closed).\n\n7. **Root Route**\n```python\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Welcome to the User Management API!\"}\n```\n- **Root Endpoint**: A simple GET endpoint that returns a welcome message. This prevents the 404 error when accessing the root URL.\n\n8. **Adding a New User**\n```python\n@app.post(\"/users/\", response_model=User)\ndef create_user(name: str, session: Session = Depends(get_session)):\n    new_user = User(name=name)\n    session.add(new_user)\n    session.commit()\n    session.refresh(new_user)\n    return new_user\n```\n- **POST Endpoint**: Adds a new user to the database.\n- **`name: str`**: The name of the user is received as a path parameter.\n- **`session: Session = Depends(get_session)`**: Injects a session dependency into the function.\n- **Creating and Committing**: The new user is created, added to the session, committed to the database, and returned as a response.\n\n9. **Fetching All Users**\n```python\n@app.get(\"/users/\", response_model=list[User])\ndef get_users(session: Session = Depends(get_session)):\n    statement = select(User)\n    results = session.exec(statement)\n    users = results.all()\n    return users\n```\n- **GET Endpoint**: Fetches all users from the database.\n- **SQL Select Statement**: Uses the `select` function to create a query and executes it.\n- **Returns**: A list of all user records.\n\n10. **Updating a User**\n```python\n@app.put(\"/users/{user_id}\", response_model=User)\ndef update_user(user_id: int, new_name: str, session: Session = Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    user.name = new_name\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n    return user\n```\n- **PUT Endpoint**: Updates the name of an existing user identified by `user_id`.\n- **Error Handling**: If the user is not found, raises a 404 HTTP exception.\n- **Session Management**: Updates the user object, commits changes, and returns the updated user.\n\n11. **Deleting a User**\n```python\n@app.delete(\"/users/{user_id}\")\ndef delete_user(user_id: int, session: Session = Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    session.delete(user)\n    session.commit()\n    return {\"detail\": \"User deleted\"}\n```\n- **DELETE Endpoint**: Deletes the user identified by `user_id`.\n- **Error Handling**: If the user is not found, raises a 404 HTTP exception.\n- **Session Management**: Deletes the user and commits the changes.\n\nThe use of FastAPI's dependency injection for database sessions and structured error handling ensures a robust application. Each endpoint is clearly defined and returns data in a structured format, making it easy to use and extend.\n\n**5. Why Use SQLModel in FastAPI Projects?**\n\nSQLModel was designed with **FastAPI** in mind. Here‚Äôs why it‚Äôs a great fit for FastAPI projects:\n\n- **Seamless Integration with FastAPI**: Both FastAPI and SQLModel use **Pydantic** under the hood, so the models you define in SQLModel work perfectly with FastAPI‚Äôs request/response validation system.\n- **Automatic Data Validation**: SQLModel automatically validates incoming and outgoing data, which fits beautifully with FastAPI‚Äôs validation-first philosophy.\n- **Reduced Boilerplate**: You write less code compared to raw SQLAlchemy. For example, you don‚Äôt need to specify columns explicitly, and everything integrates smoothly with FastAPI.\n\n#### 3.2.3 Summary: SQLAlchemy vs. SQLModel\n\n| Feature                    | SQLAlchemy                              | SQLModel                                      |\n|----------------------------|-----------------------------------------|-----------------------------------------------|\n| **Data Validation**         | Separate (manually or with Pydantic)    | Built-in with Pydantic                       |\n| **Syntax**                  | More verbose (manually define columns)  | Simpler, using Python type hints             |\n| **FastAPI Integration**     | Works, but not designed for it          | Seamlessly integrated                        |\n| **Boilerplate Code**        | More boilerplate (defining columns)     | Less boilerplate (uses type hints + Pydantic)|\n| **Primary Use Case**        | Large, complex applications             | FastAPI apps, quick development              |\n\nIn essence, **SQLAlchemy** gives you more control for complex applications, but if you‚Äôre working with **FastAPI**, **SQLModel** makes everything cleaner, simpler, and faster‚Äî**without sacrificing power**. It's like having a Swiss Army knife that's perfectly sharpened for FastAPI's needs.\n\n### 3.3 Database Migrations (Optional)\n\nDatabase migrations are crucial for managing changes to your database schema as your application evolves. \n\n#### 3.1. Managing Database Schema Changes\n\n**[Alembic](https://jod35.github.io/fastapi-beyond-crud-docs/site/chapter7/?h=alembic#database-migrations-with-alembic)** is a lightweight database migration tool for use with SQLAlchemy. It helps you version control your database schema changes and makes it easier to apply these changes across different environments.\n\n**Key Features of Alembic:**\n\n1. **Version Control**: Each migration script is like a **bookmark** in your tree‚Äôs growth. It tells you exactly how the branches have changed over time. You can easily look back to see when a new feature was added or an old one was removed.\n\n2. **Autogeneration**: With Alembic, you don‚Äôt have to manually write every migration script. It‚Äôs like having a **smart assistant** who automatically detects changes in your models and drafts the migration scripts for you. Imagine saying, ‚ÄúHey Alembic, I added a new leaf!‚Äù and it responds with a complete plan to incorporate that leaf into your tree.\n\n3. **Consistent Environments**: Alembic ensures that whether you‚Äôre working in your cozy development environment or the bustling production stage, everyone is looking at the same beautiful tree. It keeps all developers and environments in sync, avoiding those dreaded ‚ÄúIt works on my machine!‚Äù moments.\n\n**The Power of Alembic in Your Hands**\n\nWhile Alembic might feel optional for small projects, it‚Äôs like having a **safety net** when you decide to jump into more complex applications. \n\nImagine you‚Äôve planted a tiny sapling today, but a year later, it‚Äôs a full-fledged tree with multiple branches‚Äîsome may need to be reshaped or removed. \n\nBy implementing Alembic from the start, you save yourself from headaches down the line as your application grows.\n\nSo, whether you're just starting out or scaling to new heights, think of Alembic as your trusty tool to manage database changes, keeping everything neat, organized, and growing beautifully! \n\n#### 3.2. Step-by-Step Guide\n\n**1. Installing Alembic**\n\nFirst, install Alembic via pip:\n\n```bash\npip install alembic\n```\n\n**2. Setting Up Alembic**\n\nInitialize Alembic in your FastAPI project. Run this command in your terminal:\n\n```bash\nalembic init alembic\n```\n\nThis creates a new directory called `alembic`, which contains configuration files and a folder for your migration scripts.\n\n**3. Configuring Alembic**\n\nIn the `alembic.ini` file, set the database URL to match your FastAPI project:\n\n```ini\n[alembic]\n# A generic, single database configuration.\nsqlalchemy.url = sqlite:///./mydb.db\n```\nYou should also modify the `env.py` file in the `alembic` folder to work with SQLModel. Replace the line:\n\n```python\nfrom myapp import mymodel\n```\n\nwith:\n\n```python\nfrom myapp.models import User  # Import your SQLModel classes here\n```\n\nMake sure to import the base metadata:\n\n```python\nfrom sqlmodel import SQLModel\n\ntarget_metadata = SQLModel.metadata\n```\n\n**4. Creating a Migration**\n\nWhen you modify your models (for example, adding a new column), create a migration script:\n\n```bash\nalembic revision --autogenerate -m \"Add email column to users\"\n```\n\nThis command creates a new migration file in the `alembic/versions` directory with the changes detected by Alembic.\n\n**Example: Adding an Email Column to User Model**\n\nLet‚Äôs say you want to add an `email` column to your `User` model. Update your `User` model like this:\n\n```python\nfrom sqlmodel import SQLModel, Field\n\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n    email: str = Field(default=None)  # New email field\n```\n\nAfter saving this change, run the Alembic command to generate a migration:\n\n```bash\nalembic revision --autogenerate -m \"Add email column to users\"\n```\n\nAlembic generates a migration script similar to the following:\n\n```python\n\"\"\"Add email column to users\n\nRevision ID: 123456789abc\nRevises: previous_revision_id\nCreate Date: 2024-10-11 12:00:00.000000\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\nfrom sqlmodel import SQLModel\n\n# revision identifiers, used by Alembic.\nrevision = '123456789abc'\ndown_revision = 'previous_revision_id'\nbranch_labels = None\ndepends_on = None\n\ndef upgrade():\n    # Adding the email column\n    op.add_column('user', sa.Column('email', sa.String(), nullable=True))\n\ndef downgrade():\n    # Dropping the email column\n    op.drop_column('user', 'email')\n```\n\n**5. Applying the Migration**\n\nOnce you‚Äôve created the migration script, apply it to your database:\n\n```bash\nalembic upgrade head\n```\n\nThis command runs the `upgrade` function in your migration script, applying the changes to your database.\n\nBy following these steps, you can effectively manage your database schema changes as your application grows and evolves. Now that we have a robust migration strategy in place, it‚Äôs time to delve into more advanced topics that enhance our application‚Äôs architecture and functionality.\n\n\n## 4. Advanced Topics Toolbox (Very advanced, so very optional)\n\nYou‚Äôve made it this far‚Äîwell done! üéâ\n\nNow we‚Äôre diving into the supercharged section, where we tackle some **seriously advanced topics** in FastAPI. \n\nThese are the power tools that can turn you from a solid developer into a FastAPI **wizard**. \n\nThey‚Äôre optional, but if you‚Äôre up for the challenge, you‚Äôll come out with a toolbox of knowledge that will let you **build, secure, and optimize** APIs like a pro.\n\nLet‚Äôs open the toolbox:\n\n### 4.1. Dependency Injection\n> \"Why do we need it?\"  \nThink of **dependency injection** like getting a superpower to \"inject\" exactly what your code needs, when it needs it, without unnecessary clutter! It‚Äôs all about clean, maintainable code that scales with your project. \n\n- **Understanding Dependency Injection in FastAPI**  \nYou‚Äôll see how FastAPI makes managing dependencies a breeze. Instead of cluttering up your logic with repetitive calls, you inject them cleanly.\n\n- **Using `fastapi.Depends` for Dependency Injection**  \nYou‚Äôll learn how to simplify your code by using the `Depends` method‚Äîlike ordering takeout for your app‚Äôs resources instead of cooking every time.\n\n- **Creating Custom Dependencies**  \nWhy stop at the basics? Learn to create your own custom dependencies, from database connections to third-party API calls.\n\n#### 4.1.1 What is Dependency Injection (DI)?\n\nIn FastAPI, DI helps you inject dependencies into your routes and functions without having to create them manually each time.\n\nThe magic happens using **`Depends`**.\n\n#### 4.1.2 FastAPI's `Depends` in Action\n\nFastAPI uses **`Depends`** to handle dependency injection in a clean and Pythonic way. Let's look at how it works:\n\n```python\nfrom fastapi import FastAPI, Depends\n\napp = FastAPI()\n\n# Define a dependency\ndef get_db_connection():\n    return {\"db\": \"connected\"}\n\n# Use the dependency in an endpoint\n@app.get(\"/items/\")\ndef read_items(db_conn = Depends(get_db_connection)):\n    return {\"message\": f\"Database status: {db_conn['db']}\"}\n```\n\nüî• **Explanation**:\n\n- **`get_db_connection()`**: This function simulates connecting to a database.\n- **`Depends(get_db_connection)`**: The `Depends()` function calls our dependency and \"injects\" its return value into the route.\n- Now, the `db_conn` variable has access to the database connection without having to create it inside the route.\n\n#### 4.1.3 Custom Dependencies\n\nFastAPI isn‚Äôt just limited to database connections! You can create your own custom dependencies to manage **authentication**, **logging**, **configuration**, and more.\n\nLet's build a simple *authorization* dependency:\n\n```python\nfrom fastapi import HTTPException, Header\n\ndef verify_token(x_token: str = Header(...)):\n    if x_token != \"supersecrettoken\":\n        raise HTTPException(status_code=403, detail=\"Invalid token\")\n    return True\n\n@app.get(\"/secure-data/\")\ndef secure_data(token = Depends(verify_token)):\n    return {\"message\": \"You have access to secure data!\"}\n```\n\nüî• **Explanation**:\n\n- **`verify_token()`**: This function checks if the token provided in the `x_token` header is correct.\n\n- **`Depends(verify_token)`**: If the token is valid, the user can access the secure route. If not, it raises an error.\n\n### 4.2. Testing FastAPI Applications\n> \"Your code works... but does it really?\"  \nTesting is like **proofreading** for developers. Sure, your app runs on your machine, but what about production? What about edge cases? ü§î\n\n- **Unit Testing, Integration Testing, and API Testing**  \nGet familiar with different types of tests and when to use them. Unit tests are like checking individual LEGO bricks, while integration tests check the full LEGO model.\n\n- **Using Tools like pytest for Testing**  \nLearn the magic of `pytest`‚Äîyour testing buddy! From simple tests to mocking dependencies, we‚Äôll cover it all.\n\n#### 4.2.1 Why is Testing Important?\n\nImagine launching a rocket without checking if all the parts work‚Äîscary, right?\nIn development, it‚Äôs the same! Testing ensures that your code behaves as expected, so you don‚Äôt end up with unexpected bugs in production.\n\n**Types of Testing** :\n\n1. **Unit Testing**: Test individual components of your code (e.g., a function or a class) to make sure they behave correctly in isolation.\n2. **Integration Testing**: Test how different parts of your application work together (e.g., database, API, external services).\n3. **API Testing**: Specifically focus on testing the endpoints of your FastAPI app to ensure they return the right responses and handle errors gracefully.\n\n#### 4.2.2 Setting Up Pytest\n\nFastAPI plays well with **pytest**, one of the most popular testing frameworks in Python. It‚Äôs simple, powerful, and easy to integrate.\n\n1. **Install pytest**:\n```bash\npip install pytest\n```\n\n2. **Install TestClient from FastAPI**:\nFastAPI has a built-in **TestClient** (powered by Starlette) that you can use to send HTTP requests during testing.\n\n```bash\npip install httpx\n```\n\n#### 4.2.3 Writing Your First Unit Test\n\nLet‚Äôs start small by writing a unit test for a simple FastAPI route.\n\n**Here‚Äôs your API:**\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/hello/\")\ndef read_hello():\n    return {\"message\": \"Hello, World!\"}\n```\n\n**Writing the Test:**\n\n```python\nfrom fastapi.testclient import TestClient\nfrom myapp import app  # Assuming your app is defined in 'myapp.py'\n\nclient = TestClient(app)\n\ndef test_read_hello():\n    response = client.get(\"/hello/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello, World!\"}\n```\n\nüî• **Explanation**:\n\n- **TestClient**: This allows us to simulate HTTP requests to the FastAPI app during tests.\n- **`client.get(\"/hello/\")`**: We send a GET request to the `/hello/` route.\n- **Assertions**: We check if the response‚Äôs status code is 200 (OK) and if the response data matches `{\"message\": \"Hello, World!\"}`.\n\n\n#### 4.2.4 Writing Integration Tests\n\nNow, let‚Äôs take things up a notch. We‚Äôll write an integration test for an endpoint that interacts with a database.\n\n**API to Test:**\n\n```python\nfrom fastapi import FastAPI, Depends\nfrom sqlmodel import SQLModel, Session, create_engine, Field, select\n\napp = FastAPI()\n\nclass User(SQLModel, table=True):\n    id: int = Field(primary_key=True)\n    name: str\n\nengine = create_engine(\"sqlite:///./test.db\")\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n@app.post(\"/users/\")\ndef create_user(name: str, session: Session = Depends(get_session)):\n    user = User(name=name)\n    session.add(user)\n    session.commit()\n    return user\n```\n\n**Writing the Integration Test**:\n\n```python\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlmodel import SQLModel, Session\nfrom myapp import app, engine\n\nclient = TestClient(app)\n\n@pytest.fixture\ndef setup_db():\n    # Set up the database before each test\n    SQLModel.metadata.create_all(engine)\n    yield\n    # Tear down the database after each test\n    SQLModel.metadata.drop_all(engine)\n\ndef test_create_user(setup_db):\n    response = client.post(\"/users/\", json={\"name\": \"Alice\"})\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"name\"] == \"Alice\"\n    assert \"id\" in data  # Check that the user has an id\n```\n\nüî• **Explanation**:\n\n- **`setup_db()`**: A pytest fixture that sets up and tears down the database for each test. This ensures that your tests always start with a clean slate.\n- **Integration Test**: We simulate a POST request to create a new user and verify that the response data contains the expected user name and a generated ID.\n\n#### 4.2.5 Mocking Dependencies in Tests\n\nSometimes, you don‚Äôt want to test every part of your app during unit tests. Maybe you don‚Äôt want to hit the actual database but want to **mock** the database connection instead. Here‚Äôs how you can do it:\n\n```python\nfrom unittest.mock import MagicMock\nfrom fastapi import Depends\n\ndef fake_get_session():\n    db = MagicMock()  # Mocked database session\n    yield db\n\n@app.post(\"/fake-user/\")\ndef create_fake_user(name: str, session = Depends(fake_get_session)):\n    session.add(name)  # Add a name to the mocked session\n    return {\"message\": f\"User {name} added\"}\n```\n\nüî• **Explanation**:\n\n- **`MagicMock()`**: A utility from the `unittest` library that allows us to mock dependencies like database connections.\n- **Fake Dependency**: We use the fake session during testing to ensure we don‚Äôt interact with the real database.\n\n#### 4.2.6 Testing Summary\n\n- **Unit tests**: Test individual components in isolation.\n- **Integration tests**: Ensure that different parts of your app work well together.\n- **TestClient**: Allows you to simulate HTTP requests to your FastAPI app.\n- **Pytest**: A powerful testing framework that integrates seamlessly with FastAPI.\n- **Mocking**: Helps you isolate your tests from real dependencies.\n\n### 4.3. Security in FastAPI\n> \"Locks on the door, security cameras on the house.\"  \nSecurity is **non-negotiable**. No one wants their API hacked or misused! You‚Äôll learn how to **protect** your FastAPI app from common vulnerabilities.\n\n> > \"Who are you? And what are you allowed to do?\"  \nFastAPI makes handling **authentication** and **authorization** simple, but don‚Äôt be fooled‚Äîit‚Äôs a crucial topic.\n\n\n- **Authentication and Authorization**  \nKeep the wrong people out and make sure the right people can only do what they‚Äôre supposed to do.\n\n- **Protecting Against Common Vulnerabilities**  \nWe‚Äôll go over real-world threats like **SQL injection**, **XSS**, and **CSRF**, and how to defend against them. Think of it as locking all the windows before leaving your house. \n\n- **Input Validation and Sanitization**  \nClean your data like you‚Äôd wash your hands‚Äîalways! No messy, untrusted input allowed.\n\n- **Secure Coding Practices**  \nIt‚Äôs like learning to cook without burning your kitchen down. Follow best practices to keep your app safe.\n\n#### 4.3.1 The Importance of Security in APIs \n\nYour API is like the front door to your application, and just like your house, you want to make sure it's locked and secure. Poor security practices can expose sensitive data, compromise user privacy, and leave your app vulnerable to attacks. With FastAPI, implementing security features is not only crucial but also relatively straightforward.\n\n#### 4.3.2 **Authentication vs. Authorization**\n\n- **Authentication**: Who are you? Authentication is the process of verifying the identity of a user or system.\n- **Authorization**: What are you allowed to do? Authorization is about determining what actions a verified user can perform.\n\nThink of authentication as checking a ticket at a concert and authorization as making sure you can access the VIP lounge.\n\n**Authentication in FastAPI**\n\nFastAPI provides several methods for authentication. One of the most popular and secure ways is **token-based authentication** using JWT (JSON Web Tokens). Let's dive into an example:\n\n1. **Installing the Required Package**:\n    ```bash\n    pip install pyjwt\n    ```\n\n2. **Creating the Token**:\nHere's how you can generate and validate a JWT for user authentication.\n\n```python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\napp = FastAPI()\n\n# Secret key to encode/decode JWT\nSECRET_KEY = \"mysecretkey\"\nALGORITHM = \"HS256\"\n\n# Mock user database\nfake_users_db = {\n    \"user1\": {\"username\": \"user1\", \"hashed_password\": \"fakehashedpassword\"}\n}\n\n# OAuth2 scheme\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\ndef create_access_token(data: dict):\n    \"\"\"Create JWT token.\"\"\"\n    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)\n\n@app.post(\"/token\")\ndef login(form_data: OAuth2PasswordRequestForm = Depends()):\n    \"\"\"Login and return JWT token.\"\"\"\n    user = fake_users_db.get(form_data.username)\n    if not user:\n        raise HTTPException(status_code=400, detail=\"Invalid credentials\")\n        \n        # Generate token with user data\n    token = create_access_token({\"sub\": form_data.username})\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n\n@app.get(\"/users/me\")\ndef get_user(token: str = Depends(oauth2_scheme)):\n    \"\"\"Get current user based on JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n        return {\"username\": username}\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n```\nüî• **Explanation**:\n\n- **JWT Token**: A JWT token is generated when a user logs in, and this token is used to authenticate the user in future requests.\n- **OAuth2PasswordBearer**: FastAPI's built-in method to handle OAuth2-based authentication, which works perfectly with JWT.\n- **Token Endpoint**: `/token` is where users will exchange their credentials for a token.\n- **Token Validation**: The token is decoded on subsequent requests to validate the user‚Äôs identity.\n\n**Authorization: Controlling Access**\n\nOnce you have authentication in place, the next step is**authorization‚Äîmaking sure users can only access what they are allowed to**.\n\nLet‚Äôs add some roles to our users and restrict certain routes based on these roles:\n\n```python\nfrom fastapi import Depends\n\nroles_db = {\n    \"user1\": {\"role\": \"admin\"},\n    \"user2\": {\"role\": \"user\"}\n}\n\ndef get_current_user(token: str = Depends(oauth2_scheme)):\n    payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n    username: str = payload.get(\"sub\")\n    return roles_db.get(username)\n\n@app.get(\"/admin/\")\ndef admin_area(user: dict = Depends(get_current_user)):\n    if user[\"role\"] != \"admin\":\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    return {\"message\": \"Welcome to the admin area\"}\n```\n\nüî• **Explanation**:\n\n- **Roles**: We've assigned roles (e.g., \"admin\", \"user\") to each user.\n- **Authorization Check**: We use the user‚Äôs role to allow or deny access to specific routes like `/admin/`.\n\n#### 4.3.3 Protecting Against Common Vulnerabilities\n\nIn addition to authentication and authorization, it's important to protect your FastAPI app against common security threats:\n\n- **SQL Injection**: Use parameterized queries or an ORM like SQLModel to avoid exposing your app to malicious SQL injection attacks.\n\n```python\n@app.get(\"/users/\")\ndef get_users(name: str, session: Session = Depends(get_session)):\n    statement = select(User).where(User.name == name)\n    return session.exec(statement).all()\n```\n\n- **Cross-Site Scripting (XSS)**: Always sanitize user inputs that are rendered back in the UI, especially if you're interacting with frontend components.\n- **Cross-Site Request Forgery (CSRF)**: FastAPI doesn‚Äôt include CSRF protection by default, but you can integrate external packages or implement custom middleware to guard against CSRF attacks.\n\n- **Input Validation**: FastAPI‚Äôs **Pydantic** models help you validate and sanitize inputs automatically. You should always ensure that the data users submit conforms to the expected format.\n\n```python\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr  # This ensures a valid email format\n```\n#### 4.3.4 Secure Coding Practices\n\nFollow these best practices to keep your code secure:\n\n1. **Limit Exposure**: Only expose the routes that are necessary and avoid allowing external access to sensitive routes (e.g., admin areas).\n2. **Use HTTPS**: Always deploy your FastAPI application with HTTPS in production to encrypt all data between the client and server.\n3. **Update Dependencies**: Regularly update your dependencies to ensure you‚Äôre using the latest security patches.\n4. **Environment Variables**: Store sensitive information (like database credentials and secret keys) in environment variables, not in your codebase.\n5. **Logging**: Set up proper logging to monitor and detect suspicious activity.\n\n\n### 4.4. Performance Optimization\n> \"Faster is always better, right?\"  \nSpeed is **key** when building APIs. Let‚Äôs make sure your FastAPI app can handle the pressure‚Äîwhether it's 10 users or 10,000.\n\nNow that you've built a secure and functional FastAPI app, it's time to make it *fly* by focusing on performance optimization! Whether your app is running a high-traffic API, managing real-time data, or simply needs to be more responsive, performance optimization can make a big difference in user experience.\n\n#### 4.4.1 Why Optimize?\n\nImagine you‚Äôre using a writing app that checks your spelling and grammar in real time.\n\nAs you type, you expect instant feedback‚Äîcorrections popping up seamlessly as you go. But what if there‚Äôs a lag? \n\nYou write a sentence, and the corrections take five seconds to appear. It throws off your rhythm, you lose focus, and eventually, you might give up on the app altogether.\n\nThat‚Äôs how your users feel when your FastAPI app is slow.\n\nThey expect things to work instantly, especially for real-time features. If your app can‚Äôt keep up with the demand, they‚Äôll find another tool that can. This lesson will teach you how to optimize your FastAPI app so it stays responsive, even when it's processing a lot of requests at once.\n\n#### 4.4.2. Caching Strategies: Save Time, Repeat Less\n\nWhen your app processes the same requests repeatedly, caching can be a lifesaver. Instead of recalculating or re-fetching data for every request, caching lets you store previously computed responses and serve them up super fast.\n\n**Example: Caching with `fastapi-cache`**\n\n1. **Installing the Required Package**:\n```bash\npip install fastapi-cache2\n```\n\n2. **Implementing Basic Caching**:\nHere's a simple way to cache the response of an endpoint using `fastapi-cache2`:\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi_cache import FastAPICache\nfrom fastapi_cache.backends.redis import RedisBackend\nimport redis\n\napp = FastAPI()\n\n@app.on_event(\"startup\")\nasync def startup():\n    redis_client = redis.Redis(host=\"localhost\", port=6379)\n    FastAPICache.init(RedisBackend(redis_client), prefix=\"fastapi-cache\")\n\n@app.get(\"/items/{item_id}\")\n@FastAPICache(expire=60)  # Cache this response for 60 seconds\nasync def get_item(item_id: int):\n# Imagine this is an expensive operation like a database call\n    return {\"item_id\": item_id, \"description\": \"This is an item.\"}\n```\n\nüî• **Explanation**:\n- **Redis**: We use Redis as a caching backend. Redis is a super fast in-memory data structure store, perfect for caching.\n- **FastAPICache**: This decorator caches the response of the `/items/{item_id}` endpoint for 60 seconds.\n\n**Why Caching Matters**:\n\n- **Faster Responses**: By storing responses, you reduce the time it takes to fetch data.\n- **Reduced Server Load**: You‚Äôre not hitting your database or performing expensive operations on every request.\n\n#### 4.4.3. Asynchronous Optimization: Handling Many Requests Like a Champ\n\nFastAPI shines when it comes to asynchronous programming. Unlike traditional synchronous frameworks, FastAPI can handle multiple requests concurrently, which means it‚Äôs great for high-performance use cases. [See in section 1. The magic of Asynchronicity](#the-magic-of-asynchronicity)\n\n#### 4.4.4. Profiling and Benchmarking: Measure Before You Improve\n\nYou can‚Äôt improve what you don‚Äôt measure! Profiling and benchmarking tools help you identify performance bottlenecks in your application so you know exactly where optimizations are needed.\n\n**Tools for Profiling**:\n- **cProfile**: Python‚Äôs built-in profiler.\n- **py-spy**: A sampling profiler that can show you where your app is spending most of its time, even in production.\n\n**Example: Using `py-spy`**\n\n1. **Installing `py-spy`**:\n    ```bash\n    pip install py-spy\n    ```\n\n2. **Profiling your FastAPI app**:\n    ```bash\n    py-spy top -- python3 -m uvicorn main:app\n    ```\n\nThis will show you a live breakdown of where your app is spending its CPU time. You can use this information to pinpoint slow parts of your code, like that unoptimized database query or the slow for-loop.\n\n**Example: Measuring Latency with `timeit`**\n\nHere‚Äôs a quick way to measure the latency of an endpoint using the `timeit` module:\n\n```python\nimport timeit\n\ndef measure():\n    return requests.get(\"http://localhost:8000/some-endpoint\")\n\nprint(timeit.timeit(measure, number=10))  # Run the request 10 times\n```\nRemember, this section is optional but packed with advanced, exciting tools to supercharge your FastAPI skills! \n\n## In Summary \n\n### Asynchronicity: The Key to Responsiveness\nUnderstanding asynchronous programming allows your FastAPI applications to handle multiple requests simultaneously, making them faster and more efficient. By leveraging `async` and `await`, your app can juggle tasks like a seasoned performer!\n\n### Routing: Navigating the API Landscape\nRouting is crucial for directing requests to the appropriate endpoints. You‚Äôve learned how to set up routes effectively, ensuring your users can access the functionality they need without a hitch.\n\n### Database Integration: Persistence Made Easy\nWe explored how to connect your FastAPI app with a database using SQLModel. By mastering CRUD operations, you can create, read, update, and delete data effortlessly, paving the way for dynamic applications.\n\n### Advanced Topics Toolbox: Powering Up Your Skills\nWe touched on various advanced topics, including dependency injection, testing, security measures, and performance optimization. These tools are essential for creating robust, secure, and high-performing applications that can handle the demands of modern users.\n\nNow that we‚Äôve covered the advanced topics, let‚Äôs dive into **[Lab 2](../01_Exercises/02_Lab.qmd)** and make your FastAPI apps **secure, fast, and scalable**! üí™\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"02_Lecture.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.554","code-summary":"Show the code","theme":{"light":["flatly","../styles.scss"]},"title":"Lecture 2 - Building Scalable and Efficient FastAPI Applications","author":"M√©nyssa Cherifa-Luron","date":"today"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}