{"title":"Lab 2 - Building Scalable and Efficient FastAPI Applications","markdown":{"yaml":{"title":"Lab 2 - Building Scalable and Efficient FastAPI Applications","author":"Ményssa Cherifa-Luron","date":"today"},"headingText":"Overview","containsRefs":false,"markdown":"\n\n\nIn this notebook, you will create two distinct APIs, each tailored for different industries:\n\n- **Marketing Agency API**: This API will help manage clients and their marketing campaigns for a fictional agency. You’ll handle client requests, campaign management, performance tracking, and secure sensitive data. The API will be designed to scale, allowing you to efficiently manage multiple clients and campaigns simultaneously.\n\n- **Healthcare Management API**:  This API is designed to manage patient records, doctor schedules, medical appointments, and prescriptions. The project will emphasize integrating external APIs, handling real-time data, and ensuring compliance with healthcare regulations.\n\n::: {.callout-important title=\"Note\" collapse=\"true\"}\nHealthcare Management API project is optional and intended for students who feel comfortable taking on an additional challenge\n::: \n\n## Goals\n\nBy the end of this lab, you should be able to:\n\n1. Use **asynchronous programming** to improve performance when handling multiple client requests.\n2. Create **CRUD routes** to manage clients and their marketing campaigns.\n3. Integrate a **database** to store client and campaign information.\n4. Apply **dependency injection** to keep your code modular.\n5. Write tests using **`pytest`** to verify that your client operations work as expected.\n6. Secure sensitive **client data** using authentication and authorization. (optional)\n7. Use **performance optimization** techniques to make your API efficient under high loads.(optional)\n\n## Prerequisites\n\nEnsure you have FastAPI, SQLAlchemy (or SQLModel), Pydantic, and other necessary libraries installed. You’ll also need access to Python and a terminal.\n\n## Marketing Agency API\n\n### Key Features\n\n1. **Client Management**:\n   - Create, update, and delete client profiles.\n   - Store client-specific information such as contact details and preferences.\n   \n2. **Campaign Management**:\n   - Create and manage marketing campaigns for clients.\n   - Track campaign performance metrics and budget allocations.\n\n3. **Database Integration**:\n   - Utilize SQLAlchemy for ORM and database management.\n   - Support for SQLite with easy migration to other databases if needed.\n\n4. **Fake Data Generation**: Populate the database with synthetic data for testing purposes using Faker.\n\n5. **API Testing**:\n   - Comprehensive test suite using `pytest` to ensure reliability.\n   - Test coverage for all major CRUD operations and business logic.\n\n### Project structure \n```bash\nMARKETING\n│\n├── .venv/\n│\n├── app/\n│   ├── test/\n│   │   ├── __init__.py\n│   │   └── test_unit.py\n│   │\n│   ├── __init__.py\n│   ├── campaign_routes.py\n│   ├── client_routes.py\n│   ├── database.py\n│   ├── generate_fake_data.py\n│   ├── main.py\n│   ├── models.py\n│   └── schemas.py\n│\n├── env/\n│\n├── prod.db\n│\n└── requirements.txt\n```\n\n### Implementation Steps\n\n#### 1. `app/__init__.py`\n\nLeave this file empty or add package-level documentation.\n\n#### 2. `app/models.py`\n\nDefine the database structure using SQLAlchemy models for `Client` and `Campaign`.\n\n1. **Import Necessary Components**:\n   - Import `Column`, `Integer`, `String`, `ForeignKey`, `DateTime`, `JSON`, `relationship` from SQLAlchemy.\n   - Import `Base` from your database setup file.\n\n2. **Define the `Client` Class**:\n   - Set `__tablename__ = \"clients\"` to specify the table name.\n   - Define columns:\n     - `id`: Primary key, integer, indexed.\n     - `name`: String, indexed.\n     - `email`: Unique string, indexed.\n   - Define a relationship with `Campaign`:\n     - `campaigns = relationship(\"Campaign\", back_populates=\"client\")`.\n\n3. **Define the `Campaign` Class**:\n   - Set `__tablename__ = \"campaigns\"` to specify the table name.\n   - Define columns:\n     - `id`: Primary key, integer, indexed.\n     - `campaign_name`: String, indexed.\n     - `description`: String for campaign description.\n     - `start_date`: DateTime for when the campaign starts.\n     - `budget`: Integer for campaign budget.\n     - `performance_metrics`: JSON for storing metrics.\n     - `canal`: String \n     - `client_id`: Foreign key referencing `clients.id`.\n   - Define a relationship with `Client`:\n     - `client = relationship(\"Client\", back_populates=\"campaigns\")`.\n\n#### 3. `app/schemas.py`\n\nCreate Pydantic models for validating request and response data.\n\n1. **Import BaseModel**:\n   - Import `BaseModel` from Pydantic.\n\n2. **Define `ClientSchema`**:\n   - Create a class `ClientBase` inheriting from `BaseModel` with fields:\n     - `name`: String.\n     - `email`: String.\n   - Create a class `ClientCreate` inheriting from `ClientBase` for creation-specific validation.\n\n3. **Define `Client`**:\n   - Create a class `Client` inheriting from `ClientBase` with an additional field:\n     - `id`: Integer.\n   - Add `Config` class inside to enable ORM mode: `orm_mode = True`.\n\n4. **Define `CampaignSchema`**:\n   - Create a class `CampaignBase` inheriting from `BaseModel` with fields:\n     - `campaign_name`: String.\n     - `description`: String.\n     - `start_date`: DateTime.\n     - `budget`: Integer.\n     - `performance_metrics`: JSON.\n     - `canal`:     canal: List[Literal['internet', 'tv', 'radio']].\n   - Create a class `CampaignCreate` inheriting from `CampaignBase` for creation-specific validation.\n\n5. **Define `Campaign`**:\n   - Create a class `Campaign` inheriting from `CampaignBase` with additional fields:\n     - `id`: Integer.\n     - `client_id`: Integer.\n   - Add `Config` class inside to enable ORM mode: `orm_mode = True`.\n\n#### 4. `app/database.py`\n\nSet up database configuration and connection.\n\n1. **Import Necessary Components**:\n   - Import `create_engine`, `sessionmaker`, and `declarative_base` from SQLAlchemy.\n\n2. **Configure Database**:\n   - Define the database URL using SQLite : DATABASE_URL = \"sqlite:///./prod.db\"\n   - Create a database engine and session local.\n   - Define a `Base` class for model definitions.\n\n#### 5. `app/generate_fake_data.py`\n\nPopulate the database with fake data for testing.\n\n1. **Install Faker**:\n   - Run `pip install faker`.\n\n2. **Generate Data**:\n   - Import Faker and create an instance.\n   - Generate sample data for 10 clients and 20 campaigns (2 campaigns/client)\n   - Insert this data into the database using SQLAlchemy.\n\n#### 6. `app/campaign_routes.py`\n\nDefine API routes for managing campaigns.\n\n1. **Import Necessary Components**:\n   - Import `APIRouter` from FastAPI.\n\n2. **Set Up CRUD Operations**:\n   - Define routes for creating, reading, updating, and deleting campaigns.\n   - Include additional routes for pausing and terminating campaigns.\n   - Use dependency injection to access the database session.\n\n#### 7. `app/client_routes.py`\n\nDefine API routes for managing clients.\n\n1. **Import Necessary Components**:\n   - Import `APIRouter` from FastAPI.\n\n2. **Set Up CRUD Operations**:\n   - Define routes for creating, reading, updating, and deleting clients.\n   - Use dependency injection to access the database session.\n\n#### 8. `app/main.py`\n\nInitialize the FastAPI application, include routers, and define application startup and shutdown behavior.\n\n1. Import Required Modules:\n- Import `FastAPI` from FastAPI.\n- Import `APIRouter` from `client_routes.py` and `campaign_routes.py`.\n- Import `asynccontextmanager` from `contextlib` for managing startup and shutdown tasks.\n- Import `generate_fake_data` from `generate_fake_data.py`.\n\n2. Initialize FastAPI with a lifespan context manager:\n```python\napp = FastAPI(lifespan=lifespan)\n```\n\n3. Add the client and campaign routers to the FastAPI instance:\n```python\napp.include_router(client_router, prefix=\"/clients\", tags=[\"Clients\"])\napp.include_router(campaign_router, prefix=\"/campaigns\", tags=[\"Campaigns\"])\n```\n\n4. Use the `@asynccontextmanager` decorator to define startup and shutdown logic:\n```python\n  @asynccontextmanager\n  async def lifespan(app: FastAPI):\n    # Startup logic\n    print(\"Generating fake data during startup...\")\n    generate_fake_data()  # Ensure this runs during startup\n      yield  # Pass control to the rest of the app\n    # Shutdown logic can be added here if needed\n```\n\n#### 10. `app/test/test_unit.py`\n\nTest the API endpoints for clients and campaigns to ensure they perform CRUD operations correctly.\n\n1. **Import Required Modules**:\n   - Import `pytest` for testing framework functionalities.\n   - Import `TestClient` from `fastapi.testclient` to simulate HTTP requests to the FastAPI app.\n   - Import `create_engine` and `sessionmaker` from `sqlalchemy` for database connections.\n   - Import `SQLModel` and `Session` from `sqlmodel`.\n   - Import `StaticPool` from `sqlmodel.pool` to manage SQLite in-memory database.\n\n2. **Import Your App and Models**:\n   - Import the FastAPI app from `app.main`.\n   - Import `get_db`, `engine`, and `Base` from `app.database`.\n   - Import `Client` and `Campaign` models from `app.models`.\n\n3. **Set Up Test Database**:\n   - Create an in-memory SQLite database for testing:\n     ```python\n     test_engine = create_engine(\n         \"sqlite://\", connect_args={\"check_same_thread\": False}, poolclass=StaticPool\n     )\n     ```\n   - Define a `SessionLocal` session factory bound to `test_engine`.\n\n4. **Create Database Tables**:\n   - Use `Base.metadata.create_all(bind=test_engine)` to create tables.\n\n5. **Define Fixtures**:\n   - **Session Fixture**:\n     - Create a fresh database session for each test:\n       ```python\n       @pytest.fixture(name=\"session\")\n       def session_fixture():\n           Base.metadata.create_all(bind=test_engine)\n           with Session(test_engine) as session:\n               yield session\n           Base.metadata.drop_all(bind=test_engine)  # Clean up after tests\n       ```\n   - **Client Fixture**:\n     - Override the default database session with the test session:\n       ```python\n       @pytest.fixture(name=\"client\")\n       def client_fixture(session: Session):\n           def get_session_override():\n               return session\n\n           app.dependency_overrides[get_db] = get_session_override\n           client = TestClient(app)\n           yield client\n           app.dependency_overrides.clear()\n       ```\n\n6. **One example : Test Create Client**:\n```python\ndef test_create_client(client: TestClient):\n  response = client.post(\n    \"/clients/\", json={\"name\": \"Test Client\", \"email\": \"test1@example.com\"}\n    )\n  data = response.json()\n  assert response.status_code == 200\n  assert data[\"name\"] == \"Test Client\"\n  assert data[\"email\"] == \"test1@example.com\"\n  assert data[\"id\"] is not None\n```\n**Do the same for all clients endpoints**\n\n7. **Run `pytest`** in the terminal from the project root to execute tests.\n\n#### 11. `requirements.txt`\n\nUse `pip freeze > requirements.txt` after installing packages. \n\n#### 12. Go Further : Implement Security\n\nSecure the application by implementing authentication and authorization.\n\n1. **Explore FastAPI Security**:\n   - Visit the FastAPI security tutorial: [FastAPI Security Documentation](https://fastapi.tiangolo.com/tutorial/security/).\n\n2. **Implement OAuth2 with Password (and hashing)**:\n   - Use `fastapi.security` to implement OAuth2 with password hashing.\n   - Set up a `get_current_user` dependency to secure routes.\n   - Define a `User` model for managing users and credentials.\n\n3. **Add JWT Authentication**:\n   - Use `python-jose` for JWT token management.\n   - Secure routes by requiring valid tokens for access.\n\n4. **Role-Based Access Control (RBAC)**:\n   - Implement roles (e.g., admin, user) to control access to specific endpoints.\n   - Use role checks in your route dependencies.\n\n5. **Test Security Features**:\n   - Write tests to ensure that unauthorized users cannot access protected endpoints.\n   - Verify that users with valid tokens have the correct permissions.\n\n\n## Healthcare Management API\n\n### Key Features\n- **Patient Management**: Create and manage patient profiles, including medical history and contact information.\n- **Doctor Schedule**: Organize and update doctor availability and appointments.\n- **Appointment Booking**: Allow patients to book, update, or cancel appointments.\n- **Prescription Management**: Track prescriptions, refills, and pharmacy interactions.\n- **Secure Data Handling**: Implement role-based access control and data encryption for patient confidentiality.\n- **Integration with External APIs**: Connect with third-party services for additional functionalities like pharmacy networks or insurance verification.\n- **Real-Time Notifications**: Implement WebSocket or similar technology for real-time updates on appointments and prescriptions.\n\n### Project Structure\n```\nHEALTHCARE\n│\n├── .venv/\n│\n├── app/\n│   ├── __pycache__/\n│   ├── test/\n│   │   ├── __pycache__/\n│   │   ├── __init__.py\n│   │   └── test_unit.py\n│   │\n│   ├── __init__.py\n│   ├── appointment_routes.py\n│   ├── doctor_routes.py\n│   ├── patient_routes.py\n│   ├── prescription_routes.py\n│   ├── database.py\n│   ├── external_api.py\n│   ├── main.py\n│   ├── models.py\n│   └── schemas.py\n│\n├── env/\n│\n├── prod.db\n│\n└── requirements.txt\n```\n\n### Implementation Steps\n\n1. **Set Up Project Environment**:\n   - Create a virtual environment and install necessary packages (`fastapi`, `uvicorn`, `sqlalchemy`, `pydantic`, `python-jose[cryptography]`, `websockets`).\n\n2. **Design Database Models**:\n   - Define models for `Patient`, `Doctor`, `Appointment`, and `Prescription` using SQLAlchemy.\n\n`Patient` Model\n\n- `id`: Integer, primary key\n- `name`: String, indexed\n- `age`: Integer\n- `gender`: String\n- `medical_history`: Text\n\n`Doctor` Model\n\n- `id`: Integer, primary key\n- `name`: String, indexed\n- `specialty`: String\n- `contact_info`: String\n\n`Appointment` Model\n\n- `id`: Integer, primary key\n- `appointment_date`: DateTime\n- `patient_id`: Integer, ForeignKey\n- `doctor_id`: Integer, ForeignKey\n- `status`: String\n\n`Prescription` Model\n\n- `id`: Integer, primary key\n- `medication_name`: String\n- `dosage`: String\n- `patient_id`: Integer, ForeignKey\n- `doctor_id`: Integer, ForeignKey\n- `instructions`: Text\n\n3. **Create Pydantic Schemas**:\n   - Design schemas for data validation and serialization.\n\n4. **Implement CRUD Operations**:\n   - Develop routes for managing patients, doctors, appointments, and prescriptions.\n\n5. **Secure the API**:\n   - Implement JWT authentication and role-based access control (RBAC).\n\n6. **Integrate External APIs**:\n   - Set up connections to pharmacy networks, insurance companies, or other relevant services.\n\n7. **Real-Time Data Handling**:\n   - Use WebSocket for notifications about appointment changes or prescription updates.\n\n8. **Testing**:\n   - Write unit and integration tests to ensure all functionalities work as expected.\n\n9. **Documentation**:\n   - Provide comprehensive API documentation using FastAPI’s built-in tools.\n\n","srcMarkdownNoYaml":"\n\n## Overview\n\nIn this notebook, you will create two distinct APIs, each tailored for different industries:\n\n- **Marketing Agency API**: This API will help manage clients and their marketing campaigns for a fictional agency. You’ll handle client requests, campaign management, performance tracking, and secure sensitive data. The API will be designed to scale, allowing you to efficiently manage multiple clients and campaigns simultaneously.\n\n- **Healthcare Management API**:  This API is designed to manage patient records, doctor schedules, medical appointments, and prescriptions. The project will emphasize integrating external APIs, handling real-time data, and ensuring compliance with healthcare regulations.\n\n::: {.callout-important title=\"Note\" collapse=\"true\"}\nHealthcare Management API project is optional and intended for students who feel comfortable taking on an additional challenge\n::: \n\n## Goals\n\nBy the end of this lab, you should be able to:\n\n1. Use **asynchronous programming** to improve performance when handling multiple client requests.\n2. Create **CRUD routes** to manage clients and their marketing campaigns.\n3. Integrate a **database** to store client and campaign information.\n4. Apply **dependency injection** to keep your code modular.\n5. Write tests using **`pytest`** to verify that your client operations work as expected.\n6. Secure sensitive **client data** using authentication and authorization. (optional)\n7. Use **performance optimization** techniques to make your API efficient under high loads.(optional)\n\n## Prerequisites\n\nEnsure you have FastAPI, SQLAlchemy (or SQLModel), Pydantic, and other necessary libraries installed. You’ll also need access to Python and a terminal.\n\n## Marketing Agency API\n\n### Key Features\n\n1. **Client Management**:\n   - Create, update, and delete client profiles.\n   - Store client-specific information such as contact details and preferences.\n   \n2. **Campaign Management**:\n   - Create and manage marketing campaigns for clients.\n   - Track campaign performance metrics and budget allocations.\n\n3. **Database Integration**:\n   - Utilize SQLAlchemy for ORM and database management.\n   - Support for SQLite with easy migration to other databases if needed.\n\n4. **Fake Data Generation**: Populate the database with synthetic data for testing purposes using Faker.\n\n5. **API Testing**:\n   - Comprehensive test suite using `pytest` to ensure reliability.\n   - Test coverage for all major CRUD operations and business logic.\n\n### Project structure \n```bash\nMARKETING\n│\n├── .venv/\n│\n├── app/\n│   ├── test/\n│   │   ├── __init__.py\n│   │   └── test_unit.py\n│   │\n│   ├── __init__.py\n│   ├── campaign_routes.py\n│   ├── client_routes.py\n│   ├── database.py\n│   ├── generate_fake_data.py\n│   ├── main.py\n│   ├── models.py\n│   └── schemas.py\n│\n├── env/\n│\n├── prod.db\n│\n└── requirements.txt\n```\n\n### Implementation Steps\n\n#### 1. `app/__init__.py`\n\nLeave this file empty or add package-level documentation.\n\n#### 2. `app/models.py`\n\nDefine the database structure using SQLAlchemy models for `Client` and `Campaign`.\n\n1. **Import Necessary Components**:\n   - Import `Column`, `Integer`, `String`, `ForeignKey`, `DateTime`, `JSON`, `relationship` from SQLAlchemy.\n   - Import `Base` from your database setup file.\n\n2. **Define the `Client` Class**:\n   - Set `__tablename__ = \"clients\"` to specify the table name.\n   - Define columns:\n     - `id`: Primary key, integer, indexed.\n     - `name`: String, indexed.\n     - `email`: Unique string, indexed.\n   - Define a relationship with `Campaign`:\n     - `campaigns = relationship(\"Campaign\", back_populates=\"client\")`.\n\n3. **Define the `Campaign` Class**:\n   - Set `__tablename__ = \"campaigns\"` to specify the table name.\n   - Define columns:\n     - `id`: Primary key, integer, indexed.\n     - `campaign_name`: String, indexed.\n     - `description`: String for campaign description.\n     - `start_date`: DateTime for when the campaign starts.\n     - `budget`: Integer for campaign budget.\n     - `performance_metrics`: JSON for storing metrics.\n     - `canal`: String \n     - `client_id`: Foreign key referencing `clients.id`.\n   - Define a relationship with `Client`:\n     - `client = relationship(\"Client\", back_populates=\"campaigns\")`.\n\n#### 3. `app/schemas.py`\n\nCreate Pydantic models for validating request and response data.\n\n1. **Import BaseModel**:\n   - Import `BaseModel` from Pydantic.\n\n2. **Define `ClientSchema`**:\n   - Create a class `ClientBase` inheriting from `BaseModel` with fields:\n     - `name`: String.\n     - `email`: String.\n   - Create a class `ClientCreate` inheriting from `ClientBase` for creation-specific validation.\n\n3. **Define `Client`**:\n   - Create a class `Client` inheriting from `ClientBase` with an additional field:\n     - `id`: Integer.\n   - Add `Config` class inside to enable ORM mode: `orm_mode = True`.\n\n4. **Define `CampaignSchema`**:\n   - Create a class `CampaignBase` inheriting from `BaseModel` with fields:\n     - `campaign_name`: String.\n     - `description`: String.\n     - `start_date`: DateTime.\n     - `budget`: Integer.\n     - `performance_metrics`: JSON.\n     - `canal`:     canal: List[Literal['internet', 'tv', 'radio']].\n   - Create a class `CampaignCreate` inheriting from `CampaignBase` for creation-specific validation.\n\n5. **Define `Campaign`**:\n   - Create a class `Campaign` inheriting from `CampaignBase` with additional fields:\n     - `id`: Integer.\n     - `client_id`: Integer.\n   - Add `Config` class inside to enable ORM mode: `orm_mode = True`.\n\n#### 4. `app/database.py`\n\nSet up database configuration and connection.\n\n1. **Import Necessary Components**:\n   - Import `create_engine`, `sessionmaker`, and `declarative_base` from SQLAlchemy.\n\n2. **Configure Database**:\n   - Define the database URL using SQLite : DATABASE_URL = \"sqlite:///./prod.db\"\n   - Create a database engine and session local.\n   - Define a `Base` class for model definitions.\n\n#### 5. `app/generate_fake_data.py`\n\nPopulate the database with fake data for testing.\n\n1. **Install Faker**:\n   - Run `pip install faker`.\n\n2. **Generate Data**:\n   - Import Faker and create an instance.\n   - Generate sample data for 10 clients and 20 campaigns (2 campaigns/client)\n   - Insert this data into the database using SQLAlchemy.\n\n#### 6. `app/campaign_routes.py`\n\nDefine API routes for managing campaigns.\n\n1. **Import Necessary Components**:\n   - Import `APIRouter` from FastAPI.\n\n2. **Set Up CRUD Operations**:\n   - Define routes for creating, reading, updating, and deleting campaigns.\n   - Include additional routes for pausing and terminating campaigns.\n   - Use dependency injection to access the database session.\n\n#### 7. `app/client_routes.py`\n\nDefine API routes for managing clients.\n\n1. **Import Necessary Components**:\n   - Import `APIRouter` from FastAPI.\n\n2. **Set Up CRUD Operations**:\n   - Define routes for creating, reading, updating, and deleting clients.\n   - Use dependency injection to access the database session.\n\n#### 8. `app/main.py`\n\nInitialize the FastAPI application, include routers, and define application startup and shutdown behavior.\n\n1. Import Required Modules:\n- Import `FastAPI` from FastAPI.\n- Import `APIRouter` from `client_routes.py` and `campaign_routes.py`.\n- Import `asynccontextmanager` from `contextlib` for managing startup and shutdown tasks.\n- Import `generate_fake_data` from `generate_fake_data.py`.\n\n2. Initialize FastAPI with a lifespan context manager:\n```python\napp = FastAPI(lifespan=lifespan)\n```\n\n3. Add the client and campaign routers to the FastAPI instance:\n```python\napp.include_router(client_router, prefix=\"/clients\", tags=[\"Clients\"])\napp.include_router(campaign_router, prefix=\"/campaigns\", tags=[\"Campaigns\"])\n```\n\n4. Use the `@asynccontextmanager` decorator to define startup and shutdown logic:\n```python\n  @asynccontextmanager\n  async def lifespan(app: FastAPI):\n    # Startup logic\n    print(\"Generating fake data during startup...\")\n    generate_fake_data()  # Ensure this runs during startup\n      yield  # Pass control to the rest of the app\n    # Shutdown logic can be added here if needed\n```\n\n#### 10. `app/test/test_unit.py`\n\nTest the API endpoints for clients and campaigns to ensure they perform CRUD operations correctly.\n\n1. **Import Required Modules**:\n   - Import `pytest` for testing framework functionalities.\n   - Import `TestClient` from `fastapi.testclient` to simulate HTTP requests to the FastAPI app.\n   - Import `create_engine` and `sessionmaker` from `sqlalchemy` for database connections.\n   - Import `SQLModel` and `Session` from `sqlmodel`.\n   - Import `StaticPool` from `sqlmodel.pool` to manage SQLite in-memory database.\n\n2. **Import Your App and Models**:\n   - Import the FastAPI app from `app.main`.\n   - Import `get_db`, `engine`, and `Base` from `app.database`.\n   - Import `Client` and `Campaign` models from `app.models`.\n\n3. **Set Up Test Database**:\n   - Create an in-memory SQLite database for testing:\n     ```python\n     test_engine = create_engine(\n         \"sqlite://\", connect_args={\"check_same_thread\": False}, poolclass=StaticPool\n     )\n     ```\n   - Define a `SessionLocal` session factory bound to `test_engine`.\n\n4. **Create Database Tables**:\n   - Use `Base.metadata.create_all(bind=test_engine)` to create tables.\n\n5. **Define Fixtures**:\n   - **Session Fixture**:\n     - Create a fresh database session for each test:\n       ```python\n       @pytest.fixture(name=\"session\")\n       def session_fixture():\n           Base.metadata.create_all(bind=test_engine)\n           with Session(test_engine) as session:\n               yield session\n           Base.metadata.drop_all(bind=test_engine)  # Clean up after tests\n       ```\n   - **Client Fixture**:\n     - Override the default database session with the test session:\n       ```python\n       @pytest.fixture(name=\"client\")\n       def client_fixture(session: Session):\n           def get_session_override():\n               return session\n\n           app.dependency_overrides[get_db] = get_session_override\n           client = TestClient(app)\n           yield client\n           app.dependency_overrides.clear()\n       ```\n\n6. **One example : Test Create Client**:\n```python\ndef test_create_client(client: TestClient):\n  response = client.post(\n    \"/clients/\", json={\"name\": \"Test Client\", \"email\": \"test1@example.com\"}\n    )\n  data = response.json()\n  assert response.status_code == 200\n  assert data[\"name\"] == \"Test Client\"\n  assert data[\"email\"] == \"test1@example.com\"\n  assert data[\"id\"] is not None\n```\n**Do the same for all clients endpoints**\n\n7. **Run `pytest`** in the terminal from the project root to execute tests.\n\n#### 11. `requirements.txt`\n\nUse `pip freeze > requirements.txt` after installing packages. \n\n#### 12. Go Further : Implement Security\n\nSecure the application by implementing authentication and authorization.\n\n1. **Explore FastAPI Security**:\n   - Visit the FastAPI security tutorial: [FastAPI Security Documentation](https://fastapi.tiangolo.com/tutorial/security/).\n\n2. **Implement OAuth2 with Password (and hashing)**:\n   - Use `fastapi.security` to implement OAuth2 with password hashing.\n   - Set up a `get_current_user` dependency to secure routes.\n   - Define a `User` model for managing users and credentials.\n\n3. **Add JWT Authentication**:\n   - Use `python-jose` for JWT token management.\n   - Secure routes by requiring valid tokens for access.\n\n4. **Role-Based Access Control (RBAC)**:\n   - Implement roles (e.g., admin, user) to control access to specific endpoints.\n   - Use role checks in your route dependencies.\n\n5. **Test Security Features**:\n   - Write tests to ensure that unauthorized users cannot access protected endpoints.\n   - Verify that users with valid tokens have the correct permissions.\n\n\n## Healthcare Management API\n\n### Key Features\n- **Patient Management**: Create and manage patient profiles, including medical history and contact information.\n- **Doctor Schedule**: Organize and update doctor availability and appointments.\n- **Appointment Booking**: Allow patients to book, update, or cancel appointments.\n- **Prescription Management**: Track prescriptions, refills, and pharmacy interactions.\n- **Secure Data Handling**: Implement role-based access control and data encryption for patient confidentiality.\n- **Integration with External APIs**: Connect with third-party services for additional functionalities like pharmacy networks or insurance verification.\n- **Real-Time Notifications**: Implement WebSocket or similar technology for real-time updates on appointments and prescriptions.\n\n### Project Structure\n```\nHEALTHCARE\n│\n├── .venv/\n│\n├── app/\n│   ├── __pycache__/\n│   ├── test/\n│   │   ├── __pycache__/\n│   │   ├── __init__.py\n│   │   └── test_unit.py\n│   │\n│   ├── __init__.py\n│   ├── appointment_routes.py\n│   ├── doctor_routes.py\n│   ├── patient_routes.py\n│   ├── prescription_routes.py\n│   ├── database.py\n│   ├── external_api.py\n│   ├── main.py\n│   ├── models.py\n│   └── schemas.py\n│\n├── env/\n│\n├── prod.db\n│\n└── requirements.txt\n```\n\n### Implementation Steps\n\n1. **Set Up Project Environment**:\n   - Create a virtual environment and install necessary packages (`fastapi`, `uvicorn`, `sqlalchemy`, `pydantic`, `python-jose[cryptography]`, `websockets`).\n\n2. **Design Database Models**:\n   - Define models for `Patient`, `Doctor`, `Appointment`, and `Prescription` using SQLAlchemy.\n\n`Patient` Model\n\n- `id`: Integer, primary key\n- `name`: String, indexed\n- `age`: Integer\n- `gender`: String\n- `medical_history`: Text\n\n`Doctor` Model\n\n- `id`: Integer, primary key\n- `name`: String, indexed\n- `specialty`: String\n- `contact_info`: String\n\n`Appointment` Model\n\n- `id`: Integer, primary key\n- `appointment_date`: DateTime\n- `patient_id`: Integer, ForeignKey\n- `doctor_id`: Integer, ForeignKey\n- `status`: String\n\n`Prescription` Model\n\n- `id`: Integer, primary key\n- `medication_name`: String\n- `dosage`: String\n- `patient_id`: Integer, ForeignKey\n- `doctor_id`: Integer, ForeignKey\n- `instructions`: Text\n\n3. **Create Pydantic Schemas**:\n   - Design schemas for data validation and serialization.\n\n4. **Implement CRUD Operations**:\n   - Develop routes for managing patients, doctors, appointments, and prescriptions.\n\n5. **Secure the API**:\n   - Implement JWT authentication and role-based access control (RBAC).\n\n6. **Integrate External APIs**:\n   - Set up connections to pharmacy networks, insurance companies, or other relevant services.\n\n7. **Real-Time Data Handling**:\n   - Use WebSocket for notifications about appointment changes or prescription updates.\n\n8. **Testing**:\n   - Write unit and integration tests to ensure all functionalities work as expected.\n\n9. **Documentation**:\n   - Provide comprehensive API documentation using FastAPI’s built-in tools.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"02_Lab.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.554","code-summary":"Show the code","theme":{"light":["flatly","../styles.scss"]},"title":"Lab 2 - Building Scalable and Efficient FastAPI Applications","author":"Ményssa Cherifa-Luron","date":"today"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}