[
  {
    "objectID": "Syllabus.html",
    "href": "Syllabus.html",
    "title": "üìã FastAPI Course Syllabus",
    "section": "",
    "text": "This course offers an introduction to FastAPI, a high-performance Python web framework designed for building APIs quickly and efficiently.\nThrough a mix of lectures, coding exercises, and hands-on projects, students will develop the skills necessary to build, manage, and deploy APIs, with a focus on scalability, asynchronous operations, and modern development practices.",
    "crumbs": [
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "Syllabus.html#course-overview",
    "href": "Syllabus.html#course-overview",
    "title": "üìã FastAPI Course Syllabus",
    "section": "",
    "text": "This course offers an introduction to FastAPI, a high-performance Python web framework designed for building APIs quickly and efficiently.\nThrough a mix of lectures, coding exercises, and hands-on projects, students will develop the skills necessary to build, manage, and deploy APIs, with a focus on scalability, asynchronous operations, and modern development practices.",
    "crumbs": [
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "Syllabus.html#course-structure",
    "href": "Syllabus.html#course-structure",
    "title": "üìã FastAPI Course Syllabus",
    "section": "Course Structure",
    "text": "Course Structure\n\nüìö Lectures: Theory and live coding examples to boost your understanding.\nüõ†Ô∏è Exercises: Hands-on tasks to solidify your skills.\nüéì Instructor Files: Teaching resources, including solutions and assessments.",
    "crumbs": [
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "Syllabus.html#syllabus",
    "href": "Syllabus.html#syllabus",
    "title": "üìã FastAPI Course Syllabus",
    "section": "Syllabus",
    "text": "Syllabus\n\nLecture 1. Introduction to FastAPI & Development Setup\n\nWhat the Heck is an API, and Why Should You Care?\nThe Importance of APIs in Client-Server Architecture\nHTTP Basics: It‚Äôs Like a Postman for the Web\n\n3.1. Requests in the Tech World\n3.2. HTTP Status Codes\n3.3. Role of HTTP Verbs in RESTful Web Services\n3.4. REST, SOAP, and GraphQL: The Web‚Äôs Favorite Squabble\n\nURL Construction: What is a URL?\n\n4.1. Components of a URL\n4.2. Constructing a URL with Parameters\n4.3. Best Practices for URL Construction\n4.4. Constructing API URLs: Example Scenarios\n\nFull Architecture of an HTTP Request and Response: A Breakdown\nFastAPI‚Äôs Superpowers\n\n6.1. FastAPI vs.¬†Flask vs.¬†Django\n6.2. Key Features\n\n\n\n\nLecture 2. Building Scalable and Efficient FastAPI Applications\n\nThe Magic of Asynchronicity\n\n1.1. Synchronous vs.¬†Asynchronous Execution\n1.2. Implementing Asynchronous Endpoints\n1.3. Best Practices for Asynchronous Programming\n\nAdvanced Routing: The Map of Your FastAPI World\n\n2.1. Introduction to Routers\n2.2. Path Parameters and Query Parameters\n2.3. Custom Routers and Middleware\n\nDatabase Dynamo: Powering Your App\n\n3.1. Choosing the Right Database\n3.2. SQLAlchemy and SQLModel\n3.3. Database Migrations (Optional)\n\nAdvanced Topics Toolbox (Very advanced, so very optional)\n\n4.1. Dependency Injection\n4.2. Testing FastAPI Applications\n4.3. Security in FastAPI\n4.4. Performance Optimization\n\n\n\n\nLecture 3. Deployment and Production Considerations\n\nIntroduction to Deploying Machine Learning Applications\n\n1.1. The Challenges of Deploying Machine Learning Models\n1.2. Different Deployment Approaches\n1.3. Introduction to Containerization with Docker\n1.4. Benefits of Using Docker for Deployment\n\nGetting Started with Docker\n\n2.1. Installing and Configuring Docker\n2.2. Key Concepts: Images, Containers, Dockerfile\n2.3. Creating a Simple Docker Image for a FastAPI Application\n2.4. Running and Managing Docker Containers\n\nDockerizing a Machine Learning Application\n\n3.2. Creating a Dockerfile for the Application\n3.3. Defining Dependencies and Configurations\n3.4. Exposing Ports and Setting the Run Command\n3.5. Building and Running the Docker Container\n3.6. Deploying the Docker Image\n\n3.6.1. Deploy to Heroku (Using Container Registry)\n3.6.2. Deploy to AWS Elastic Container Service (ECS)\n\nRecap and Project Structure\n\nIntroduction to GitHub Actions\n\n4.1. Principles of Continuous Integration and Continuous Delivery (CI/CD)\n4.2. Overview of GitHub Actions and Its Components\n4.3. Creating a Basic GitHub Actions Workflow\n4.4. Defining Triggers and Jobs for Deployment\n\nAutomating the Deployment Process with GitHub Actions\n\n5.1. Setting Up GitHub Actions for Our Project\n5.2. Configuring a Workflow for Docker Build and Deployment\n5.3. Handling Secrets and Environment Variables\n5.4. Monitoring and Managing Workflow Runs\n5.5. Best Practices for CI/CD with GitHub Actions",
    "crumbs": [
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "Syllabus.html#lectures-objectives",
    "href": "Syllabus.html#lectures-objectives",
    "title": "üìã FastAPI Course Syllabus",
    "section": "Lectures Objectives",
    "text": "Lectures Objectives\n\nLecture 1: Introduction to FastAPI & Development Setup\nContent Overview üéì\nThis module introduces the foundations of API development, HTTP basics, and how to get started with FastAPI. Students will learn how APIs function, the request/response cycle, and the technical setup for FastAPI applications.\nLearning Objectives üß†\n\nDefine what an API is and explain the basic components of HTTP (methods, status codes, headers)\nDescribe the request/response cycle and how clients and servers communicate\nSet up a FastAPI development environment, create your first FastAPI app, and run it locally.\nRecall basic commands and syntax for setting up a FastAPI environment.\nComprehend the purpose and function of FastAPI and its components.\nBreak down the structure of FastAPI applications to understand their components.\nExplain the purpose of different HTTP methods (GET, POST, PUT, DELETE) and their real-life use cases.\nEvaluating the correctness and efficiency of CRUD operations\nDevelop new FastAPI applications or extend existing ones with additional features.\nCreating new endpoints using Pydantic models to handle complex data validation and processing.\nCustomized the endpoints of the API documentation to enhance clarity and usability.\n\n\n\nLecture 2: Building Scalable and Efficient FastAPI Applications\nContent Overview üéì\nIn this module, students will dive deeper into FastAPI‚Äôs core features, such as asynchronous programming, path parameters, and data validation.\nAdditionally, this module covers the integration of databases (e.g., SQLAlchemy) to store and retrieve data.\nLearning Objectives üß†\n\nOrganize and manage routers to effectively structure large-scale FastAPI projects.\nIdentify and evaluate database integration tools that are compatible with FastAPI for seamless data management.\nImplement a persistent database solution to efficiently store and retrieve necessary data within FastAPI applications.\nArticulate how FastAPI leverages Python‚Äôs async/await syntax to handle multiple requests concurrently, enhancing application performance.\nExplore SQLModel as an ORM solution that integrates the capabilities of Pydantic and SQLAlchemy for streamlined data modeling and interaction.\nUtilize asynchronous programming techniques to perform non-blocking database queries, optimizing the responsiveness of FastAPI applications.\n\n\n\nLecture 3: Deployment and Production Considerations\n\nUnderstand containerization and CI/CD concepts.\nBuild Docker images for machine learning applications.\nSet up GitHub Actions workflows for automated deployments.\nDeploy and manage machine learning applications on the Heroku platform.\n\nContent Overview üéì\nThis module focuses on preparing FastAPI applications for deployment. Students will learn how to containerize their applications using Docker and deploy them to cloud services such as Heroku or AWS, ensuring that the application can scale and handle real-world traffic.\nLearning Objectives üß†\n\nIdentify the steps required for deploying a FastAPI application to a cloud platform.\nList common cloud platforms (e.g., AWS, Heroku, GCP) and their basic services for web applications.\nDescribe the importance of Docker in creating reproducible environments for deployment.\nExplain how scaling works on cloud platforms and why it is critical for handling increased traffic.\nContainerize a FastAPI application using Docker and deploy it to a cloud service.\nImplement environment variables and configurations for production environments.\nAnalyze the advantages and challenges of deploying a FastAPI application in the cloud versus on-premise.\nCompare different deployment strategies (manual vs.¬†automated CI/CD pipelines).\nEvaluate the performance of a deployed FastAPI application under different traffic conditions.",
    "crumbs": [
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "Syllabus.html#assessment-and-evaluation",
    "href": "Syllabus.html#assessment-and-evaluation",
    "title": "üìã FastAPI Course Syllabus",
    "section": "Assessment and Evaluation",
    "text": "Assessment and Evaluation\n\nLectures: Participation and engagement in live sessions.\nExercises: Hands-on coding tasks that will be graded based on completion and accuracy.\nFinal Project: A capstone project where students will build, document, and deploy a complete FastAPI-based API.\nInstructor Feedback: Personalized feedback will be provided throughout the course to ensure continuous improvement.",
    "crumbs": [
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "Syllabus.html#expectations-for-students",
    "href": "Syllabus.html#expectations-for-students",
    "title": "üìã FastAPI Course Syllabus",
    "section": "Expectations for Students",
    "text": "Expectations for Students\nStudents are expected to actively participate in all lectures, complete exercises on time, and engage with their peers in group discussions or projects. Continuous feedback will be provided to help students improve.",
    "crumbs": [
      "Course information",
      "Syllabus"
    ]
  },
  {
    "objectID": "LICENSE-CC-BY-NC-ND-4.0.html",
    "href": "LICENSE-CC-BY-NC-ND-4.0.html",
    "title": "Attribution-NonCommercial-NoDerivatives 4.0 International",
    "section": "",
    "text": "Creative Commons Corporation (‚ÄúCreative Commons‚Äù) is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an ‚Äúas-is‚Äù basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible.\n\nCreative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses.\n\nConsiderations for licensors: Our public licenses are intended for use by those authorized to give the public permission to use material in ways otherwise restricted by copyright and certain other rights. Our licenses are irrevocable. Licensors should read and understand the terms and conditions of the license they choose before applying it. Licensors should also secure all rights necessary before applying our licenses so that the public can reuse the material as expected. Licensors should clearly mark any material not subject to the license. This includes other CC-licensed material, or material used under an exception or limitation to copyright. More considerations for licensors.\nConsiderations for the public: By using one of our public licenses, a licensor grants the public permission to use the licensed material under specified terms and conditions. If the licensor‚Äôs permission is not necessary for any reason‚Äìfor example, because of any applicable exception or limitation to copyright‚Äìthen that use is not regulated by the license. Our licenses grant only permissions under copyright and certain other rights that a licensor has authority to grant. Use of the licensed material may still be restricted for other reasons, including because others have copyright or other rights in the material. A licensor may make special requests, such as asking that all changes be marked or described. Although not required by our licenses, you are encouraged to respect those requests where reasonable. More considerations for the public.\n\n\n\n\nBy exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License (‚ÄúPublic License‚Äù). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.\n\n\n\nAdapted Material means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.\nCopyright and Similar Rights means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights.\nEffective Technological Measures means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements.\nExceptions and Limitations means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.\nLicensed Material means the artistic or literary work, database, or other material to which the Licensor applied this Public License.\nLicensed Rights means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license.\nLicensor means the individual(s) or entity(ies) granting rights under this Public License.\nNonCommercial means not primarily intended for or directed towards commercial advantage or monetary compensation. For purposes of this Public License, the exchange of the Licensed Material for other material subject to Copyright and Similar Rights by digital file-sharing or similar means is NonCommercial provided there is no payment of monetary compensation in connection with the exchange.\nShare means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.\nSui Generis Database Rights means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.\nYou means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning.\n\n\n\n\n\nLicense grant.\n\nSubject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:\nA. reproduce and Share the Licensed Material, in whole or in part, for NonCommercial purposes only; and\nB. produce and reproduce, but not Share, Adapted Material for NonCommercial purposes only.\nExceptions and Limitations. For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.\nTerm. The term of this Public License is specified in Section 6(a).\nMedia and formats; technical modifications allowed. The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)(4) never produces Adapted Material.\nDownstream recipients.\nA. Offer from the Licensor ‚Äì Licensed Material. Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.\nB. No downstream restrictions. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.\nNo endorsement. Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i).\n\nOther rights.\n\nMoral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.\nPatent and trademark rights are not licensed under this Public License.\nTo the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties, including when the Licensed Material is used other than for NonCommercial purposes.\n\n\n\n\n\nYour exercise of the Licensed Rights is expressly made subject to the following conditions.\n\nAttribution.\n\nIf You Share the Licensed Material, You must:\nA. retain the following if it is supplied by the Licensor with the Licensed Material:\n\nidentification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);\na copyright notice;\na notice that refers to this Public License;\na notice that refers to the disclaimer of warranties;\na URI or hyperlink to the Licensed Material to the extent reasonably practicable;\n\nB. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and\nC. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.\nFor the avoidance of doubt, You do not have permission under this Public License to Share Adapted Material.\nYou may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.\nIf requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable.\n\n\n\n\n\nWhere the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:\n\nfor the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database for NonCommercial purposes only and provided You do not Share Adapted Material;\nif You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material; and\nYou must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database.\n\nFor the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.\n\n\n\n\nUnless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You.\nTo the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You.\nThe disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.\n\n\n\n\n\nThis Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.\nWhere Your right to use the Licensed Material has terminated under Section 6(a), it reinstates:\n\nautomatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or\nupon express reinstatement by the Licensor.\n\nFor the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.\nFor the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.\nSections 1, 5, 6, 7, and 8 survive termination of this Public License.\n\n\n\n\n\nThe Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.\nAny arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.\n\n\n\n\n\nFor the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.\nTo the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.\nNo term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.\nNothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority.\n\n\nCreative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the ‚ÄúLicensor.‚Äù Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at creativecommons.org/policies, Creative Commons does not authorize the use of the trademark ‚ÄúCreative Commons‚Äù or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.\nCreative Commons may be contacted at creativecommons.org."
  },
  {
    "objectID": "LICENSE-CC-BY-NC-ND-4.0.html#creative-commons-attribution-noncommercial-noderivatives-4.0-international-public-license",
    "href": "LICENSE-CC-BY-NC-ND-4.0.html#creative-commons-attribution-noncommercial-noderivatives-4.0-international-public-license",
    "title": "Attribution-NonCommercial-NoDerivatives 4.0 International",
    "section": "",
    "text": "By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License (‚ÄúPublic License‚Äù). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.\n\n\n\nAdapted Material means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.\nCopyright and Similar Rights means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights.\nEffective Technological Measures means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements.\nExceptions and Limitations means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.\nLicensed Material means the artistic or literary work, database, or other material to which the Licensor applied this Public License.\nLicensed Rights means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license.\nLicensor means the individual(s) or entity(ies) granting rights under this Public License.\nNonCommercial means not primarily intended for or directed towards commercial advantage or monetary compensation. For purposes of this Public License, the exchange of the Licensed Material for other material subject to Copyright and Similar Rights by digital file-sharing or similar means is NonCommercial provided there is no payment of monetary compensation in connection with the exchange.\nShare means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.\nSui Generis Database Rights means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.\nYou means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning.\n\n\n\n\n\nLicense grant.\n\nSubject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:\nA. reproduce and Share the Licensed Material, in whole or in part, for NonCommercial purposes only; and\nB. produce and reproduce, but not Share, Adapted Material for NonCommercial purposes only.\nExceptions and Limitations. For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.\nTerm. The term of this Public License is specified in Section 6(a).\nMedia and formats; technical modifications allowed. The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)(4) never produces Adapted Material.\nDownstream recipients.\nA. Offer from the Licensor ‚Äì Licensed Material. Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.\nB. No downstream restrictions. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.\nNo endorsement. Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i).\n\nOther rights.\n\nMoral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.\nPatent and trademark rights are not licensed under this Public License.\nTo the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties, including when the Licensed Material is used other than for NonCommercial purposes.\n\n\n\n\n\nYour exercise of the Licensed Rights is expressly made subject to the following conditions.\n\nAttribution.\n\nIf You Share the Licensed Material, You must:\nA. retain the following if it is supplied by the Licensor with the Licensed Material:\n\nidentification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);\na copyright notice;\na notice that refers to this Public License;\na notice that refers to the disclaimer of warranties;\na URI or hyperlink to the Licensed Material to the extent reasonably practicable;\n\nB. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and\nC. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.\nFor the avoidance of doubt, You do not have permission under this Public License to Share Adapted Material.\nYou may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.\nIf requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable.\n\n\n\n\n\nWhere the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:\n\nfor the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database for NonCommercial purposes only and provided You do not Share Adapted Material;\nif You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material; and\nYou must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database.\n\nFor the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.\n\n\n\n\nUnless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You.\nTo the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You.\nThe disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.\n\n\n\n\n\nThis Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.\nWhere Your right to use the Licensed Material has terminated under Section 6(a), it reinstates:\n\nautomatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or\nupon express reinstatement by the Licensor.\n\nFor the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.\nFor the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.\nSections 1, 5, 6, 7, and 8 survive termination of this Public License.\n\n\n\n\n\nThe Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.\nAny arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.\n\n\n\n\n\nFor the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.\nTo the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.\nNo term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.\nNothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority.\n\n\nCreative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the ‚ÄúLicensor.‚Äù Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at creativecommons.org/policies, Creative Commons does not authorize the use of the trademark ‚ÄúCreative Commons‚Äù or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.\nCreative Commons may be contacted at creativecommons.org."
  },
  {
    "objectID": "02_Instructors/instructors_notes.html",
    "href": "02_Instructors/instructors_notes.html",
    "title": "üìë FastAPI Course with Principles of Andragogy",
    "section": "",
    "text": "Understanding that your students are adults with professional experiences, you can apply the principles of andragogy to enhance their learning.\nHere‚Äôs how:\n\nLeverage Past Experiences:\n\nTip: Encourage students to share their experiences with APIs or web applications they‚Äôve used or developed. This will help them relate the material to their professional context and see its real-world applicability.\nExample: Ask students to discuss a time when they encountered or had to integrate with an API in their job. This can prompt a discussion about the challenges they faced and how FastAPI could simplify such tasks.\n\nSelf-Direction:\n\nTip: Provide opportunities for students to explore topics of interest within FastAPI and its applications. This could be through elective projects or optional advanced topics.\nExample: Allow students to choose a mini-project related to their field or job, such as building a small API to automate a task they perform frequently.\n\nRelevance to Work:\n\nTip: Ensure that the course content is directly applicable to their careers. Highlight how FastAPI can be used to solve industry-specific challenges.\nExample: In a lecture on database integration, discuss how FastAPI can be used to streamline data handling in sectors like finance or healthcare, where data integrity and speed are crucial.\n\nProblem-Centered Approach:\n\nTip: Use problem-solving as a core teaching strategy. Present real-world problems and guide students in using FastAPI to develop solutions.\nExample: Create a scenario where students must build a RESTful API to handle a client‚Äôs data request and response cycle efficiently.\n\nImmediate Application:\n\nTip: Structure the course so that students can immediately apply what they learn to their work.\nExample: After teaching a concept, have students implement a small feature or fix an issue in a simulated project setting.\n\nMotivation to Learn:\n\nTip: Connect the learning objectives to personal and professional growth opportunities.\nExample: Emphasize how mastering FastAPI can enhance their skill set, making them more competitive in the job market."
  },
  {
    "objectID": "02_Instructors/assessment_materials.html",
    "href": "02_Instructors/assessment_materials.html",
    "title": "üìë Instructors",
    "section": "",
    "text": "Welcome to the HealthPredictor Project guide!\nThis document outlines the framework for delivering the HealthPredictor project, designed for students to develop a comprehensive full-stack healthcare application.\nThis project combines machine learning, FastAPI for the backend, and a modern frontend framework. Through this experience, students will gain valuable insights and hands-on skills relevant to real-world healthcare challenges."
  },
  {
    "objectID": "02_Instructors/assessment_materials.html#project-objectives",
    "href": "02_Instructors/assessment_materials.html#project-objectives",
    "title": "üìë Instructors",
    "section": "Project Objectives",
    "text": "Project Objectives\nBy the end of this project, students will be able to:\n\nDevelop a FastAPI application with machine learning capabilities to predict health risks based on user input.\nCreate a responsive frontend using a JavaScript framework (React, Vue.js, or Angular) that interacts seamlessly with the backend.\nImplement RESTful API endpoints for data management and predictions.\nDeploy the application using Docker and set up Continuous Integration/Continuous Deployment (CI/CD) pipelines for automated deployment.\nApply best practices in software development, including code organization, documentation, and testing methodologies."
  },
  {
    "objectID": "02_Instructors/assessment_materials.html#project-structure-and-phases",
    "href": "02_Instructors/assessment_materials.html#project-structure-and-phases",
    "title": "üìë Instructors",
    "section": "Project Structure and Phases",
    "text": "Project Structure and Phases\nThe FastAPI FullStack template\n\nPhase 1: Research and Planning (1 week)\n\nActivities:\n\nStudents select a healthcare dataset (e.g., heart disease, diabetes, or other relevant datasets).\nOutline the features and functionalities of the application, including user input forms and prediction results.\nDesign the database schema, ensuring it meets the application‚Äôs requirements.\n\nDeliverables:\n\nDataset Selection Document: Justification for the chosen dataset and its relevance to the project.\nProject Feature List: A comprehensive list of features and functionalities.\nInitial Wireframe Designs: Mockups of the user interface and user experience.\nDatabase Schema Diagram: Visual representation of the database structure.\n\n\n\n\nPhase 2: Backend Development (2 weeks)\n\nActivities:\n\nDevelop the FastAPI application to handle backend logic.\nCreate scripts for building and training machine learning models using libraries like scikit-learn or TensorFlow.\nImplement SQLAlchemy for database management, ensuring proper connections to the selected relational database (e.g., PostgreSQL or SQLite).\n\nDeliverables:\n\nFastAPI Application Code: Codebase for the backend with endpoints for model training, predictions, and CRUD operations.\nAPI Documentation: Auto-generated documentation using Swagger, including endpoint specifications.\nDatabase Migration Scripts: Scripts to set up the database schema and tables.\n\n\n\n\nPhase 3: Frontend Development (2 weeks)\n\nActivities:\n\nBuild the user interface using Streamlit, React, Vue.js, or Angular, ensuring it is intuitive and user-friendly.\nIntegrate the frontend with the FastAPI backend using Axios or Fetch API for data transmission.\nImplement data visualization components to present prediction results and insights.\n\nDeliverables:\n\nFrontend Codebase: Complete code for the user interface.\nUser Interface Designs: Documentation on UI components and their functionalities.\nAPI Integration Documentation: Guidelines on how the frontend interacts with the backend.\n\n\n\n\nPhase 4: Testing and Deployment (1 week)\n\nActivities:\n\nConduct thorough testing of the application for functionality, usability, and performance.\nContainerize both backend and frontend applications using Docker to simplify deployment.\nDeploy the applications to cloud platforms (e.g., AWS, Heroku, or Azure) and set up CI/CD pipelines using GitHub Actions or similar tools.\n\nDeliverables:\n\nTest Cases and Results: Documentation of testing strategies and results obtained.\nDockerfiles: Configuration files for containerizing both applications.\nDeployment Instructions: Comprehensive guidelines for deploying the application, including CI/CD pipeline configurations."
  },
  {
    "objectID": "02_Instructors/assessment_materials.html#assessment-criteria",
    "href": "02_Instructors/assessment_materials.html#assessment-criteria",
    "title": "üìë Instructors",
    "section": "Assessment Criteria",
    "text": "Assessment Criteria\n\nFunctionality (30%)\n\nDoes the application perform the required predictions accurately?\nAre all specified features implemented correctly?\n\nCode Quality (25%)\n\nIs the code well-structured, organized, and documented?\nAre best practices followed in both backend and frontend development?\n\nUser Experience (20%)\n\nIs the user interface intuitive, responsive, and aesthetically pleasing?\nAre the visualizations clear, meaningful, and useful for end-users?\n\nDeployment (15%)\n\nIs the application deployed successfully with proper accessibility and performance?\nAre CI/CD pipelines functioning correctly and efficiently?\n\nPresentation and Documentation (10%)\n\nIs the project documentation clear, comprehensive, and well-structured?\nDid the team effectively present their project and findings, demonstrating an understanding of the technologies used?"
  },
  {
    "objectID": "02_Instructors/assessment_materials.html#supporting-materials",
    "href": "02_Instructors/assessment_materials.html#supporting-materials",
    "title": "üìë Instructors",
    "section": "Supporting Materials",
    "text": "Supporting Materials\n\nDatasets:\n\nUCI Machine Learning Repository: Heart Disease Dataset\nKaggle: Diabetes Dataset\n\nFastAPI Documentation:\n\nFastAPI Official Documentation\n\nFrontend Framework Documentation:\n\nReact Documentation\nVue.js Documentation\nAngular Documentation\n\nDocker Documentation:\n\nDocker Official Documentation\n\nCI/CD Resources:\n\nGitHub Actions Documentation\n\n\nFeel free to adapt the timeline and assessment criteria to best fit your course structure and learning objectives!\nLet‚Äôs inspire the next generation of developers to innovate in healthcare technology!"
  },
  {
    "objectID": "02_Instructors/02_Lab_Solutions.html",
    "href": "02_Instructors/02_Lab_Solutions.html",
    "title": "Lab 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "",
    "text": "In this lab, guide your students through setting up their development environment and creating foundational API endpoints using FastAPI for managing clients and their marketing campaigns (or pharmaceutical trials).\nThese exercises are designed to build proficiency in constructing robust APIs for various industries. Encourage students to ask questions and explore as they progress through their coding journey.\nMay the code be with them! üåü ## Goals\nYou will help students achieve the following:\n\nAsynchronous Programming: Improve performance when handling multiple client requests by implementing asynchronous programming techniques.\nCRUD Routes: Create routes for managing clients and their marketing campaigns, allowing for full Create, Read, Update, and Delete operations.\nDatabase Integration: Integrate a database to store client and campaign information, ensuring reliable and structured data management.\nDependency Injection: Apply dependency injection to maintain modularity and facilitate easier testing and maintenance of the code.\nTesting with pytest: Write comprehensive tests using pytest to verify that client and campaign operations work as expected.\nClient Data Security: Secure sensitive client data by implementing authentication and authorization mechanisms.\nPerformance Optimization: Utilize performance optimization techniques to ensure the API remains efficient under high loads."
  },
  {
    "objectID": "02_Instructors/02_Lab_Solutions.html#overview",
    "href": "02_Instructors/02_Lab_Solutions.html#overview",
    "title": "Lab 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "",
    "text": "In this lab, guide your students through setting up their development environment and creating foundational API endpoints using FastAPI for managing clients and their marketing campaigns (or pharmaceutical trials).\nThese exercises are designed to build proficiency in constructing robust APIs for various industries. Encourage students to ask questions and explore as they progress through their coding journey.\nMay the code be with them! üåü ## Goals\nYou will help students achieve the following:\n\nAsynchronous Programming: Improve performance when handling multiple client requests by implementing asynchronous programming techniques.\nCRUD Routes: Create routes for managing clients and their marketing campaigns, allowing for full Create, Read, Update, and Delete operations.\nDatabase Integration: Integrate a database to store client and campaign information, ensuring reliable and structured data management.\nDependency Injection: Apply dependency injection to maintain modularity and facilitate easier testing and maintenance of the code.\nTesting with pytest: Write comprehensive tests using pytest to verify that client and campaign operations work as expected.\nClient Data Security: Secure sensitive client data by implementing authentication and authorization mechanisms.\nPerformance Optimization: Utilize performance optimization techniques to ensure the API remains efficient under high loads."
  },
  {
    "objectID": "02_Instructors/02_Lab_Solutions.html#marketing-agency-api",
    "href": "02_Instructors/02_Lab_Solutions.html#marketing-agency-api",
    "title": "Lab 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "Marketing Agency API",
    "text": "Marketing Agency API\nThe full project solution is available here"
  },
  {
    "objectID": "02_Instructors/02_Lab_Solutions.html#healthcare-management-api",
    "href": "02_Instructors/02_Lab_Solutions.html#healthcare-management-api",
    "title": "Lab 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "Healthcare Management API",
    "text": "Healthcare Management API\nThis project is optional and intended for students who feel comfortable taking on an additional challenge.\nThe full project solution folder will be available soon"
  },
  {
    "objectID": "01_Exercises/index.html",
    "href": "01_Exercises/index.html",
    "title": "üìë Exercises",
    "section": "",
    "text": "These labs are designed to give you practical experience, allowing you to apply your knowledge, experiment with code, and solve real-world problems.\n\nLab 1 üìù\nLab 2 üìù\nLab 3 üìù\n\nRoll up your sleeves, get coding, and most importantly‚Äîhave fun!",
    "crumbs": [
      "Exercices",
      "Notes"
    ]
  },
  {
    "objectID": "01_Exercises/02_Lab.html",
    "href": "01_Exercises/02_Lab.html",
    "title": "Lab 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "",
    "text": "In this notebook, you will create two distinct APIs, each tailored for different industries:\n\nMarketing Agency API: This API will help manage clients and their marketing campaigns for a fictional agency. You‚Äôll handle client requests, campaign management, performance tracking, and secure sensitive data. The API will be designed to scale, allowing you to efficiently manage multiple clients and campaigns simultaneously.\nHealthcare Management API: This API is designed to manage patient records, doctor schedules, medical appointments, and prescriptions. The project will emphasize integrating external APIs, handling real-time data, and ensuring compliance with healthcare regulations.\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nHealthcare Management API project is optional and intended for students who feel comfortable taking on an additional challenge",
    "crumbs": [
      "Exercices",
      "Lab 2"
    ]
  },
  {
    "objectID": "01_Exercises/02_Lab.html#overview",
    "href": "01_Exercises/02_Lab.html#overview",
    "title": "Lab 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "",
    "text": "In this notebook, you will create two distinct APIs, each tailored for different industries:\n\nMarketing Agency API: This API will help manage clients and their marketing campaigns for a fictional agency. You‚Äôll handle client requests, campaign management, performance tracking, and secure sensitive data. The API will be designed to scale, allowing you to efficiently manage multiple clients and campaigns simultaneously.\nHealthcare Management API: This API is designed to manage patient records, doctor schedules, medical appointments, and prescriptions. The project will emphasize integrating external APIs, handling real-time data, and ensuring compliance with healthcare regulations.\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nHealthcare Management API project is optional and intended for students who feel comfortable taking on an additional challenge",
    "crumbs": [
      "Exercices",
      "Lab 2"
    ]
  },
  {
    "objectID": "01_Exercises/02_Lab.html#goals",
    "href": "01_Exercises/02_Lab.html#goals",
    "title": "Lab 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "Goals",
    "text": "Goals\nBy the end of this lab, you should be able to:\n\nUse asynchronous programming to improve performance when handling multiple client requests.\nCreate CRUD routes to manage clients and their marketing campaigns.\nIntegrate a database to store client and campaign information.\nApply dependency injection to keep your code modular.\nWrite tests using pytest to verify that your client operations work as expected.\nSecure sensitive client data using authentication and authorization. (optional)\nUse performance optimization techniques to make your API efficient under high loads.(optional)",
    "crumbs": [
      "Exercices",
      "Lab 2"
    ]
  },
  {
    "objectID": "01_Exercises/02_Lab.html#prerequisites",
    "href": "01_Exercises/02_Lab.html#prerequisites",
    "title": "Lab 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "Prerequisites",
    "text": "Prerequisites\nEnsure you have FastAPI, SQLAlchemy (or SQLModel), Pydantic, and other necessary libraries installed. You‚Äôll also need access to Python and a terminal.",
    "crumbs": [
      "Exercices",
      "Lab 2"
    ]
  },
  {
    "objectID": "01_Exercises/02_Lab.html#marketing-agency-api",
    "href": "01_Exercises/02_Lab.html#marketing-agency-api",
    "title": "Lab 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "Marketing Agency API",
    "text": "Marketing Agency API\n\nKey Features\n\nClient Management:\n\nCreate, update, and delete client profiles.\nStore client-specific information such as contact details and preferences.\n\nCampaign Management:\n\nCreate and manage marketing campaigns for clients.\nTrack campaign performance metrics and budget allocations.\n\nDatabase Integration:\n\nUtilize SQLAlchemy for ORM and database management.\nSupport for SQLite with easy migration to other databases if needed.\n\nFake Data Generation: Populate the database with synthetic data for testing purposes using Faker.\nAPI Testing:\n\nComprehensive test suite using pytest to ensure reliability.\nTest coverage for all major CRUD operations and business logic.\n\n\n\n\nProject structure\nMARKETING\n‚îÇ\n‚îú‚îÄ‚îÄ .venv/\n‚îÇ\n‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îú‚îÄ‚îÄ test/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_unit.py\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îú‚îÄ‚îÄ campaign_routes.py\n‚îÇ   ‚îú‚îÄ‚îÄ client_routes.py\n‚îÇ   ‚îú‚îÄ‚îÄ database.py\n‚îÇ   ‚îú‚îÄ‚îÄ generate_fake_data.py\n‚îÇ   ‚îú‚îÄ‚îÄ main.py\n‚îÇ   ‚îú‚îÄ‚îÄ models.py\n‚îÇ   ‚îî‚îÄ‚îÄ schemas.py\n‚îÇ\n‚îú‚îÄ‚îÄ env/\n‚îÇ\n‚îú‚îÄ‚îÄ prod.db\n‚îÇ\n‚îî‚îÄ‚îÄ requirements.txt\n\n\nImplementation Steps\n\n1. app/__init__.py\nLeave this file empty or add package-level documentation.\n\n\n2. app/models.py\nDefine the database structure using SQLAlchemy models for Client and Campaign.\n\nImport Necessary Components:\n\nImport Column, Integer, String, ForeignKey, DateTime, JSON, relationship from SQLAlchemy.\nImport Base from your database setup file.\n\nDefine the Client Class:\n\nSet __tablename__ = \"clients\" to specify the table name.\nDefine columns:\n\nid: Primary key, integer, indexed.\nname: String, indexed.\nemail: Unique string, indexed.\n\nDefine a relationship with Campaign:\n\ncampaigns = relationship(\"Campaign\", back_populates=\"client\").\n\n\nDefine the Campaign Class:\n\nSet __tablename__ = \"campaigns\" to specify the table name.\nDefine columns:\n\nid: Primary key, integer, indexed.\ncampaign_name: String, indexed.\ndescription: String for campaign description.\nstart_date: DateTime for when the campaign starts.\nbudget: Integer for campaign budget.\nperformance_metrics: JSON for storing metrics.\ncanal: String\nclient_id: Foreign key referencing clients.id.\n\nDefine a relationship with Client:\n\nclient = relationship(\"Client\", back_populates=\"campaigns\").\n\n\n\n\n\n3. app/schemas.py\nCreate Pydantic models for validating request and response data.\n\nImport BaseModel:\n\nImport BaseModel from Pydantic.\n\nDefine ClientSchema:\n\nCreate a class ClientBase inheriting from BaseModel with fields:\n\nname: String.\nemail: String.\n\nCreate a class ClientCreate inheriting from ClientBase for creation-specific validation.\n\nDefine Client:\n\nCreate a class Client inheriting from ClientBase with an additional field:\n\nid: Integer.\n\nAdd Config class inside to enable ORM mode: orm_mode = True.\n\nDefine CampaignSchema:\n\nCreate a class CampaignBase inheriting from BaseModel with fields:\n\ncampaign_name: String.\ndescription: String.\nstart_date: DateTime.\nbudget: Integer.\nperformance_metrics: JSON.\ncanal: canal: List[Literal[‚Äòinternet‚Äô, ‚Äòtv‚Äô, ‚Äòradio‚Äô]].\n\nCreate a class CampaignCreate inheriting from CampaignBase for creation-specific validation.\n\nDefine Campaign:\n\nCreate a class Campaign inheriting from CampaignBase with additional fields:\n\nid: Integer.\nclient_id: Integer.\n\nAdd Config class inside to enable ORM mode: orm_mode = True.\n\n\n\n\n4. app/database.py\nSet up database configuration and connection.\n\nImport Necessary Components:\n\nImport create_engine, sessionmaker, and declarative_base from SQLAlchemy.\n\nConfigure Database:\n\nDefine the database URL using SQLite : DATABASE_URL = ‚Äúsqlite:///./prod.db‚Äù\nCreate a database engine and session local.\nDefine a Base class for model definitions.\n\n\n\n\n5. app/generate_fake_data.py\nPopulate the database with fake data for testing.\n\nInstall Faker:\n\nRun pip install faker.\n\nGenerate Data:\n\nImport Faker and create an instance.\nGenerate sample data for 10 clients and 20 campaigns (2 campaigns/client)\nInsert this data into the database using SQLAlchemy.\n\n\n\n\n6. app/campaign_routes.py\nDefine API routes for managing campaigns.\n\nImport Necessary Components:\n\nImport APIRouter from FastAPI.\n\nSet Up CRUD Operations:\n\nDefine routes for creating, reading, updating, and deleting campaigns.\nInclude additional routes for pausing and terminating campaigns.\nUse dependency injection to access the database session.\n\n\n\n\n7. app/client_routes.py\nDefine API routes for managing clients.\n\nImport Necessary Components:\n\nImport APIRouter from FastAPI.\n\nSet Up CRUD Operations:\n\nDefine routes for creating, reading, updating, and deleting clients.\nUse dependency injection to access the database session.\n\n\n\n\n8. app/main.py\nInitialize the FastAPI application, include routers, and define application startup and shutdown behavior.\n\nImport Required Modules:\n\n\nImport FastAPI from FastAPI.\nImport APIRouter from client_routes.py and campaign_routes.py.\nImport asynccontextmanager from contextlib for managing startup and shutdown tasks.\nImport generate_fake_data from generate_fake_data.py.\n\n\nInitialize FastAPI with a lifespan context manager:\n\napp = FastAPI(lifespan=lifespan)\n\nAdd the client and campaign routers to the FastAPI instance:\n\napp.include_router(client_router, prefix=\"/clients\", tags=[\"Clients\"])\napp.include_router(campaign_router, prefix=\"/campaigns\", tags=[\"Campaigns\"])\n\nUse the @asynccontextmanager decorator to define startup and shutdown logic:\n\n  @asynccontextmanager\n  async def lifespan(app: FastAPI):\n    # Startup logic\n    print(\"Generating fake data during startup...\")\n    generate_fake_data()  # Ensure this runs during startup\n      yield  # Pass control to the rest of the app\n    # Shutdown logic can be added here if needed\n\n\n10. app/test/test_unit.py\nTest the API endpoints for clients and campaigns to ensure they perform CRUD operations correctly.\n\nImport Required Modules:\n\nImport pytest for testing framework functionalities.\nImport TestClient from fastapi.testclient to simulate HTTP requests to the FastAPI app.\nImport create_engine and sessionmaker from sqlalchemy for database connections.\nImport SQLModel and Session from sqlmodel.\nImport StaticPool from sqlmodel.pool to manage SQLite in-memory database.\n\nImport Your App and Models:\n\nImport the FastAPI app from app.main.\nImport get_db, engine, and Base from app.database.\nImport Client and Campaign models from app.models.\n\nSet Up Test Database:\n\nCreate an in-memory SQLite database for testing:\ntest_engine = create_engine(\n    \"sqlite://\", connect_args={\"check_same_thread\": False}, poolclass=StaticPool\n)\nDefine a SessionLocal session factory bound to test_engine.\n\nCreate Database Tables:\n\nUse Base.metadata.create_all(bind=test_engine) to create tables.\n\nDefine Fixtures:\n\nSession Fixture:\n\nCreate a fresh database session for each test:\n@pytest.fixture(name=\"session\")\ndef session_fixture():\n    Base.metadata.create_all(bind=test_engine)\n    with Session(test_engine) as session:\n        yield session\n    Base.metadata.drop_all(bind=test_engine)  # Clean up after tests\n\nClient Fixture:\n\nOverride the default database session with the test session:\n@pytest.fixture(name=\"client\")\ndef client_fixture(session: Session):\n    def get_session_override():\n        return session\n\n    app.dependency_overrides[get_db] = get_session_override\n    client = TestClient(app)\n    yield client\n    app.dependency_overrides.clear()\n\n\nOne example : Test Create Client:\n\ndef test_create_client(client: TestClient):\n  response = client.post(\n    \"/clients/\", json={\"name\": \"Test Client\", \"email\": \"test1@example.com\"}\n    )\n  data = response.json()\n  assert response.status_code == 200\n  assert data[\"name\"] == \"Test Client\"\n  assert data[\"email\"] == \"test1@example.com\"\n  assert data[\"id\"] is not None\nDo the same for all clients endpoints\n\nRun pytest in the terminal from the project root to execute tests.\n\n\n\n11. requirements.txt\nUse pip freeze &gt; requirements.txt after installing packages.\n\n\n12. Go Further : Implement Security\nSecure the application by implementing authentication and authorization.\n\nExplore FastAPI Security:\n\nVisit the FastAPI security tutorial: FastAPI Security Documentation.\n\nImplement OAuth2 with Password (and hashing):\n\nUse fastapi.security to implement OAuth2 with password hashing.\nSet up a get_current_user dependency to secure routes.\nDefine a User model for managing users and credentials.\n\nAdd JWT Authentication:\n\nUse python-jose for JWT token management.\nSecure routes by requiring valid tokens for access.\n\nRole-Based Access Control (RBAC):\n\nImplement roles (e.g., admin, user) to control access to specific endpoints.\nUse role checks in your route dependencies.\n\nTest Security Features:\n\nWrite tests to ensure that unauthorized users cannot access protected endpoints.\nVerify that users with valid tokens have the correct permissions.",
    "crumbs": [
      "Exercices",
      "Lab 2"
    ]
  },
  {
    "objectID": "01_Exercises/02_Lab.html#healthcare-management-api",
    "href": "01_Exercises/02_Lab.html#healthcare-management-api",
    "title": "Lab 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "Healthcare Management API",
    "text": "Healthcare Management API\n\nKey Features\n\nPatient Management: Create and manage patient profiles, including medical history and contact information.\nDoctor Schedule: Organize and update doctor availability and appointments.\nAppointment Booking: Allow patients to book, update, or cancel appointments.\nPrescription Management: Track prescriptions, refills, and pharmacy interactions.\nSecure Data Handling: Implement role-based access control and data encryption for patient confidentiality.\nIntegration with External APIs: Connect with third-party services for additional functionalities like pharmacy networks or insurance verification.\nReal-Time Notifications: Implement WebSocket or similar technology for real-time updates on appointments and prescriptions.\n\n\n\nProject Structure\nHEALTHCARE\n‚îÇ\n‚îú‚îÄ‚îÄ .venv/\n‚îÇ\n‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/\n‚îÇ   ‚îú‚îÄ‚îÄ test/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_unit.py\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îú‚îÄ‚îÄ appointment_routes.py\n‚îÇ   ‚îú‚îÄ‚îÄ doctor_routes.py\n‚îÇ   ‚îú‚îÄ‚îÄ patient_routes.py\n‚îÇ   ‚îú‚îÄ‚îÄ prescription_routes.py\n‚îÇ   ‚îú‚îÄ‚îÄ database.py\n‚îÇ   ‚îú‚îÄ‚îÄ external_api.py\n‚îÇ   ‚îú‚îÄ‚îÄ main.py\n‚îÇ   ‚îú‚îÄ‚îÄ models.py\n‚îÇ   ‚îî‚îÄ‚îÄ schemas.py\n‚îÇ\n‚îú‚îÄ‚îÄ env/\n‚îÇ\n‚îú‚îÄ‚îÄ prod.db\n‚îÇ\n‚îî‚îÄ‚îÄ requirements.txt\n\n\nImplementation Steps\n\nSet Up Project Environment:\n\nCreate a virtual environment and install necessary packages (fastapi, uvicorn, sqlalchemy, pydantic, python-jose[cryptography], websockets).\n\nDesign Database Models:\n\nDefine models for Patient, Doctor, Appointment, and Prescription using SQLAlchemy.\n\n\nPatient Model\n\nid: Integer, primary key\nname: String, indexed\nage: Integer\ngender: String\nmedical_history: Text\n\nDoctor Model\n\nid: Integer, primary key\nname: String, indexed\nspecialty: String\ncontact_info: String\n\nAppointment Model\n\nid: Integer, primary key\nappointment_date: DateTime\npatient_id: Integer, ForeignKey\ndoctor_id: Integer, ForeignKey\nstatus: String\n\nPrescription Model\n\nid: Integer, primary key\nmedication_name: String\ndosage: String\npatient_id: Integer, ForeignKey\ndoctor_id: Integer, ForeignKey\ninstructions: Text\n\n\nCreate Pydantic Schemas:\n\nDesign schemas for data validation and serialization.\n\nImplement CRUD Operations:\n\nDevelop routes for managing patients, doctors, appointments, and prescriptions.\n\nSecure the API:\n\nImplement JWT authentication and role-based access control (RBAC).\n\nIntegrate External APIs:\n\nSet up connections to pharmacy networks, insurance companies, or other relevant services.\n\nReal-Time Data Handling:\n\nUse WebSocket for notifications about appointment changes or prescription updates.\n\nTesting:\n\nWrite unit and integration tests to ensure all functionalities work as expected.\n\nDocumentation:\n\nProvide comprehensive API documentation using FastAPI‚Äôs built-in tools.",
    "crumbs": [
      "Exercices",
      "Lab 2"
    ]
  },
  {
    "objectID": "00_Lectures/index.html",
    "href": "00_Lectures/index.html",
    "title": "üìö Lectures",
    "section": "",
    "text": "The full FastAPI course is now available for you to download.\n\n\n\nDownload the Full Course\n\n\n\nDive into the material and enhance your skills in building efficient APIs!",
    "crumbs": [
      "Lectures",
      "Notes"
    ]
  },
  {
    "objectID": "00_Lectures/index.html#great-news-students",
    "href": "00_Lectures/index.html#great-news-students",
    "title": "üìö Lectures",
    "section": "",
    "text": "The full FastAPI course is now available for you to download.\n\n\n\nDownload the Full Course\n\n\n\nDive into the material and enhance your skills in building efficient APIs!",
    "crumbs": [
      "Lectures",
      "Notes"
    ]
  },
  {
    "objectID": "00_Lectures/index.html#lecture-1---introduction-to-fastapi-development-setup",
    "href": "00_Lectures/index.html#lecture-1---introduction-to-fastapi-development-setup",
    "title": "üìö Lectures",
    "section": "Lecture 1 - Introduction to FastAPI & Development Setup",
    "text": "Lecture 1 - Introduction to FastAPI & Development Setup\nDive into the basics of APIs, explore the HTTP protocol, and learn how the Request/Response Cycle works.\nBy the end, you‚Äôll have a solid understanding of how APIs power modern applications and how FastAPI fits into the picture.\n\nResources\n\nLecture 1 üéì\nLive Coding Playlist 1 üé•\nAudio Overview 1 üîä",
    "crumbs": [
      "Lectures",
      "Notes"
    ]
  },
  {
    "objectID": "00_Lectures/index.html#lecture-2--building-scalable-and-efficient-fastapi-applications",
    "href": "00_Lectures/index.html#lecture-2--building-scalable-and-efficient-fastapi-applications",
    "title": "üìö Lectures",
    "section": "Lecture 2 -Building Scalable and Efficient FastAPI Applications",
    "text": "Lecture 2 -Building Scalable and Efficient FastAPI Applications\nUnlock the Key Features of FastAPI and discover the magic of Asynchronous Programming. We‚Äôll explore how FastAPI manages requests and connects seamlessly to databases‚Äîtaking your API development skills to the next level!\n\nResources\n\nLecture 2 üéì\nLive Coding Playlist 2 üé• (from 01:23:00 to the end)\nAudio Overview 2 üîä",
    "crumbs": [
      "Lectures",
      "Notes"
    ]
  },
  {
    "objectID": "00_Lectures/index.html#lecture-3---deployment-and-production-considerations",
    "href": "00_Lectures/index.html#lecture-3---deployment-and-production-considerations",
    "title": "üìö Lectures",
    "section": "Lecture 3 - Deployment and Production Considerations",
    "text": "Lecture 3 - Deployment and Production Considerations\nThis hands-on course takes you on an intergalactic journey through the process of deploying machine learning applications in a cloud environment using Docker and GitHub Actions on the Heroku platform. We‚Äôll cover the fundamental concepts, tools, and techniques needed to build a robust CI/CD pipeline for automated deployments.\n\nResources\n\nLecture 3 üéì\nLive Coding Playlist 3 üé•\nAudio Overview 3 üîä",
    "crumbs": [
      "Lectures",
      "Notes"
    ]
  },
  {
    "objectID": "00_Lectures/02_Lecture.html",
    "href": "00_Lectures/02_Lecture.html",
    "title": "Lecture 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "",
    "text": "If you‚Äôre short on time, you can listen to the key takeaways from the course in this audio summary:\n\n\n\nListen to the Audio Overview:\n\n\n\n Download audio\n\n\n\nIn this lecture, we cover key concepts to enhance your FastAPI development skills:\n\nAsynchronous Programming improves performance by handling multiple tasks simultaneously.\nRouting maps URLs to code, ensuring easy navigation within your API.\nDatabases are essential for efficient data storage and retrieval in your applications.\nDependency Injection promotes modularity, making code easier to maintain and test.\nTesting with tools like pytest ensures your application functions as expected.\nSecurity through authentication and authorization protects your API from unauthorized access.\nPerformance Optimization techniques, such as caching and async enhancements, ensure efficiency under heavy load.\n\n\nYour API is a bustling city.\nEach street represents a different route, leading to specific destinations (functions or data).\n\n\n\nAsynchronous programming is like having a fleet of delivery drones zipping around, handling multiple tasks at once. Databases are the city‚Äôs bustling warehouses, storing and retrieving valuable information.\nDependency Injection is like having a reliable supply chain. It ensures that the right components (dependencies) are always available where needed. Testing is your quality control department, making sure everything runs smoothly. Security is the vigilant police force, protecting your API from hackers and unauthorized access.\nPerformance optimization is about keeping the city running smoothly, even during peak hours. Techniques like caching and async enhancements are your traffic management tools, ensuring that everything flows efficiently.\n\nAre you ready to build your own API metropolis?\n\nLet‚Äôs get started!",
    "crumbs": [
      "Lectures",
      "2. Building Scalable and Efficient FastAPI Applications"
    ]
  },
  {
    "objectID": "00_Lectures/02_Lecture.html#tldr",
    "href": "00_Lectures/02_Lecture.html#tldr",
    "title": "Lecture 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "",
    "text": "If you‚Äôre short on time, you can listen to the key takeaways from the course in this audio summary:\n\n\n\nListen to the Audio Overview:\n\n\n\n Download audio\n\n\n\nIn this lecture, we cover key concepts to enhance your FastAPI development skills:\n\nAsynchronous Programming improves performance by handling multiple tasks simultaneously.\nRouting maps URLs to code, ensuring easy navigation within your API.\nDatabases are essential for efficient data storage and retrieval in your applications.\nDependency Injection promotes modularity, making code easier to maintain and test.\nTesting with tools like pytest ensures your application functions as expected.\nSecurity through authentication and authorization protects your API from unauthorized access.\nPerformance Optimization techniques, such as caching and async enhancements, ensure efficiency under heavy load.\n\n\nYour API is a bustling city.\nEach street represents a different route, leading to specific destinations (functions or data).\n\n\n\nAsynchronous programming is like having a fleet of delivery drones zipping around, handling multiple tasks at once. Databases are the city‚Äôs bustling warehouses, storing and retrieving valuable information.\nDependency Injection is like having a reliable supply chain. It ensures that the right components (dependencies) are always available where needed. Testing is your quality control department, making sure everything runs smoothly. Security is the vigilant police force, protecting your API from hackers and unauthorized access.\nPerformance optimization is about keeping the city running smoothly, even during peak hours. Techniques like caching and async enhancements are your traffic management tools, ensuring that everything flows efficiently.\n\nAre you ready to build your own API metropolis?\n\nLet‚Äôs get started!",
    "crumbs": [
      "Lectures",
      "2. Building Scalable and Efficient FastAPI Applications"
    ]
  },
  {
    "objectID": "00_Lectures/02_Lecture.html#the-magic-of-asynchronicity",
    "href": "00_Lectures/02_Lecture.html#the-magic-of-asynchronicity",
    "title": "Lecture 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "1. The Magic of Asynchronicity",
    "text": "1. The Magic of Asynchronicity\nAlright, let‚Äôs dive into the world of asynchronicity, where things happen‚Ä¶ but they don‚Äôt always wait around for you. Get ready for some tech magic!\n\n1.1. Synchronous vs.¬†Asynchronous Execution\nIn a synchronous world, you‚Äôre the chef cooking one dish at a time. You can‚Äôt start the next meal until the first is finished and delivered‚Äîslow, right?\n\n\n\nNow, welcome to the asynchronous kitchen!\nHere, while one dish is cooking (waiting on I/O*, like boiling water), you can start prepping the next one. FastAPI does this for your app‚Äîit doesn‚Äôt wait idly for the oven to preheat before taking on new tasks.\n\n\n\n\n\n\nNote: I/O\n\n\n\n\n\nI/O in computing stands for ‚ÄúInput/Output‚Äù. It refers to the communication between a computer system and the outside world, or between different components within a system. Here‚Äôs a brief overview:\nDefinition : I/O is the process of transferring data to or from a computer system.\nTypes\n\nHard I/O: Direct transfer of data between a computer and an external physical device (e.g., keyboard, mouse).\nSoft I/O: Data transfer between computers or servers over a network.\n\nCharacteristics\n\nBidirectional: Some devices can function as both input and output devices.\nPerspective-based: Whether a device is considered input or output can depend on the perspective.\n\nExamples\n\nInput devices: Keyboards, mice, scanners\nOutput devices: Monitors, printers, speakers\nI/O devices: Hard drives, network cards\n\nImportance : I/O operations are crucial for user interaction, data transfer, and system performance. Understanding I/O is essential for developers and system administrators for system design, performance optimization, and troubleshooting.\n\n\n\nHere‚Äôs the technical breakdown:\n\nSynchronous Execution is like cooking one meal from start to finish before even thinking about the next one. It‚Äôs linear‚Äîone task finishes, and only then does the next begin.\nAsynchronous Execution is like juggling multiple orders at once. While one task waits for something (say, file reading or a web request), the event loop jumps to the next task, keeping everything moving!\n\nEvent loop is the master chef in charge, making sure no task burns by hopping from one to another.\nAnd coroutines are those tasks‚Äîit‚Äôs like each dish being prepped. They tell the event loop,\n\nI‚Äôm gonna be busy for a while, feel free to go check on the others.\n\nThe benefit? FastAPI can handle a huge number of requests quickly, without getting bogged down in waiting, making your app zippy and responsive, even when under heavy load.\n\n\n1.2. Implementing Asynchronous Endpoints\nOkay, let‚Äôs jump into FastAPI‚Äôs version of cooking up some asynchronous magic.\nTo make a route asynchronous, we use the keywords async and await‚Äîthey‚Äôre like the VIP passes to FastAPI‚Äôs asynchronous event.\n\nasync: This tells Python that a function might take a while to complete, and it‚Äôs cool to check out other functions while waiting.\nawait: It‚Äôs like a signal flare. It tells the event loop, ‚ÄúHey, I‚Äôm waiting for this task to finish, but you don‚Äôt need to hang around! Come back later.‚Äù\n\nHere‚Äôs a sample:\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/async-dish\")\nasync def cook_something():\n    await prep_ingredients()  # Might take time\n    await bake_dish()  # Another wait here\n    return {\"status\": \"Dish ready!\"}\nSee how we use await to tell the event loop to handle other things while it waits for the cooking functions to finish?\n\nThat‚Äôs the magic sauce!\n\nLet‚Äôs whip up more examples to help you better understand how to use async and await in FastAPI!\nThese will showcase different ways you can handle async operations in routes.\n\nSimulating Multiple Async Operations in Parallel\n\nLet‚Äôs say you‚Äôre preparing different parts of a meal simultaneously. While the oven is baking the dish, you‚Äôre also mixing the salad, and getting drinks ready.\nfrom fastapi import FastAPI\nimport asyncio  # For running tasks concurrently\n\napp = FastAPI()\n\nasync def bake_dish():\n    await asyncio.sleep(3)  # Simulate baking time\n    return \"Dish baked\"\n\nasync def prepare_salad():\n    await asyncio.sleep(1)  # Simulate chopping veggies\n    return \"Salad ready\"\n\nasync def get_drinks():\n    await asyncio.sleep(2)  # Simulate fetching drinks\n    return \"Drinks ready\"\n\n@app.get(\"/prepare-meal\")\nasync def prepare_meal():\n    # Run all tasks at the same time using asyncio.gather\n    dish, salad, drinks = await asyncio.gather(\n        bake_dish(),\n        prepare_salad(),\n        get_drinks()\n    )\n    return {\"status\": f\"{dish}, {salad}, {drinks}!\"}\nüî• Explanation: In this example, instead of waiting for each task (baking, salad prep, drinks) to finish one by one, we‚Äôre using asyncio.gather() to run all of them in parallel. The event loop jumps between these tasks while they‚Äôre waiting for something, maximizing efficiency.\n\nUsing Async with External API Calls\n\nNow, you‚Äôre pulling recipe data from a remote service. You don‚Äôt want your server to stop everything and wait while it fetches the data, so we make that operation asynchronous.\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/fetch-recipe\")\nasync def fetch_recipe():\n    async with httpx.AsyncClient() as client:\n        response = await client.get('https://recipe-api.com/special-dish')\n        data = response.json()\n    return {\"recipe\": data}\nüî• Explanation: With httpx.AsyncClient(), we‚Äôre making the API call non-blocking. While the app waits for the recipe service to respond, the event loop is free to handle other requests. This is essential when working with third-party services to prevent your application from getting ‚Äústuck‚Äù waiting.\n\nAsynchronous File Reading\n\nYou can read files asynchronously so other requests don‚Äôt have to wait in line while your server is reading a large file.\nimport aiofiles  # Async library for file I/O\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/read-steps\")\nasync def read_steps():\n    async with aiofiles.open('recipe.txt', mode='r') as file:\n        content = await file.read()\n    return {\"recipe_steps\": content}\nüî• Explanation: Here, we‚Äôre using aiofiles to open and read a file asynchronously. This allows FastAPI to handle other requests while reading the file in the background.\n\nDelayed Responses: Simulating Long Operations\n\nSuppose you have a task that simulates a long operation, like slow cooking. You don‚Äôt want your app to freeze while waiting for the slow cook to finish, so you implement it asynchronously.\nfrom fastapi import FastAPI\nimport asyncio  # For simulating a delay\n\napp = FastAPI()\n\n@app.get(\"/slow-cook\")\nasync def slow_cook():\n    await asyncio.sleep(5)  # Simulate a long task (e.g., slow cooking)\n    return {\"status\": \"Slow-cooked meal is ready!\"}\nüî• Explanation: In this case, the asyncio.sleep(5) simulates a task that takes time (like slow cooking). While this is happening, FastAPI doesn‚Äôt sit idle‚Äîit can handle other requests while the slow-cooked meal finishes. üê¢üî•üç≤\n\nAsynchronous Error Handling in Tasks\n\nWhat if something goes wrong during one of your asynchronous tasks? For example, you‚Äôre preparing a cake but the oven breaks down midway. Let‚Äôs handle that gracefully using async and try-except.\nfrom fastapi import FastAPI\nimport asyncio\n\napp = FastAPI()\n\nasync def bake_cake():\n    await asyncio.sleep(2)\n    raise Exception(\"Oven malfunctioned!\")  # Something went wrong\n\n@app.get(\"/bake-cake\")\nasync def prepare_cake():\n    try:\n        await bake_cake()\n        return {\"status\": \"Cake baked successfully!\"}\n    except Exception as e:\n        return {\"error\": f\"Oops! {e}\"}\nüî• Explanation: In this example, the oven ‚Äúmalfunctions‚Äù during the cake-baking process. The try-except block catches the error, allowing us to return a helpful message instead of crashing the app. This is like having a backup plan in case your cake flops.\n\nHandling CPU-bound Tasks with Async + Background Tasks\n\nWhile asynchronous tasks are great for I/O-bound operations (like waiting on APIs or files), CPU-bound operations (like heavy computations) can block the event loop. To avoid this, we can offload such tasks to background workers.\nfrom fastapi import FastAPI, BackgroundTasks\nimport time  # Simulate CPU-bound task\n\napp = FastAPI()\n\ndef heavy_computation():\n    time.sleep(10)  # Simulate a long-running computation\n    print(\"Computation done!\")\n\n@app.get(\"/start-computation\")\nasync def start_computation(background_tasks: BackgroundTasks):\n    background_tasks.add_task(heavy_computation)\n    return {\"status\": \"Computation started in the background!\"}\nüî• Explanation: Here, BackgroundTasks allows us to offload the heavy computation (CPU-bound) to a background task so it doesn‚Äôt block the event loop. This way, FastAPI can continue processing other requests without waiting for the long-running computation to finish.\nBy using async and await correctly, you make your FastAPI apps super efficient, like a pro chef in a fast-paced kitchen, always juggling tasks without missing a beat!\n\n\n1.3. Best Practices for Asynchronous Programming\nWhen it comes to asynchronous programming, it‚Äôs not just about sprinkling async and await everywhere. There‚Äôs a bit of finesse to it‚Äîjust like any good recipe.\n\nKnow when to go async:\n\n\nUse async for I/O-bound tasks: things that need to wait for something external, like network requests or reading files.\nDon‚Äôt go async for CPU-bound tasks (heavy number crunching), because while your function is churning away, you‚Äôre not gaining any advantage from async‚Äôs multitasking magic.\n\n\nError handling in asynchronous functions\n\nThink of error handling as catching a wayward dish before it hits the ground. In asynchronous code, make sure to wrap tasks in try-except blocks, so your event loop doesn‚Äôt trip over unhandled exceptions.\n\n\n\nHere‚Äôs how to handle errors asynchronously:\nasync def serve_dish():\n    try:\n        await bake_cake()\n    except OvenFailureException:\n        return {\"status\": \"Oven exploded! Call for help!\"}\n\nSimple try-except in an Asynchronous Function\n\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/get-recipe\")\nasync def get_recipe():\n    try:\n        response = await httpx.get(\"https://random-recipes.com/cake\")\n        response.raise_for_status()  # Raise an error if the request failed\n        return {\"recipe\": response.json()}\n    except httpx.HTTPStatusError as e:\n        return {\"error\": f\"Recipe not available! Error: {e}\"}\n    except Exception as e:\n        return {\"error\": f\"Unexpected error occurred: {e}\"}\nüî• Explanation: Here, we‚Äôre using httpx to make an asynchronous HTTP request. If the recipe website is down or returns an error, the HTTPStatusError exception will trigger, and we handle it smoothly without crashing the app.\n\nHandling Multiple Exceptions\n\nSometimes, different errors need different solutions. Let‚Äôs say your app reads data from a file and makes an HTTP request, both of which can fail in different ways.\nimport aiofiles  # Asynchronous file handling\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/read-data\")\nasync def read_data():\n    try:\n        # Try reading from a file asynchronously\n        async with aiofiles.open(\"data.txt\", mode=\"r\") as file:\n            contents = await file.read()\n        \n        # Then, make a web request for additional info\n        response = await httpx.get(\"https://api.example.com/data\")\n        response.raise_for_status()\n\n        return {\"file_data\": contents, \"api_data\": response.json()}\n\n    except FileNotFoundError:\n        return {\"error\": \"File not found. Please check the file path.\"}\n    except httpx.RequestError as e:\n        return {\"error\": f\"Failed to reach API: {e}\"}\n    except Exception as e:\n        return {\"error\": f\"An unexpected error occurred: {e}\"}\nüî• Explanation: - FileNotFoundError: Happens if the file doesn‚Äôt exist. We handle this separately with a user-friendly message. - httpx.RequestError: Happens if the API request fails (e.g., bad connection). We give a clear message indicating the API issue.\n\nRetry Mechanism with try-except\n\nLet‚Äôs say you‚Äôre dealing with flaky internet, and you want to retry a failed task a couple of times before giving up. You can create a loop with retries inside your try-except block.\nimport httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/retry-request\")\nasync def retry_request():\n    retries = 3\n    for attempt in range(retries):\n        try:\n            response = await httpx.get(\"https://api.slow-server.com/data\")\n            response.raise_for_status()\n            return {\"data\": response.json()}\n        except httpx.RequestError as e:\n            if attempt &lt; retries - 1:  # Only retry if we haven't exhausted attempts\n                continue\n            return {\"error\": f\"Failed after {retries} attempts. Error: {e}\"}\nüî• Explanation: Here, the try-except block runs in a loop. If the request fails, the function will retry up to 3 times before giving up and returning an error.\n\nChaining async Calls with try-except\n\nLet‚Äôs say you need to perform several asynchronous tasks, and you want to catch errors at different points.\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nasync def get_ingredients():\n    # Simulating an asynchronous function\n    return {\"flour\": 1, \"sugar\": 2, \"eggs\": 3}\n\nasync def prepare_dough(ingredients):\n    if \"eggs\" not in ingredients:\n        raise ValueError(\"Missing eggs!\")\n    # Pretend we're making dough\n    return \"dough prepared\"\n\n@app.get(\"/make-cake\")\nasync def make_cake():\n    try:\n        ingredients = await get_ingredients()\n        dough = await prepare_dough(ingredients)\n        return {\"status\": f\"{dough}, ready for baking!\"}\n    \n    except ValueError as e:\n        return {\"error\": f\"Invalid ingredients: {e}\"}\n    except Exception as e:\n        return {\"error\": f\"An unexpected error occurred: {e}\"}\nüî• Explanation: - We first get ingredients asynchronously. - Then we prepare the dough asynchronously. - If there‚Äôs an issue (e.g., missing ingredients), we raise a ValueError and catch it, returning a helpful error message.\n\nNested try-except for More Granular Control\n\nLet‚Äôs get more advanced. Sometimes, you need different try-except blocks for different stages of your async workflow.\nfrom fastapi import FastAPI\nimport aiofiles\n\napp = FastAPI()\n\n@app.get(\"/complex-process\")\nasync def complex_process():\n    try:\n        # Stage 1: File read\n        try:\n            async with aiofiles.open(\"input.txt\", mode=\"r\") as file:\n                contents = await file.read()\n        except FileNotFoundError:\n            return {\"error\": \"Input file missing!\"}\n        \n        # Stage 2: Process data\n        try:\n            # Fake processing step\n            if not contents:\n                raise ValueError(\"File is empty!\")\n            processed_data = contents.upper()\n        except ValueError as e:\n            return {\"error\": f\"Data processing failed: {e}\"}\n\n        # Stage 3: Return response\n        return {\"processed_data\": processed_data}\n\n    except Exception as e:\n        return {\"error\": f\"An unexpected error occurred: {e}\"}\nüî• Explanation\nHere, we have different try-except blocks:\n\nFile reading (handles file errors separately).\nData processing (checks content validity).\nA final catch-all to handle anything unexpected.\n\nThis allows us to give very specific error messages, depending on where things go wrong.\nIn the world of FastAPI, asynchronicity is like having an army of chefs helping you cook multiple meals at once. You save time, resources, and keep things running smoothly.\nJust remember:\n\nuse async when it makes sense, manage your I/O carefully, and make sure you‚Äôve got error-handling oven mitts at the ready!",
    "crumbs": [
      "Lectures",
      "2. Building Scalable and Efficient FastAPI Applications"
    ]
  },
  {
    "objectID": "00_Lectures/02_Lecture.html#advanced-routing-the-map-of-your-fastapi-world",
    "href": "00_Lectures/02_Lecture.html#advanced-routing-the-map-of-your-fastapi-world",
    "title": "Lecture 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "2. Advanced Routing: The Map of Your FastAPI World",
    "text": "2. Advanced Routing: The Map of Your FastAPI World\nRouting is the backbone of FastAPI‚Äîlike a GPS guiding every request to its destination.\nIn this part, we‚Äôll dive into routers, parameters, and middleware to organize and streamline your FastAPI applications.\nGet ready for a journey through the ‚Äúhighways‚Äù of FastAPI! üöóüí®\n\n2.1. Introduction to Routers\nLet‚Äôs start by breaking down routers.\nThink of them as different sections of a city: each router is responsible for handling related endpoints, like the ‚Äúshopping district‚Äù or ‚Äúresidential zone‚Äù of your app.\nIn a simple project, you might only need a single main.py to handle all routes. But as your app grows, it becomes necessary to group routes logically‚Äîby features or services. FastAPI provides APIRouter to help you do just that.\nHere‚Äôs a basic example:\nfrom fastapi import FastAPI, APIRouter\n\napp = FastAPI()\n\n# Create a new router for user-related routes\nuser_router = APIRouter()\n\n@user_router.get(\"/users/\")\nasync def get_users():\n    return {\"users\": [\"M√©nyssa\", \"Eric\", \"Paul\"]}\n\n@user_router.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    return {\"user\": user_id}\n\n# Include the user_router in the main FastAPI app\napp.include_router(user_router)\nCurrent Project Structure\nRight now, you have a very simple project structure:\n‚îú‚îÄ‚îÄ env/\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ requirements.txt\nLet‚Äôs refactor it to make use of routers. Create a folder to hold all your route files:\n‚îú‚îÄ‚îÄ env/\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ routers/         # New folder to store routers\n‚îÇ   ‚îî‚îÄ‚îÄ users.py     # New file for user-related routes\n‚îú‚îÄ‚îÄ requirements.txt\nInside users.py:\nfrom fastapi import APIRouter\n\nuser_router = APIRouter()\n\n@user_router.get(\"/users/\")\nasync def get_users():\n    return {\"users\": [\"Alice\", \"Bob\", \"Charlie\"]}\n\n@user_router.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    return {\"user\": user_id}\nThen, include this router in main.py:\nfrom fastapi import FastAPI\nfrom routers.users import user_router\n\napp = FastAPI()\n\napp.include_router(user_router)\nNow you‚Äôve separated concerns and logically grouped your endpoints. This makes your app easier to scale and maintain!\nOrganizing Endpoints into Logical Groups\nYou can create more routers for different areas of your app, like products.py for managing a product catalog or orders.py for processing orders. This modular approach keeps things clean, especially as the number of endpoints grows.\n‚îú‚îÄ‚îÄ env/\n‚îú‚îÄ‚îÄ main.py\n‚îú‚îÄ‚îÄ routers/\n‚îÇ   ‚îú‚îÄ‚îÄ users.py\n‚îÇ   ‚îú‚îÄ‚îÄ products.py\n‚îÇ   ‚îî‚îÄ‚îÄ orders.py\n‚îú‚îÄ‚îÄ requirements.txt\nEach router becomes a dedicated zone of your app, handling its own logic. This modularity is a huge win for maintainability and scalability.\n\n\n2.2. Path Parameters and Query Parameters\nParameters allow users to send extra information with requests, making them more flexible and dynamic. See also Lecture 1\nPath Parameters\nPath parameters are part of the URL. They let you capture dynamic parts of a route. For example, if you have /users/{user_id}, {user_id} is a path parameter.\n@user_router.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    return {\"user\": user_id}\nüî• Explanation: Here, user_id is extracted from the URL and passed as an argument to the handler function.\nQuery Parameters\nQuery parameters are key-value pairs that follow a ? in the URL. They‚Äôre usually used to filter or sort data.\nFor example, if you have /users?name=Paul, name is a query parameter:\n@user_router.get(\"/users/\")\nasync def get_users(name: str = None):\n    if name:\n        return {\"filtered_user\": name}\n    return {\"users\": [\"M√©nyssa\", \"Eric\", \"Paul\"]}\nüî• Explanation: Here, name is a query parameter that filters the list of users. If no name is provided, it returns the full list.\nValidating Parameters with Dependency Injection\nFastAPI‚Äôs dependency injection system allows you to validate parameters before they reach the route handler. For example, you can use Pydantic models to validate query parameters:\nfrom pydantic import BaseModel\n\nclass UserQueryParams(BaseModel):\n    name: str\n    age: int\n\n@user_router.get(\"/search/\")\nasync def search_users(params: UserQueryParams):\n    return {\"name\": params.name, \"age\": params.age}\nWith dependency injection, FastAPI will automatically validate the query parameters based on the UserQueryParams schema.\n\n\n2.3. Custom Routers and Middleware\nLet‚Äôs now explore how to extend routers and add middleware to handle more advanced use cases.\nCreating Custom Routers for Specific Use Cases\nYou can create custom routers for specific sections of your app, each with its own set of routes and logic.\nFor instance, let‚Äôs create an admin router with custom logic:\nfrom fastapi import APIRouter\n\nadmin_router = APIRouter()\n\n@admin_router.get(\"/admin/reports\")\nasync def get_admin_reports():\n    return {\"report\": \"Admin report data\"}\nüî• Explanation: This custom router can be used to separate admin functionality from general user functionality. It helps ensure the right people access the right routes.\nImplementing Middleware for Cross-Cutting Concerns\nMiddleware is code that runs before or after each request. It‚Äôs great for logging, authentication, and other cross-cutting concerns.\nHere‚Äôs an example of middleware that logs the time taken for each request:\nfrom fastapi import FastAPI\nimport time\n\napp = FastAPI()\n\n@app.middleware(\"http\")\nasync def log_requests(request, call_next):\n    start_time = time.time()\n    response = await call_next(request)\n    duration = time.time() - start_time\n    print(f\"Request: {request.url}, Duration: {duration}s\")\n    return response\nüî• Explanation: With this middleware, every request gets timed and logged. Middleware is powerful because it can intercept every request and response, applying logic that affects the entire app.\nBonus: Custom Error Handling with Middleware You can even use middleware for custom error handling. For example, you might want to catch all exceptions and return a custom error message:\n@app.middleware(\"http\")\nasync def custom_error_handling(request, call_next):\n    try:\n        return await call_next(request)\n    except Exception as e:\n        return JSONResponse(status_code=500, content={\"error\": str(e)})\nüî• Explanation: This middleware catches any unhandled exceptions and returns a consistent error response to the client.\nBy organizing your FastAPI app into logical pieces and implementing advanced routing techniques, you‚Äôll keep your code clean and scalable‚Äîlike a well-mapped city!",
    "crumbs": [
      "Lectures",
      "2. Building Scalable and Efficient FastAPI Applications"
    ]
  },
  {
    "objectID": "00_Lectures/02_Lecture.html#database-dynamo-powering-your-app",
    "href": "00_Lectures/02_Lecture.html#database-dynamo-powering-your-app",
    "title": "Lecture 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "3. Database Dynamo: Powering Your App",
    "text": "3. Database Dynamo: Powering Your App\nThis is the heart of most web applications : The database.\nIt‚Äôs the powerful engine that drives the storage and retrieval of your data, and in this section, we‚Äôll explore how to set up, manage, and interact with databases in FastAPI.\n\n3.1. Choosing the Right Database\nChoosing the right database is like choosing the right vehicle for a road trip:\n\nDo you want a rugged SUV (NoSQL) or a precision-engineered sports car (SQL)?\n\nIt all depends on the type of data, how it‚Äôs structured, and what you need in terms of performance.\nSQL vs.¬†NoSQL Databases\n\nSQL: Think of SQL databases like Excel sheets‚Äîthey‚Äôre great for structured data with clear relationships. You can run complex queries across multiple tables, and they‚Äôre backed by solid ACID compliance (Atomicity, Consistency, Isolation, Durability). Common options include PostgreSQL, MySQL, and SQLite.\n\n‚û°Ô∏è Use case: Banking systems, e-commerce platforms where data integrity and relationships matter.\n\nNoSQL: NoSQL databases, on the other hand, are more like dynamic, flexible containers. They can handle semi-structured or unstructured data like JSON documents. They scale horizontally, which means they work great with massive datasets.\n\n‚û°Ô∏è Use case: Social networks, real-time applications, or scenarios where data structure is constantly changing (e.g., MongoDB, Cassandra).\nPopular Databases for FastAPI\nWhen it comes to FastAPI, the database world is your oyster. Here are some great options:\n\nPostgreSQL: The SQL superstar! It‚Äôs powerful, open-source, and works smoothly with FastAPI. Great for complex queries, relational data, and transactional applications.\nMongoDB: NoSQL king! Ideal for flexible, large-scale applications where the structure isn‚Äôt rigid. Use it if you‚Äôre dealing with JSON-like data or want to easily scale horizontally.\nSQLite: Lightweight and portable SQL option. Best for smaller applications or quick prototypes. It‚Äôs built into Python, so no additional setup required.\n\nAnalogy Time:\n\nSQL databases are like libraries, neatly organized with sections, rows, and books that reference other books (relational).\nNoSQL databases are like a garage sale where things might not be perfectly organized, but you can grab what you need quickly (flexibility).\n\n\n\n3.2. SQLAlchemy and SQLModel\nFastAPI makes working with databases easy, thanks to SQLAlchemy and SQLModel.\nLet‚Äôs break them down and see how they power up your database interactions.\n\n3.2.1. Using SQLAlchemy for Database Interactions\nSQLAlchemy is one of the most powerful and flexible libraries for working with relational databases in Python. It gives you fine-grained control over every aspect of database interaction.\n\n\n\nIt‚Äôs an ORM* (Object Relational Mapper) that lets you work with databases in a Pythonic way‚Äîno more raw SQL queries unless you want to.\n\n\n\n\n\n\nNote: ORM\n\n\n\n\n\nORM stands for Object-Relational Mapper. It‚Äôs a programming technique that bridges the gap between object-oriented programming (OOP) and relational databases.\nIn simpler terms, an ORM allows you to interact with database tables as if they were objects in your programming language. This means you can use familiar OOP concepts like classes, objects, and methods to create, read, update, and delete data in your database.\nHere‚Äôs how it works:\n\nMapping: The ORM defines a mapping between your object classes and database tables. This mapping specifies how properties of your objects correspond to columns in the database table.\nData Access: You can use your object‚Äôs methods to perform database operations. For example, to save an object, you might call a save() method. The ORM will automatically translate this into the appropriate SQL query to insert data into the database.\nData Retrieval: To retrieve data from the database, you can query for objects based on certain criteria. The ORM will translate your query into SQL and return the results as objects.\n\nBenefits of using ORMs:\n\nSimplified development: ORMs can significantly reduce the amount of boilerplate code needed to interact with databases.\nImproved productivity: By using familiar OOP concepts, developers can work more efficiently and make fewer errors.\nPortability: ORMs can often be used with different databases, making it easier to switch between systems.\nAbstraction: ORMs provide a layer of abstraction between your application and the database, making your code more maintainable and easier to test.\n\nPopular ORMs include:\n\nSQLAlchemy for Python\nHibernate for Java\nEntity Framework for .NET\nActiveRecord for Ruby\n\nBy using an ORM, you can focus on building your application‚Äôs logic without having to worry about the intricacies of SQL and database interactions.\n\n\n\nLet‚Äôs break this down step by step to make it super clear. We‚Äôll start with the basics of creating a table and then move into interacting with that table using SQLAlchemy.\n1. Define a SQLAlchemy Model (Table Representation)\nIn a database, a table stores data in rows and columns. In SQLAlchemy, we create a model that acts like a blueprint for a database table.\nWhat‚Äôs happening in the code:\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\ncreate_engine: Think of this as your connection to the database. In this example, we‚Äôre using SQLite, which is a lightweight, file-based SQL database (though this could be PostgreSQL, MySQL, etc.). The engine is the bridge between SQLAlchemy and the actual database.\ndeclarative_base: This is the starting point for any model in SQLAlchemy. We use it to define tables. The Base class lets SQLAlchemy know which classes (tables) should be mapped to the database.\nsessionmaker: This is a factory for creating sessions, which are used to talk to the database (we‚Äôll get to sessions later).\n\n# Connect to a SQLite database (or PostgreSQL)\nengine = create_engine(\"sqlite:///mydb.db\")\nBase = declarative_base()\n\nengine = create_engine(\"sqlite:///mydb.db\"): This line creates the connection to the SQLite database, which is stored in a file called mydb.db. If you were using PostgreSQL, the string would look something like this:\nengine = create_engine(\"postgresql://username:password@localhost/dbname\")\nBase = declarative_base(): This creates the base class Base, which we‚Äôll use to define all our tables (models) in the future.\n\n2. Defining the User Table\nNow, let‚Äôs create the User table:\n# Define a model representing a table\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True)\nüî• Explanation:\n\nclass User(Base) defines a class User that inherits from Base. Each class in SQLAlchemy is mapped to a table in the database, so this class is our blueprint for the users table.\n__tablename__ = \"users\" sets the table name to \"users\". Whenever we query or modify data, this table name is used in the background.\n\nInside this class, we define columns, which are the fields in our table: - id = Column(Integer, primary_key=True, index=True) creates an id column in the table, which is an integer, the primary key (unique for each row), and indexed for fast lookups. - name = Column(String, index=True) creates a name column that stores strings (text) and is also indexed.\n3. Create the Table in the Database\nNow that we‚Äôve defined our User model, we need to actually create the table in the database:\n# Create the table in the database\nBase.metadata.create_all(bind=engine)\nüî• Explanation: Base.metadata.create_all(bind=engine) tells SQLAlchemy to take all the models we‚Äôve defined (in this case, the User model) and create the corresponding tables in the database connected to engine. This will create the users table in mydb.db.\n4.Interacting with the Database (CRUD Operations)\nOnce our table is created, we can start performing CRUD operations (Create, Read, Update, Delete) to interact with our data.\nTo communicate with the database, we need a session. A session is like a temporary workspace where we can make changes to the database, and once we‚Äôre done, we can commit (save) those changes.\n# Create a session to interact with the database\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nüî• Explanation: Here, we define SessionLocal, a session factory that will let us create sessions when we need them.\n5. Adding Data to the Database\nLet‚Äôs use this session to add a new user to the users table:\n# Create a session and add a new user\ndb = SessionLocal()\nnew_user = User(name=\"M√©nyssa\")\ndb.add(new_user)\ndb.commit()\ndb.close()\nüî• Explanation:\n\ndb = SessionLocal()create a new session using SessionLocal(). This session allows us to interact with the database.\nnew_user = User(name=\"M√©nyssa\") create a new instance of the User model. In this case, we‚Äôre adding a user with the name M√©nyssa. The id column will be automatically generated because it‚Äôs a primary key.\ndb.add(new_user) add this new user to our session (this step only adds it to the session, not the database yet).\ndb.commit() saves (commits) the changes to the database. The new user is now stored in the users table.\ndb.close() close the session to free up resources.\n\nSummary of CRUD Operations\n\nDefine a SQLAlchemy Model (This represents a table in your database):\n\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\n# Connect to a SQLite database (or PostgreSQL)\nengine = create_engine(\"sqlite:///mydb.db\")\nBase = declarative_base()\n\n# Define a model representing a table\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True)\n\n# Create the table in the database\nBase.metadata.create_all(bind=engine)\n\n# Create a session to interact with the database\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nInteracting with the Database: Now that we‚Äôve created a table, let‚Äôs add some users:\n\n# Create a session and add a new user\ndb = SessionLocal()\nnew_user = User(name=\"Pierre\")\ndb.add(new_user)\ndb.commit()\ndb.close()\nSQLAlchemy simplifies database interactions by letting you work with Python objects rather than raw SQL queries, making it easier to manage your app‚Äôs data.\n\n\n3.2.2. SQLModel: The Best of Both Worlds (SQLAlchemy + Pydantic)\nWhile SQLAlchemy is powerful, SQLModel takes things a step further by combining the simplicity of Pydantic (for data validation) and the power of SQLAlchemy.\nSQLModel is built on top of SQLAlchemy but introduces Pydantic-style validation. It takes the best parts of both worlds: - The powerful ORM capabilities of SQLAlchemy - The data validation magic of Pydantic\n\nSo, what does this mean? You get to use SQLAlchemy‚Äôs robust features while reducing the boilerplate code, and you get automatic data validation.\n\n1. Key Differences with SQLAlchemy:\n\nData Validation Built-In: SQLModel integrates Pydantic‚Äôs data validation. This means that every time you define a model, it automatically validates the data for you.\nLess Boilerplate: SQLModel cuts down on repetitive code. You don‚Äôt need to define columns manually like in SQLAlchemy; you can use Python‚Äôs type hints, making your code cleaner and easier to maintain.\nDeclarative Syntax: You define your models in a more Pythonic way, without needing to write repetitive column definitions.\nPydantic + SQLAlchemy Integration: SQLModel works seamlessly with FastAPI, because FastAPI is already built on Pydantic for data validation.\n\n2. SQLModel Example Breakdown\nfrom sqlmodel import SQLModel, Field, create_engine\n\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\nüî• Explanation:\n\nSQLModel is the base class for all your models. It inherits from both Pydantic and SQLAlchemy, so it does the heavy lifting for you.\ntable=True tells SQLModel to treat this class as a database table. Without it, the class would just be a data model for validation purposes.\nFields:\n\nid: int = Field(default=None, primary_key=True): Instead of defining the column type manually (like in SQLAlchemy), we use type hints (int for id and str for name) and the Field function from Pydantic for additional options like primary_key=True.\nname: str: This defines a simple name column with a string type.\n\n\nAlready, this feels cleaner and more Pythonic.\nHere‚Äôs a full script using SQLModel to create a SQLite database, define a User model, and perform basic CRUD operations.\nThis will give you a complete picture of how SQLModel works in practice:\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom sqlmodel import SQLModel, Field, create_engine, Session, select\nimport uvicorn  # Import uvicorn to run the application\n\napp = FastAPI()\n\n# 1. Define the User model using SQLModel\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n\n# 2. Create the SQLite database engine\nDATABASE_URL = \"sqlite:///./mydb.db\"\nengine = create_engine(DATABASE_URL, echo=True)\n\n# 3. Create the database tables\nSQLModel.metadata.create_all(engine)\n\n# 4. Create a session to interact with the database\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n# Add a root route to prevent the 404 error\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Welcome to the User Management API!\"}\n\n# 5. Add a new user to the database\n@app.post(\"/users/\", response_model=User)\ndef create_user(name: str, session: Session = Depends(get_session)):\n    new_user = User(name=name)\n    session.add(new_user)\n    session.commit()\n    session.refresh(new_user)\n    return new_user\n\n# 6. Fetch all users from the database\n@app.get(\"/users/\", response_model=list[User])\ndef get_users(session: Session = Depends(get_session)):\n    statement = select(User)\n    results = session.exec(statement)\n    users = results.all()\n    return users\n\n# 7. Update a user in the database\n@app.put(\"/users/{user_id}\", response_model=User)\ndef update_user(user_id: int, new_name: str, session: Session = Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    user.name = new_name\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n    return user\n\n# 8. Delete a user from the database\n@app.delete(\"/users/{user_id}\")\ndef delete_user(user_id: int, session: Session = Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    session.delete(user)\n    session.commit()\n    return {\"detail\": \"User deleted\"}\nüî• Big, big Explanation\nLet‚Äôs break down the key parts of your FastAPI script to provide a clear understanding of its structure and functionality:\n\nImports\n\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom sqlmodel import SQLModel, Field, create_engine, Session, select\nimport uvicorn  # Import uvicorn to run the application\n\nFastAPI: The main framework used to create the API.\nDepends: A helper to declare dependencies for your path operations (like database sessions).\nHTTPException: Used to raise HTTP errors with a specified status code and message.\nSQLModel: A library that combines Pydantic and SQLAlchemy for data modeling and database operations.\nField: A function to define the fields of a SQLModel class.\ncreate_engine: Used to create a database engine.\nSession: Represents a workspace for interacting with the database.\nselect: A function used to create SQL SELECT statements.\nuvicorn: An ASGI server used to run your FastAPI application.\n\n\nCreating the FastAPI App\n\napp = FastAPI()\n\nFastAPI Instance: This line initializes the FastAPI application. This instance will handle all the incoming requests.\n\n\nDefining the User Model\n\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n\nUser Class: This class defines the User model as a database table.\ntable=True: Indicates that this class should be treated as a database table.\nFields:\n\nid: An integer that serves as the primary key (automatically incremented).\nname: A string representing the user‚Äôs name.\n\n\n\nCreating the Database Engine\n\nDATABASE_URL = \"sqlite:///./mydb.db\"\nengine = create_engine(DATABASE_URL, echo=True)\n\nDATABASE_URL: Specifies the connection string for the SQLite database (using a file named mydb.db).\ncreate_engine: Creates the database engine that allows the application to interact with the database. The echo=True flag enables logging of all the generated SQL statements.\n\n\nCreating Database Tables\n\nSQLModel.metadata.create_all(engine)\n\nThis line creates all tables defined in the SQLModel classes in the database. If the table already exists, it will not be recreated.\n\n\nCreating a Database Session\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\nget_session function: A generator function that creates a database session for each request. It ensures that the session is properly managed (opened and closed).\n\n\nRoot Route\n\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Welcome to the User Management API!\"}\n\nRoot Endpoint: A simple GET endpoint that returns a welcome message. This prevents the 404 error when accessing the root URL.\n\n\nAdding a New User\n\n@app.post(\"/users/\", response_model=User)\ndef create_user(name: str, session: Session = Depends(get_session)):\n    new_user = User(name=name)\n    session.add(new_user)\n    session.commit()\n    session.refresh(new_user)\n    return new_user\n\nPOST Endpoint: Adds a new user to the database.\nname: str: The name of the user is received as a path parameter.\nsession: Session = Depends(get_session): Injects a session dependency into the function.\nCreating and Committing: The new user is created, added to the session, committed to the database, and returned as a response.\n\n\nFetching All Users\n\n@app.get(\"/users/\", response_model=list[User])\ndef get_users(session: Session = Depends(get_session)):\n    statement = select(User)\n    results = session.exec(statement)\n    users = results.all()\n    return users\n\nGET Endpoint: Fetches all users from the database.\nSQL Select Statement: Uses the select function to create a query and executes it.\nReturns: A list of all user records.\n\n\nUpdating a User\n\n@app.put(\"/users/{user_id}\", response_model=User)\ndef update_user(user_id: int, new_name: str, session: Session = Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    user.name = new_name\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n    return user\n\nPUT Endpoint: Updates the name of an existing user identified by user_id.\nError Handling: If the user is not found, raises a 404 HTTP exception.\nSession Management: Updates the user object, commits changes, and returns the updated user.\n\n\nDeleting a User\n\n@app.delete(\"/users/{user_id}\")\ndef delete_user(user_id: int, session: Session = Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    session.delete(user)\n    session.commit()\n    return {\"detail\": \"User deleted\"}\n\nDELETE Endpoint: Deletes the user identified by user_id.\nError Handling: If the user is not found, raises a 404 HTTP exception.\nSession Management: Deletes the user and commits the changes.\n\nThe use of FastAPI‚Äôs dependency injection for database sessions and structured error handling ensures a robust application. Each endpoint is clearly defined and returns data in a structured format, making it easy to use and extend.\n5. Why Use SQLModel in FastAPI Projects?\nSQLModel was designed with FastAPI in mind. Here‚Äôs why it‚Äôs a great fit for FastAPI projects:\n\nSeamless Integration with FastAPI: Both FastAPI and SQLModel use Pydantic under the hood, so the models you define in SQLModel work perfectly with FastAPI‚Äôs request/response validation system.\nAutomatic Data Validation: SQLModel automatically validates incoming and outgoing data, which fits beautifully with FastAPI‚Äôs validation-first philosophy.\nReduced Boilerplate: You write less code compared to raw SQLAlchemy. For example, you don‚Äôt need to specify columns explicitly, and everything integrates smoothly with FastAPI.\n\n\n\n3.2.3 Summary: SQLAlchemy vs.¬†SQLModel\n\n\n\n\n\n\n\n\nFeature\nSQLAlchemy\nSQLModel\n\n\n\n\nData Validation\nSeparate (manually or with Pydantic)\nBuilt-in with Pydantic\n\n\nSyntax\nMore verbose (manually define columns)\nSimpler, using Python type hints\n\n\nFastAPI Integration\nWorks, but not designed for it\nSeamlessly integrated\n\n\nBoilerplate Code\nMore boilerplate (defining columns)\nLess boilerplate (uses type hints + Pydantic)\n\n\nPrimary Use Case\nLarge, complex applications\nFastAPI apps, quick development\n\n\n\nIn essence, SQLAlchemy gives you more control for complex applications, but if you‚Äôre working with FastAPI, SQLModel makes everything cleaner, simpler, and faster‚Äîwithout sacrificing power. It‚Äôs like having a Swiss Army knife that‚Äôs perfectly sharpened for FastAPI‚Äôs needs.\n\n\n\n3.3 Database Migrations (Optional)\nDatabase migrations are crucial for managing changes to your database schema as your application evolves.\n\n3.1. Managing Database Schema Changes\nAlembic is a lightweight database migration tool for use with SQLAlchemy. It helps you version control your database schema changes and makes it easier to apply these changes across different environments.\nKey Features of Alembic:\n\nVersion Control: Each migration script is like a bookmark in your tree‚Äôs growth. It tells you exactly how the branches have changed over time. You can easily look back to see when a new feature was added or an old one was removed.\nAutogeneration: With Alembic, you don‚Äôt have to manually write every migration script. It‚Äôs like having a smart assistant who automatically detects changes in your models and drafts the migration scripts for you. Imagine saying, ‚ÄúHey Alembic, I added a new leaf!‚Äù and it responds with a complete plan to incorporate that leaf into your tree.\nConsistent Environments: Alembic ensures that whether you‚Äôre working in your cozy development environment or the bustling production stage, everyone is looking at the same beautiful tree. It keeps all developers and environments in sync, avoiding those dreaded ‚ÄúIt works on my machine!‚Äù moments.\n\nThe Power of Alembic in Your Hands\nWhile Alembic might feel optional for small projects, it‚Äôs like having a safety net when you decide to jump into more complex applications.\nImagine you‚Äôve planted a tiny sapling today, but a year later, it‚Äôs a full-fledged tree with multiple branches‚Äîsome may need to be reshaped or removed.\nBy implementing Alembic from the start, you save yourself from headaches down the line as your application grows.\nSo, whether you‚Äôre just starting out or scaling to new heights, think of Alembic as your trusty tool to manage database changes, keeping everything neat, organized, and growing beautifully!\n\n\n3.2. Step-by-Step Guide\n1. Installing Alembic\nFirst, install Alembic via pip:\npip install alembic\n2. Setting Up Alembic\nInitialize Alembic in your FastAPI project. Run this command in your terminal:\nalembic init alembic\nThis creates a new directory called alembic, which contains configuration files and a folder for your migration scripts.\n3. Configuring Alembic\nIn the alembic.ini file, set the database URL to match your FastAPI project:\n[alembic]\n# A generic, single database configuration.\nsqlalchemy.url = sqlite:///./mydb.db\nYou should also modify the env.py file in the alembic folder to work with SQLModel. Replace the line:\nfrom myapp import mymodel\nwith:\nfrom myapp.models import User  # Import your SQLModel classes here\nMake sure to import the base metadata:\nfrom sqlmodel import SQLModel\n\ntarget_metadata = SQLModel.metadata\n4. Creating a Migration\nWhen you modify your models (for example, adding a new column), create a migration script:\nalembic revision --autogenerate -m \"Add email column to users\"\nThis command creates a new migration file in the alembic/versions directory with the changes detected by Alembic.\nExample: Adding an Email Column to User Model\nLet‚Äôs say you want to add an email column to your User model. Update your User model like this:\nfrom sqlmodel import SQLModel, Field\n\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n    email: str = Field(default=None)  # New email field\nAfter saving this change, run the Alembic command to generate a migration:\nalembic revision --autogenerate -m \"Add email column to users\"\nAlembic generates a migration script similar to the following:\n\"\"\"Add email column to users\n\nRevision ID: 123456789abc\nRevises: previous_revision_id\nCreate Date: 2024-10-11 12:00:00.000000\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\nfrom sqlmodel import SQLModel\n\n# revision identifiers, used by Alembic.\nrevision = '123456789abc'\ndown_revision = 'previous_revision_id'\nbranch_labels = None\ndepends_on = None\n\ndef upgrade():\n    # Adding the email column\n    op.add_column('user', sa.Column('email', sa.String(), nullable=True))\n\ndef downgrade():\n    # Dropping the email column\n    op.drop_column('user', 'email')\n5. Applying the Migration\nOnce you‚Äôve created the migration script, apply it to your database:\nalembic upgrade head\nThis command runs the upgrade function in your migration script, applying the changes to your database.\nBy following these steps, you can effectively manage your database schema changes as your application grows and evolves. Now that we have a robust migration strategy in place, it‚Äôs time to delve into more advanced topics that enhance our application‚Äôs architecture and functionality.",
    "crumbs": [
      "Lectures",
      "2. Building Scalable and Efficient FastAPI Applications"
    ]
  },
  {
    "objectID": "00_Lectures/02_Lecture.html#advanced-topics-toolbox-very-advanced-so-very-optional",
    "href": "00_Lectures/02_Lecture.html#advanced-topics-toolbox-very-advanced-so-very-optional",
    "title": "Lecture 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "4. Advanced Topics Toolbox (Very advanced, so very optional)",
    "text": "4. Advanced Topics Toolbox (Very advanced, so very optional)\nYou‚Äôve made it this far‚Äîwell done! üéâ\nNow we‚Äôre diving into the supercharged section, where we tackle some seriously advanced topics in FastAPI.\nThese are the power tools that can turn you from a solid developer into a FastAPI wizard.\nThey‚Äôre optional, but if you‚Äôre up for the challenge, you‚Äôll come out with a toolbox of knowledge that will let you build, secure, and optimize APIs like a pro.\nLet‚Äôs open the toolbox:\n\n4.1. Dependency Injection\n\n‚ÄúWhy do we need it?‚Äù\nThink of dependency injection like getting a superpower to ‚Äúinject‚Äù exactly what your code needs, when it needs it, without unnecessary clutter! It‚Äôs all about clean, maintainable code that scales with your project.\n\n\nUnderstanding Dependency Injection in FastAPI\nYou‚Äôll see how FastAPI makes managing dependencies a breeze. Instead of cluttering up your logic with repetitive calls, you inject them cleanly.\nUsing fastapi.Depends for Dependency Injection\nYou‚Äôll learn how to simplify your code by using the Depends method‚Äîlike ordering takeout for your app‚Äôs resources instead of cooking every time.\nCreating Custom Dependencies\nWhy stop at the basics? Learn to create your own custom dependencies, from database connections to third-party API calls.\n\n\n4.1.1 What is Dependency Injection (DI)?\nIn FastAPI, DI helps you inject dependencies into your routes and functions without having to create them manually each time.\nThe magic happens using Depends.\n\n\n4.1.2 FastAPI‚Äôs Depends in Action\nFastAPI uses Depends to handle dependency injection in a clean and Pythonic way. Let‚Äôs look at how it works:\nfrom fastapi import FastAPI, Depends\n\napp = FastAPI()\n\n# Define a dependency\ndef get_db_connection():\n    return {\"db\": \"connected\"}\n\n# Use the dependency in an endpoint\n@app.get(\"/items/\")\ndef read_items(db_conn = Depends(get_db_connection)):\n    return {\"message\": f\"Database status: {db_conn['db']}\"}\nüî• Explanation:\n\nget_db_connection(): This function simulates connecting to a database.\nDepends(get_db_connection): The Depends() function calls our dependency and ‚Äúinjects‚Äù its return value into the route.\nNow, the db_conn variable has access to the database connection without having to create it inside the route.\n\n\n\n4.1.3 Custom Dependencies\nFastAPI isn‚Äôt just limited to database connections! You can create your own custom dependencies to manage authentication, logging, configuration, and more.\nLet‚Äôs build a simple authorization dependency:\nfrom fastapi import HTTPException, Header\n\ndef verify_token(x_token: str = Header(...)):\n    if x_token != \"supersecrettoken\":\n        raise HTTPException(status_code=403, detail=\"Invalid token\")\n    return True\n\n@app.get(\"/secure-data/\")\ndef secure_data(token = Depends(verify_token)):\n    return {\"message\": \"You have access to secure data!\"}\nüî• Explanation:\n\nverify_token(): This function checks if the token provided in the x_token header is correct.\nDepends(verify_token): If the token is valid, the user can access the secure route. If not, it raises an error.\n\n\n\n\n4.2. Testing FastAPI Applications\n\n‚ÄúYour code works‚Ä¶ but does it really?‚Äù\nTesting is like proofreading for developers. Sure, your app runs on your machine, but what about production? What about edge cases? ü§î\n\n\nUnit Testing, Integration Testing, and API Testing\nGet familiar with different types of tests and when to use them. Unit tests are like checking individual LEGO bricks, while integration tests check the full LEGO model.\nUsing Tools like pytest for Testing\nLearn the magic of pytest‚Äîyour testing buddy! From simple tests to mocking dependencies, we‚Äôll cover it all.\n\n\n4.2.1 Why is Testing Important?\nImagine launching a rocket without checking if all the parts work‚Äîscary, right? In development, it‚Äôs the same! Testing ensures that your code behaves as expected, so you don‚Äôt end up with unexpected bugs in production.\nTypes of Testing :\n\nUnit Testing: Test individual components of your code (e.g., a function or a class) to make sure they behave correctly in isolation.\nIntegration Testing: Test how different parts of your application work together (e.g., database, API, external services).\nAPI Testing: Specifically focus on testing the endpoints of your FastAPI app to ensure they return the right responses and handle errors gracefully.\n\n\n\n4.2.2 Setting Up Pytest\nFastAPI plays well with pytest, one of the most popular testing frameworks in Python. It‚Äôs simple, powerful, and easy to integrate.\n\nInstall pytest:\n\npip install pytest\n\nInstall TestClient from FastAPI: FastAPI has a built-in TestClient (powered by Starlette) that you can use to send HTTP requests during testing.\n\npip install httpx\n\n\n4.2.3 Writing Your First Unit Test\nLet‚Äôs start small by writing a unit test for a simple FastAPI route.\nHere‚Äôs your API:\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/hello/\")\ndef read_hello():\n    return {\"message\": \"Hello, World!\"}\nWriting the Test:\nfrom fastapi.testclient import TestClient\nfrom myapp import app  # Assuming your app is defined in 'myapp.py'\n\nclient = TestClient(app)\n\ndef test_read_hello():\n    response = client.get(\"/hello/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello, World!\"}\nüî• Explanation:\n\nTestClient: This allows us to simulate HTTP requests to the FastAPI app during tests.\nclient.get(\"/hello/\"): We send a GET request to the /hello/ route.\nAssertions: We check if the response‚Äôs status code is 200 (OK) and if the response data matches {\"message\": \"Hello, World!\"}.\n\n\n\n4.2.4 Writing Integration Tests\nNow, let‚Äôs take things up a notch. We‚Äôll write an integration test for an endpoint that interacts with a database.\nAPI to Test:\nfrom fastapi import FastAPI, Depends\nfrom sqlmodel import SQLModel, Session, create_engine, Field, select\n\napp = FastAPI()\n\nclass User(SQLModel, table=True):\n    id: int = Field(primary_key=True)\n    name: str\n\nengine = create_engine(\"sqlite:///./test.db\")\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n\n@app.post(\"/users/\")\ndef create_user(name: str, session: Session = Depends(get_session)):\n    user = User(name=name)\n    session.add(user)\n    session.commit()\n    return user\nWriting the Integration Test:\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlmodel import SQLModel, Session\nfrom myapp import app, engine\n\nclient = TestClient(app)\n\n@pytest.fixture\ndef setup_db():\n    # Set up the database before each test\n    SQLModel.metadata.create_all(engine)\n    yield\n    # Tear down the database after each test\n    SQLModel.metadata.drop_all(engine)\n\ndef test_create_user(setup_db):\n    response = client.post(\"/users/\", json={\"name\": \"Alice\"})\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"name\"] == \"Alice\"\n    assert \"id\" in data  # Check that the user has an id\nüî• Explanation:\n\nsetup_db(): A pytest fixture that sets up and tears down the database for each test. This ensures that your tests always start with a clean slate.\nIntegration Test: We simulate a POST request to create a new user and verify that the response data contains the expected user name and a generated ID.\n\n\n\n4.2.5 Mocking Dependencies in Tests\nSometimes, you don‚Äôt want to test every part of your app during unit tests. Maybe you don‚Äôt want to hit the actual database but want to mock the database connection instead. Here‚Äôs how you can do it:\nfrom unittest.mock import MagicMock\nfrom fastapi import Depends\n\ndef fake_get_session():\n    db = MagicMock()  # Mocked database session\n    yield db\n\n@app.post(\"/fake-user/\")\ndef create_fake_user(name: str, session = Depends(fake_get_session)):\n    session.add(name)  # Add a name to the mocked session\n    return {\"message\": f\"User {name} added\"}\nüî• Explanation:\n\nMagicMock(): A utility from the unittest library that allows us to mock dependencies like database connections.\nFake Dependency: We use the fake session during testing to ensure we don‚Äôt interact with the real database.\n\n\n\n4.2.6 Testing Summary\n\nUnit tests: Test individual components in isolation.\nIntegration tests: Ensure that different parts of your app work well together.\nTestClient: Allows you to simulate HTTP requests to your FastAPI app.\nPytest: A powerful testing framework that integrates seamlessly with FastAPI.\nMocking: Helps you isolate your tests from real dependencies.\n\n\n\n\n4.3. Security in FastAPI\n\n‚ÄúLocks on the door, security cameras on the house.‚Äù\nSecurity is non-negotiable. No one wants their API hacked or misused! You‚Äôll learn how to protect your FastAPI app from common vulnerabilities.\n\n\n\n‚ÄúWho are you? And what are you allowed to do?‚Äù\nFastAPI makes handling authentication and authorization simple, but don‚Äôt be fooled‚Äîit‚Äôs a crucial topic.\n\n\n\nAuthentication and Authorization\nKeep the wrong people out and make sure the right people can only do what they‚Äôre supposed to do.\nProtecting Against Common Vulnerabilities\nWe‚Äôll go over real-world threats like SQL injection, XSS, and CSRF, and how to defend against them. Think of it as locking all the windows before leaving your house.\nInput Validation and Sanitization\nClean your data like you‚Äôd wash your hands‚Äîalways! No messy, untrusted input allowed.\nSecure Coding Practices\nIt‚Äôs like learning to cook without burning your kitchen down. Follow best practices to keep your app safe.\n\n\n4.3.1 The Importance of Security in APIs\nYour API is like the front door to your application, and just like your house, you want to make sure it‚Äôs locked and secure. Poor security practices can expose sensitive data, compromise user privacy, and leave your app vulnerable to attacks. With FastAPI, implementing security features is not only crucial but also relatively straightforward.\n\n\n4.3.2 Authentication vs.¬†Authorization\n\nAuthentication: Who are you? Authentication is the process of verifying the identity of a user or system.\nAuthorization: What are you allowed to do? Authorization is about determining what actions a verified user can perform.\n\nThink of authentication as checking a ticket at a concert and authorization as making sure you can access the VIP lounge.\nAuthentication in FastAPI\nFastAPI provides several methods for authentication. One of the most popular and secure ways is token-based authentication using JWT (JSON Web Tokens). Let‚Äôs dive into an example:\n\nInstalling the Required Package: bash     pip install pyjwt\nCreating the Token: Here‚Äôs how you can generate and validate a JWT for user authentication.\n\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\napp = FastAPI()\n\n# Secret key to encode/decode JWT\nSECRET_KEY = \"mysecretkey\"\nALGORITHM = \"HS256\"\n\n# Mock user database\nfake_users_db = {\n    \"user1\": {\"username\": \"user1\", \"hashed_password\": \"fakehashedpassword\"}\n}\n\n# OAuth2 scheme\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\ndef create_access_token(data: dict):\n    \"\"\"Create JWT token.\"\"\"\n    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)\n\n@app.post(\"/token\")\ndef login(form_data: OAuth2PasswordRequestForm = Depends()):\n    \"\"\"Login and return JWT token.\"\"\"\n    user = fake_users_db.get(form_data.username)\n    if not user:\n        raise HTTPException(status_code=400, detail=\"Invalid credentials\")\n        \n        # Generate token with user data\n    token = create_access_token({\"sub\": form_data.username})\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n\n@app.get(\"/users/me\")\ndef get_user(token: str = Depends(oauth2_scheme)):\n    \"\"\"Get current user based on JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n        return {\"username\": username}\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\nüî• Explanation:\n\nJWT Token: A JWT token is generated when a user logs in, and this token is used to authenticate the user in future requests.\nOAuth2PasswordBearer: FastAPI‚Äôs built-in method to handle OAuth2-based authentication, which works perfectly with JWT.\nToken Endpoint: /token is where users will exchange their credentials for a token.\nToken Validation: The token is decoded on subsequent requests to validate the user‚Äôs identity.\n\nAuthorization: Controlling Access\nOnce you have authentication in place, the next step isauthorization‚Äîmaking sure users can only access what they are allowed to.\nLet‚Äôs add some roles to our users and restrict certain routes based on these roles:\nfrom fastapi import Depends\n\nroles_db = {\n    \"user1\": {\"role\": \"admin\"},\n    \"user2\": {\"role\": \"user\"}\n}\n\ndef get_current_user(token: str = Depends(oauth2_scheme)):\n    payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n    username: str = payload.get(\"sub\")\n    return roles_db.get(username)\n\n@app.get(\"/admin/\")\ndef admin_area(user: dict = Depends(get_current_user)):\n    if user[\"role\"] != \"admin\":\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    return {\"message\": \"Welcome to the admin area\"}\nüî• Explanation:\n\nRoles: We‚Äôve assigned roles (e.g., ‚Äúadmin‚Äù, ‚Äúuser‚Äù) to each user.\nAuthorization Check: We use the user‚Äôs role to allow or deny access to specific routes like /admin/.\n\n\n\n4.3.3 Protecting Against Common Vulnerabilities\nIn addition to authentication and authorization, it‚Äôs important to protect your FastAPI app against common security threats:\n\nSQL Injection: Use parameterized queries or an ORM like SQLModel to avoid exposing your app to malicious SQL injection attacks.\n\n@app.get(\"/users/\")\ndef get_users(name: str, session: Session = Depends(get_session)):\n    statement = select(User).where(User.name == name)\n    return session.exec(statement).all()\n\nCross-Site Scripting (XSS): Always sanitize user inputs that are rendered back in the UI, especially if you‚Äôre interacting with frontend components.\nCross-Site Request Forgery (CSRF): FastAPI doesn‚Äôt include CSRF protection by default, but you can integrate external packages or implement custom middleware to guard against CSRF attacks.\nInput Validation: FastAPI‚Äôs Pydantic models help you validate and sanitize inputs automatically. You should always ensure that the data users submit conforms to the expected format.\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr  # This ensures a valid email format\n\n\n4.3.4 Secure Coding Practices\nFollow these best practices to keep your code secure:\n\nLimit Exposure: Only expose the routes that are necessary and avoid allowing external access to sensitive routes (e.g., admin areas).\nUse HTTPS: Always deploy your FastAPI application with HTTPS in production to encrypt all data between the client and server.\nUpdate Dependencies: Regularly update your dependencies to ensure you‚Äôre using the latest security patches.\nEnvironment Variables: Store sensitive information (like database credentials and secret keys) in environment variables, not in your codebase.\nLogging: Set up proper logging to monitor and detect suspicious activity.\n\n\n\n\n4.4. Performance Optimization\n\n‚ÄúFaster is always better, right?‚Äù\nSpeed is key when building APIs. Let‚Äôs make sure your FastAPI app can handle the pressure‚Äîwhether it‚Äôs 10 users or 10,000.\n\nNow that you‚Äôve built a secure and functional FastAPI app, it‚Äôs time to make it fly by focusing on performance optimization! Whether your app is running a high-traffic API, managing real-time data, or simply needs to be more responsive, performance optimization can make a big difference in user experience.\n\n4.4.1 Why Optimize?\nImagine you‚Äôre using a writing app that checks your spelling and grammar in real time.\nAs you type, you expect instant feedback‚Äîcorrections popping up seamlessly as you go. But what if there‚Äôs a lag?\nYou write a sentence, and the corrections take five seconds to appear. It throws off your rhythm, you lose focus, and eventually, you might give up on the app altogether.\nThat‚Äôs how your users feel when your FastAPI app is slow.\nThey expect things to work instantly, especially for real-time features. If your app can‚Äôt keep up with the demand, they‚Äôll find another tool that can. This lesson will teach you how to optimize your FastAPI app so it stays responsive, even when it‚Äôs processing a lot of requests at once.\n\n\n4.4.2. Caching Strategies: Save Time, Repeat Less\nWhen your app processes the same requests repeatedly, caching can be a lifesaver. Instead of recalculating or re-fetching data for every request, caching lets you store previously computed responses and serve them up super fast.\nExample: Caching with fastapi-cache\n\nInstalling the Required Package:\n\npip install fastapi-cache2\n\nImplementing Basic Caching: Here‚Äôs a simple way to cache the response of an endpoint using fastapi-cache2:\n\nfrom fastapi import FastAPI\nfrom fastapi_cache import FastAPICache\nfrom fastapi_cache.backends.redis import RedisBackend\nimport redis\n\napp = FastAPI()\n\n@app.on_event(\"startup\")\nasync def startup():\n    redis_client = redis.Redis(host=\"localhost\", port=6379)\n    FastAPICache.init(RedisBackend(redis_client), prefix=\"fastapi-cache\")\n\n@app.get(\"/items/{item_id}\")\n@FastAPICache(expire=60)  # Cache this response for 60 seconds\nasync def get_item(item_id: int):\n# Imagine this is an expensive operation like a database call\n    return {\"item_id\": item_id, \"description\": \"This is an item.\"}\nüî• Explanation: - Redis: We use Redis as a caching backend. Redis is a super fast in-memory data structure store, perfect for caching. - FastAPICache: This decorator caches the response of the /items/{item_id} endpoint for 60 seconds.\nWhy Caching Matters:\n\nFaster Responses: By storing responses, you reduce the time it takes to fetch data.\nReduced Server Load: You‚Äôre not hitting your database or performing expensive operations on every request.\n\n\n\n4.4.3. Asynchronous Optimization: Handling Many Requests Like a Champ\nFastAPI shines when it comes to asynchronous programming. Unlike traditional synchronous frameworks, FastAPI can handle multiple requests concurrently, which means it‚Äôs great for high-performance use cases. See in section 1. The magic of Asynchronicity\n\n\n4.4.4. Profiling and Benchmarking: Measure Before You Improve\nYou can‚Äôt improve what you don‚Äôt measure! Profiling and benchmarking tools help you identify performance bottlenecks in your application so you know exactly where optimizations are needed.\nTools for Profiling: - cProfile: Python‚Äôs built-in profiler. - py-spy: A sampling profiler that can show you where your app is spending most of its time, even in production.\nExample: Using py-spy\n\nInstalling py-spy: bash     pip install py-spy\nProfiling your FastAPI app: bash     py-spy top -- python3 -m uvicorn main:app\n\nThis will show you a live breakdown of where your app is spending its CPU time. You can use this information to pinpoint slow parts of your code, like that unoptimized database query or the slow for-loop.\nExample: Measuring Latency with timeit\nHere‚Äôs a quick way to measure the latency of an endpoint using the timeit module:\nimport timeit\n\ndef measure():\n    return requests.get(\"http://localhost:8000/some-endpoint\")\n\nprint(timeit.timeit(measure, number=10))  # Run the request 10 times\nRemember, this section is optional but packed with advanced, exciting tools to supercharge your FastAPI skills!",
    "crumbs": [
      "Lectures",
      "2. Building Scalable and Efficient FastAPI Applications"
    ]
  },
  {
    "objectID": "00_Lectures/02_Lecture.html#in-summary",
    "href": "00_Lectures/02_Lecture.html#in-summary",
    "title": "Lecture 2 - Building Scalable and Efficient FastAPI Applications",
    "section": "In Summary",
    "text": "In Summary\n\nAsynchronicity: The Key to Responsiveness\nUnderstanding asynchronous programming allows your FastAPI applications to handle multiple requests simultaneously, making them faster and more efficient. By leveraging async and await, your app can juggle tasks like a seasoned performer!\n\n\nRouting: Navigating the API Landscape\nRouting is crucial for directing requests to the appropriate endpoints. You‚Äôve learned how to set up routes effectively, ensuring your users can access the functionality they need without a hitch.\n\n\nDatabase Integration: Persistence Made Easy\nWe explored how to connect your FastAPI app with a database using SQLModel. By mastering CRUD operations, you can create, read, update, and delete data effortlessly, paving the way for dynamic applications.\n\n\nAdvanced Topics Toolbox: Powering Up Your Skills\nWe touched on various advanced topics, including dependency injection, testing, security measures, and performance optimization. These tools are essential for creating robust, secure, and high-performing applications that can handle the demands of modern users.\nNow that we‚Äôve covered the advanced topics, let‚Äôs dive into Lab 2 and make your FastAPI apps secure, fast, and scalable! üí™",
    "crumbs": [
      "Lectures",
      "2. Building Scalable and Efficient FastAPI Applications"
    ]
  },
  {
    "objectID": "00_Lectures/01_Lecture.html",
    "href": "00_Lectures/01_Lecture.html",
    "title": "Lecture 1 - Introduction to FastAPI & Development Setup",
    "section": "",
    "text": "If you‚Äôre short on time, you can listen to the key takeaways from the course in this audio summary:\n\n\n\nListen to the Audio Overview:\n\n\n\n Download audio\n\n\n\nTogether, we‚Äôll dive into key concepts like asynchronous programming, data validation, and API deployment‚Äîhelping you sharpen your skills every step of the way :\n\nAPIs (Application Programming Interfaces) are crucial for allowing different software systems to communicate, making modern apps smarter and more interconnected.\nAPIs serve as the link between front-end and back-end systems, enabling seamless data exchange across various platforms like mobile apps, IoT devices, and desktop applications.\nHTTP is the protocol for web communication, using requests and responses with status codes to manage data exchange.\nRESTful services use HTTP methods to interact with resources, offering simplicity, flexibility, and scalability for web services.\nURLs are essential for locating resources on the web, comprising components like scheme, host, path, and query parameters.\nFastAPI stands out with asynchronous programming, automatic documentation, and type hinting, making it fast and suitable for API-heavy projects.\n\n\nWelcome to FastAPI 101, where we‚Äôre diving into one of the fastest-growing frameworks for building APIs‚ÄîFastAPI! üöÄ\n\n\n\nIf you‚Äôve ever worked with REST APIs and thought, ‚ÄúThere‚Äôs got to be a faster, easier way,‚Äù then you‚Äôre in the right place.\nFastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints. It is designed to be lightning-fast (hence the name) support for automatic documentation.\nIn this course, we‚Äôll get hands-on, from understanding how APIs make the modern web tick to setting up your own FastAPI environment. Whether you‚Äôre new to APIs or have some experience, by the end, you‚Äôll be running your own FastAPI server and ready to build dynamic, data-driven apps.\nLet‚Äôs get you up to speed!",
    "crumbs": [
      "Lectures",
      "1. Introduction to FastAPI & Development Setup"
    ]
  },
  {
    "objectID": "00_Lectures/01_Lecture.html#tldr",
    "href": "00_Lectures/01_Lecture.html#tldr",
    "title": "Lecture 1 - Introduction to FastAPI & Development Setup",
    "section": "",
    "text": "If you‚Äôre short on time, you can listen to the key takeaways from the course in this audio summary:\n\n\n\nListen to the Audio Overview:\n\n\n\n Download audio\n\n\n\nTogether, we‚Äôll dive into key concepts like asynchronous programming, data validation, and API deployment‚Äîhelping you sharpen your skills every step of the way :\n\nAPIs (Application Programming Interfaces) are crucial for allowing different software systems to communicate, making modern apps smarter and more interconnected.\nAPIs serve as the link between front-end and back-end systems, enabling seamless data exchange across various platforms like mobile apps, IoT devices, and desktop applications.\nHTTP is the protocol for web communication, using requests and responses with status codes to manage data exchange.\nRESTful services use HTTP methods to interact with resources, offering simplicity, flexibility, and scalability for web services.\nURLs are essential for locating resources on the web, comprising components like scheme, host, path, and query parameters.\nFastAPI stands out with asynchronous programming, automatic documentation, and type hinting, making it fast and suitable for API-heavy projects.\n\n\nWelcome to FastAPI 101, where we‚Äôre diving into one of the fastest-growing frameworks for building APIs‚ÄîFastAPI! üöÄ\n\n\n\nIf you‚Äôve ever worked with REST APIs and thought, ‚ÄúThere‚Äôs got to be a faster, easier way,‚Äù then you‚Äôre in the right place.\nFastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints. It is designed to be lightning-fast (hence the name) support for automatic documentation.\nIn this course, we‚Äôll get hands-on, from understanding how APIs make the modern web tick to setting up your own FastAPI environment. Whether you‚Äôre new to APIs or have some experience, by the end, you‚Äôll be running your own FastAPI server and ready to build dynamic, data-driven apps.\nLet‚Äôs get you up to speed!",
    "crumbs": [
      "Lectures",
      "1. Introduction to FastAPI & Development Setup"
    ]
  },
  {
    "objectID": "00_Lectures/01_Lecture.html#what-the-heck-is-an-api-and-why-should-you-care",
    "href": "00_Lectures/01_Lecture.html#what-the-heck-is-an-api-and-why-should-you-care",
    "title": "Lecture 1 - Introduction to FastAPI & Development Setup",
    "section": "1. What the Heck is an API, and Why Should You Care?",
    "text": "1. What the Heck is an API, and Why Should You Care?\nAn API (Application Programming Interface) is the glue that holds our digital world together. It‚Äôs the bridge that lets apps and services exchange data seamlessly.\n\n\n\nThink of it like sending a request to your favorite delivery app for a meal‚ÄîAPIs ensure your order is understood, processed, and delivered to the kitchen (and then to you). From social media apps to payment gateways, APIs power the connections that make modern software work.\nMore precisely, an API is a set of protocols, tools, and definitions that allow different software applications to communicate with each other. It defines how requests are made between clients (users or systems) and servers (service providers) and ensures data is transferred in a structured way.\n\nWhy are APIs so essential?\n\n\nThey let apps talk to each other, allowing you to share, pull, and push data without breaking a sweat.\nThey‚Äôre the reason your phone app syncs with your watch‚Äîand why your boss can track your productivity tools. (Oops.)\nModern apps are like Legos‚Äîmodular, flexible, and built using APIs to connect their different parts.\n\n\nWhy APIs are crucial for data and cybersecurity experts?\n\nAPIs are the digital bridges that allow different software systems to communicate and share data.\n\nFor data experts, they open up a world of possibilities by enabling the integration of diverse datasets, automating workflows, and enhancing data-driven insights. Leveraging APIs allows you to seamlessly incorporate real-time data from various sources, enriching your analyses and models with up-to-date insights.\nFor cybersecurity professionals, understanding APIs is crucial for safeguarding digital assets. As APIs become more prevalent, they also become potential targets for cyber threats. Learning how to build and secure APIs ensures that sensitive data is protected and that your systems remain resilient against attacks.\n\nWhether you‚Äôre a data scientist looking to enhance your analytical capabilities or a cybersecurity expert aiming to fortify your defenses, this course will introduce you to the knowledge and tools you need to succeed.",
    "crumbs": [
      "Lectures",
      "1. Introduction to FastAPI & Development Setup"
    ]
  },
  {
    "objectID": "00_Lectures/01_Lecture.html#the-importance-of-apis-in-client-server-architecture",
    "href": "00_Lectures/01_Lecture.html#the-importance-of-apis-in-client-server-architecture",
    "title": "Lecture 1 - Introduction to FastAPI & Development Setup",
    "section": "2. The Importance of APIs in Client-Server Architecture",
    "text": "2. The Importance of APIs in Client-Server Architecture\nIn the world of applications, it‚Äôs essential to distinguish between the Front-End and the Back-End:\n\nFront-End: This is what users interact with‚Äîthink of it as the stylish storefront of your application. It includes everything the user sees and engages with, from buttons to text. Front-end development focuses on user experience and design.\nBack-End: This is the engine that powers the application. It handles data storage, business logic, and server-side functionality. Users don‚Äôt see it, but without the Back-End, nothing would work!\n\nNow, here‚Äôs where APIs come into play. They are the vital links that connect these two worlds. APIs allow the Front-End to request and send data to the Back-End without needing to know how the Back-End operates.\n\n\n\nBut wait! APIs aren‚Äôt just for web services‚Äîthey‚Äôre the backbone of various applications. Here are a few examples:\n\nMobile Apps: Think about how your favorite weather app gets real-time data. It communicates with a weather service API to fetch the latest forecasts and display them beautifully on your screen.\nIoT Devices: Smart home devices, like thermostats or lights, use APIs to send and receive data. For instance, a smart thermostat might send temperature readings to a cloud service via an API, allowing you to control it remotely through a mobile app.\nDesktop Applications: Applications like Microsoft Word can use APIs to integrate with online services. For example, you might use an API to fetch stock photos from a service like Unsplash directly within the app, streamlining your workflow.\nThird-Party Integrations: E-commerce platforms often integrate payment gateways (like Stripe or PayPal) using APIs. When you check out, the platform calls the payment API to process your transaction securely.\n\nThis separation enables multiple clients‚Äîlike web apps, mobile apps, desktop applications, and even IoT devices‚Äîto communicate with the same Back-End services. This means you can build a seamless experience across platforms, ensuring that all your applications can tap into the same data and functionality.",
    "crumbs": [
      "Lectures",
      "1. Introduction to FastAPI & Development Setup"
    ]
  },
  {
    "objectID": "00_Lectures/01_Lecture.html#http-basics-its-like-a-postman-for-the-web",
    "href": "00_Lectures/01_Lecture.html#http-basics-its-like-a-postman-for-the-web",
    "title": "Lecture 1 - Introduction to FastAPI & Development Setup",
    "section": "3. HTTP Basics: It‚Äôs Like a Postman for the Web",
    "text": "3. HTTP Basics: It‚Äôs Like a Postman for the Web\nHTTP might sound fancy, but think of it as the mail service of the web‚Äîdelivering packages (requests) from clients (you) to servers (your favorite app).\nIt‚Äôs like sending a letter to a friend. üì©\nYou write the letter (create a request), put it in an envelope (format it), address it (specify the URL), and send it off (make the request). The server gets your letter and responds with a package (response) containing your requested information.\n\n3.1. Requests in the Tech World\n\nRequests are all about getting what you want, with a sprinkle of charm and a dash of politeness.\n\n\nThe Friendly Ask: Picture this‚Äîyou‚Äôre at a dinner party, and you spot the salad across the table. You lean in and say, ‚ÄúCould you please pass the salad? It looks amazing!‚Äù That‚Äôs a request. It‚Äôs all about expressing your desires with a touch of grace and a hint of enthusiasm.\nThe Formal Plea: Now, let‚Äôs get a bit official. You‚Äôre applying for that dream library card. You fill out a form, scribble your details, and voil√†! You‚Äôve made a formal request. It‚Äôs like sending a little note to the universe saying,\n\n\n‚ÄúI‚Äôm ready for all the books!‚Äù\n\nIn the tech world, requests are the stars of the digital show. When you type a website URL into your browser and hit enter, you‚Äôre basically saying,\n\n‚ÄúHey server, can you show me this awesome webpage?‚Äù\n\nYour browser sends a request to the server, and the server‚Äîlike a gracious host‚Äîreturns with the webpage you asked for, often with a little note on how things went down (that‚Äôs the HTTP status code, see after).\n\n\n\nRequests are everywhere, from the dinner table to the internet, keeping everything moving along with a polite ask every step of the way.\n\n\n3.2. HTTP Status Codes\nLike life, requests have outcomes. Some are good, some are bad, and some make you want to throw your laptop out the window.\nHTTP status codes are like the traffic signals of the web, guiding the flow of data between clients and servers. They indicate the outcome of an HTTP request, helping developers and users understand what happened during the interaction.\n\n\n\nHere‚Äôs a deeper dive into some of the most common and important HTTP status codes:\n\n1xx: Informational Responses\nThese codes indicate that the request was received and understood, and the process is continuing.\n\n100 Continue: The server has received the request headers, and the client should proceed to send the request body.\n\n\n\n2xx: Success\nThese codes indicate that the request was successfully received, understood, and accepted.\n\n200 OK: The request was successful, and the server returned the requested resource.\n201 Created: The request was successful, and a new resource was created as a result.\n\n\n\n3xx: Redirection\nThese codes indicate that further action needs to be taken by the user agent to fulfill the request.\n\n301 Moved Permanently: The requested resource has been permanently moved to a new URL.\n302 Found: The requested resource is temporarily located at a different URL.\n\n\n\n4xx: Client Errors\nThese codes indicate that the client seems to have made an error.\n\n400 Bad Request: The server could not understand the request due to invalid syntax.\n401 Unauthorized: The request requires user authentication.\n403 Forbidden: The server understood the request but refuses to authorize it.\n404 Not Found: The server can‚Äôt find the requested resource. This is often the result of a broken link or a mistyped URL.\n\n\n\n5xx: Server Errors\nThese codes indicate that the server failed to fulfill a valid request.\n\n500 Internal Server Error: The server encountered an unexpected condition that prevented it from fulfilling the request.\n502 Bad Gateway: The server, while acting as a gateway or proxy, received an invalid response from the upstream server.\n503 Service Unavailable: The server is not ready to handle the request, often due to maintenance or overload.\n\nUnderstanding these codes is crucial for debugging and improving user experience.\nFor instance, too many 404 errors might indicate broken links that need fixing, while frequent 500 errors could suggest server-side issues that require attention.\nBy monitoring these codes, developers can ensure smoother and more reliable web interactions.\nFor a comprehensive list of HTTP status codes, you can refer to resources like Wikipedia or detailed guides on developer platforms.\nTo wrap it all up, the Request/Response Cycle works like this:\n\nKnock, Knock!: You (the client) send a request to the server, similar to knocking on the door of your favorite restaurant, asking for your meal.\nServer Response: The server opens the door and either provides the data (response) or, on a not-so-great day, might say, ‚ÄúNot today‚Äù with an error message like 404 Not Found.\n\n\n\n\n3.3. Role of HTTP Verbs in RESTful Web Services\nHTTP verbs, also known as HTTP methods, are integral to RESTful web services. They define the actions that can be performed on resources available on a server, forming the backbone of how clients and servers communicate over the web.\nLet‚Äôs explore how these verbs contribute to the functionality and efficiency of RESTful services.\n\nWhat is a RESTful Service?\nA RESTful service is a web service that follows the principles of REST (Representational State Transfer), an architectural style for designing networked applications.\n\n\n\nLet‚Äôs explore the core principles of RESTful services and illustrate each concept.\n\nResource-Based\n\nIn REST, everything is treated as a resource, identified by a unique URI (Uniform Resource Identifier). Consider an online bookstore. Each book can be a resource with a URI like https://api.bookstore.com/books/123, where 123 is the unique identifier for a specific book.\n\nStateless Communication\n\nRESTful services are stateless, meaning each request from a client to a server must contain all the information needed to understand and process the request.\nWhen you log into a website, each request you make (like viewing your profile) includes your authentication token. The server doesn‚Äôt remember your login state between requests; it relies on the token you provide each time.\n\nUse of Standard HTTP Methods\n\nRESTful services use standard HTTP methods to perform operations on resources.\n\nGET: Retrieve a list of books with GET https://api.bookstore.com/books.\nPOST: Add a new book with POST https://api.bookstore.com/books and include the book details in the request body.\nPUT: Update book information with PUT https://api.bookstore.com/books/123 and provide the updated data.\nDELETE: Remove a book with DELETE https://api.bookstore.com/books/123.\n\nGet more details on method here\n\nRepresentation-Oriented\n\nResources can be represented in various formats, such as JSON, XML, or HTML. When you request a book‚Äôs details, you might receive the data in JSON format:\n    {\n       \"id\": 123,\n       \"title\": \"RESTful Web Services\",\n       \"author\": \"John Doe\",\n       \"price\": 29.99\n}\n\nStatelessness and Scalability\n\nThe stateless nature of RESTful services allows them to scale easily. An e-commerce site can handle thousands of simultaneous users because each request is independent, allowing the server to distribute requests across multiple servers without maintaining session state.\n\nCacheable Responses\n\nResponses from RESTful services can be cached to improve performance. A news website might cache the response for the latest headlines, so repeated requests for the same data can be served quickly without hitting the server again.\n\n\nBenefits of RESTful Services\n\nSimplicity and Flexibility: RESTful services are straightforward to use and flexible, allowing developers to build APIs that can be easily consumed by different clients, such as web browsers, mobile apps, and other servers.\nInteroperability: By using standard HTTP methods and formats, RESTful services can be accessed by any client that understands HTTP, making them highly interoperable.\nScalability: The stateless nature of RESTful services allows them to scale horizontally, handling more requests by adding more servers.\n\n\n\n\n3.4. REST, SOAP, and GraphQL: The Web‚Äôs Favorite Squabble\nRESTful services have become a popular choice for building APIs due to their simplicity, scalability, and ability to integrate seamlessly with the web‚Äôs existing infrastructure.\nBuilding APIs can be like debating pizza toppings‚ÄîREST, SOAP, and GraphQL are all different flavors:\n\nREST is the most popular, like classic pepperoni pizza. Simple, reliable, and everyone loves it.\nSOAP is for the serious types, like a fancy deep-dish. It‚Äôs packed with structure, uses a lot of XML, and is great for enterprises that need bulletproof security.\nGraphQL is for the data nerds, a custom pizza where you choose exactly what you want on it. No more, no less. It‚Äôs flexible and efficient for complex data retrieval.\n\nIf REST is the crowd-pleaser, SOAP is for the suit-and-tie folks, and GraphQL is the cool kid shaking things up with customization.\nNo matter which flavor of API you prefer‚Äîbe it REST, SOAP, or GraphQL‚ÄîURLs are the essential connectors that enable these technologies to function. They act as the precise coordinates that direct your API calls to the appropriate destinations on the internet, ensuring efficient and accurate data retrieval and interaction.",
    "crumbs": [
      "Lectures",
      "1. Introduction to FastAPI & Development Setup"
    ]
  },
  {
    "objectID": "00_Lectures/01_Lecture.html#url-construction-what-is-a-url",
    "href": "00_Lectures/01_Lecture.html#url-construction-what-is-a-url",
    "title": "Lecture 1 - Introduction to FastAPI & Development Setup",
    "section": "4. URL Construction: What is a URL?",
    "text": "4. URL Construction: What is a URL?\nA URL (Uniform Resource Locator) is essentially the address used to locate resources on the web. Just as a physical address directs you to a building or a house, a URL tells your browser or application where to find a specific resource, be it a webpage, image, or an API endpoint.\n\n\n\nWhen working with APIs, URLs are crucial because they serve as the precise coordinates that direct API calls to the right destinations. Whether you‚Äôre making a simple GET request or a complex data manipulation with POST, the URL is where it all starts.\n\n4.1. Components of a URL\nA URL is made up of several key components, each serving a unique purpose. Understanding these parts helps in correctly constructing and troubleshooting API requests.\n1. Scheme (or Protocol)\nThis defines the protocol used to access the resource. The two most common schemes are http (Hypertext Transfer Protocol) and https (Hypertext Transfer Protocol Secure). The https scheme is preferred over http because it encrypts the data being transmitted, ensuring a secure connection.\n2. Host\nThe host specifies the domain name or IP address of the server that is hosting the resource. It essentially tells your browser where to send your request.\nExample: www.example.com In the context of APIs, the host is often the base URL of the API provider, such as api.openweathermap.org or api.example.com.\n3. Path\nThe path points to the specific resource on the server. It acts like the directory structure in a file system, guiding the server to a particular location.\nExample: /products\nIn RESTful APIs, the path usually represents the endpoint or resource being accessed, such as /users, /orders, or /products/123.\n4. Query Parameters\nQuery parameters are key-value pairs appended to the end of the path, prefixed by a ? symbol. They provide extra information or filtering criteria for the request.\nExample: ?category=fruits&sort=price_asc\nMultiple parameters are separated by an &. In the above example: - category=fruits: Filters products to show only items in the ‚Äúfruits‚Äù category. - sort=price_asc: Orders the results by price in ascending order.\n5. Fragment Identifier:\nThis part of a URL points to a specific section within a webpage, often used in HTML documents.\nExample: #section2\nFor APIs, this is rarely used, but it‚Äôs helpful for navigating large documents.\nPutting it all together, a complete URL looks like this:\nhttps://www.example.com/products?category=fruits&sort=price_asc\nIn this URL:\n\nScheme: https://\nHost: www.example.com\nPath: /products\nQuery Parameters: ?category=fruits&sort=price_asc\n\n\n\n4.2. Constructing a URL with Parameters\nWhen constructing URLs for API requests, query parameters are often used to filter, sort, or modify the returned data.\nFor example, consider a URL for fetching a list of products filtered by category and sorted by price:\nGET /products?category=fruits&sort=price_asc\nBreaking down the query parameters:\n\ncategory=fruits: Specifies that only products categorized as ‚Äúfruits‚Äù should be returned.\nsort=price_asc: Instructs the server to sort the returned products by price in ascending order.\n\nThis method of passing parameters is especially useful for creating dynamic queries without modifying the underlying codebase.\n\n\n4.3. Best Practices for URL Construction\n\nUse Descriptive Paths:\n\nUse readable and meaningful paths that describe the resource.\nGood: /users/{id}/profile\nBad: /u123?details=profile\n\nLimit the Number of Query Parameters:\n\nOverusing query parameters can make URLs long and difficult to manage.\nUse query parameters only when filtering or modifying the request.\n\nAlways Use HTTPS for Secure Data Transmission:\n\nNever use http for sensitive data to prevent data interception.\nAlways opt for https:// when constructing your base URLs.\n\nUse Proper Encodings for Special Characters:\n\nSpecial characters (?, &, =, etc.) must be URL-encoded to prevent misinterpretation by the server.\nUse libraries or built-in functions to safely encode URLs, such as Python‚Äôs urllib.parse.\n\n\n\n\n4.4. Constructing API URLs: Example Scenarios\nLet‚Äôs explore a few common scenarios to see how URLs are constructed for different use cases:\n\n1. Fetching User Profile Data\nIf you want to retrieve a user‚Äôs profile data using an API:\nGET https://api.example.com/users/123/profile\nHere:\n\nhttps://api.example.com is the base URL.\n/users/123/profile is the path, where 123 is the user ID.\n\n\n\n2. Searching for Products in an E-commerce API\nTo search for laptops priced under $1000:\nGET https://api.shop.com/products?category=laptops&price_max=1000\n\nThe category parameter filters by product category (laptops).\nThe price_max parameter restricts results to products under $1000.\n\n\n\n3. Paginated Results in a Large Dataset**\nTo navigate through a paginated list of items:\nGET https://api.data.com/resources?page=2&limit=20\n\nThe page parameter specifies the current page (2).\nThe limit parameter defines the number of items per page (20).\n\nIncorporating these elements properly ensures your API calls are both efficient and readable, reducing the likelihood of errors and making debugging easier.\nURLs are the backbone of API communication. Understanding how to construct them accurately‚Äîusing appropriate schemes, paths, and query parameters‚Äîwill help you efficiently interact with web resources and design effective API interactions.",
    "crumbs": [
      "Lectures",
      "1. Introduction to FastAPI & Development Setup"
    ]
  },
  {
    "objectID": "00_Lectures/01_Lecture.html#full-architecture-of-an-http-request-and-response-a-breakdown",
    "href": "00_Lectures/01_Lecture.html#full-architecture-of-an-http-request-and-response-a-breakdown",
    "title": "Lecture 1 - Introduction to FastAPI & Development Setup",
    "section": "5. Full Architecture of an HTTP Request and Response: A Breakdown",
    "text": "5. Full Architecture of an HTTP Request and Response: A Breakdown\nTo truly grasp how web applications function, we need to understand the full architecture of an HTTP request and response.\nIt‚Äôs like uncovering the inner workings of a conversation between a client (like a web browser) and a server (the one holding the data).\nLet‚Äôs walk through a scenario where a user tries to view their profile information on a web application. This is a simplified yet typical process:\n1. The Scenario: User Wants Profile Information\nImagine a user logging into their favorite web app to check their profile. The magic starts when they click on the profile page. This action sends a request to the server, asking it to fetch the profile data.\n2. The Client Sends a Request\n\nUser Action: The user clicks their profile page.\nClient Side: The front end (browser or app) constructs an HTTP request to fetch the necessary data from the server.\n\n3. The Structure of an HTTP Request\nHere‚Äôs what that request might look like:\nGET /api/users/profile HTTP/1.1\nHost: example.com\nContent-Type: application/json\nAuthorization: Bearer &lt;token&gt;\nAccept: application/json\nEach part serves a specific purpose:\n\nGET: This is the method, telling the server we‚Äôre retrieving information.\n/api/users/profile: This is the endpoint‚Äîthe resource (in this case, the profile) we‚Äôre trying to access.\nHTTP/1.1: This is the version of the HTTP protocol being used.\n\nThe headers provide additional context, such as:\n\nHost: Specifies the domain (example.com).\nContent-Type: Declares that the data being sent is in JSON format.\nAuthorization: A token that proves the user is allowed to access the data.\nAccept: Specifies that the client expects a JSON response.\n\n4. The Server Processes the Request\nOnce the server receives this request, it jumps into action:\n\nAuthentication: First, it checks the Authorization token to ensure the user has permission to access the resource.\nData Retrieval: If the authentication is successful, the server dives into its database to fetch the requested user data.\n\n5. The Server Sends Back a Response\nWith the requested data in hand, the server responds to the client. Here‚Äôs an example:\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-cache\n\n{\n    \"username\": \"user123\",\n    \"email\": \"user123@example.com\",\n    \"fullName\": \"User OneTwoThree\"\n}\nThis response is made up of:\n\nStatus Line:\n\nHTTP/1.1 200 OK tells the client that the request was successful.\n\nHeaders: These give additional information, such as the fact that the response contains JSON data (Content-Type: application/json) and that the data should not be cached (Cache-Control: no-cache).\nResponse Body: This holds the actual data‚Äîin this case, the user‚Äôs profile details.\n\nTo transition smoothly between these sections, we need to bridge the gap from the technical process of the client receiving the server‚Äôs response to introducing FastAPI‚Äôs standout features. Here‚Äôs a natural transition:\n6. The Client Receives the Response\nOnce the client (the web app) gets the server‚Äôs response, it processes the information:\n\nParsing: The client reads the JSON response.\nRendering: The app updates the user interface with the profile details, like the username and email.\n\nThe request-response cycle is the bread and butter of web communication, but what if we could supercharge the way our apps handle these interactions? That‚Äôs where FastAPI comes in.",
    "crumbs": [
      "Lectures",
      "1. Introduction to FastAPI & Development Setup"
    ]
  },
  {
    "objectID": "00_Lectures/01_Lecture.html#fastapis-superpowers",
    "href": "00_Lectures/01_Lecture.html#fastapis-superpowers",
    "title": "Lecture 1 - Introduction to FastAPI & Development Setup",
    "section": "6. FastAPI‚Äôs Superpowers",
    "text": "6. FastAPI‚Äôs Superpowers\nFastAPI‚Äôs key features combine to create a powerful, efficient, and developer-friendly framework for building APIs. Its focus on performance, simplicity, and modern practices makes it an excellent choice for both new and experienced developers.\n(image/ stats repos github /documentation)\n\n6.1. FastAPI vs.¬†Flask vs.¬†Django\nLet‚Äôs explore how FastAPI compares with other popular Python web frameworks‚ÄîFlask and Django‚Äîand see why it might be the right choice for your next project.\n\nFlask: Flask is a lightweight framework that offers flexibility and simplicity for building applications quickly. However, it may require additional libraries for larger projects, which can complicate development. It‚Äôs great for smaller applications or prototypes but lacks the performance optimizations of FastAPI.\nDjango: Django is a comprehensive framework that includes numerous built-in features, making it suitable for complex, feature-rich applications. However, its size and structure may be overkill for simpler API projects, leading to unnecessary complexity.\nFastAPI: FastAPI stands out as a modern framework optimized for performance and efficiency, especially for building APIs. It combines the best of both worlds by being lightweight yet powerful, making it ideal for high-performance applications.\n\n\n\n6.2. Key Features\nWhether you need high performance for I/O-bound apps or want to build robust APIs with minimal effort, FastAPI delivers with its superpowers of async support, auto-generated docs, and tight integration with Pydantic for data validation.\n\n\n\n\n\n\n\n\nFeature\nDefinition\nReal-Life Example\n\n\n\n\nAsynchronous Programming\nEnables non-blocking operations, allowing multiple tasks to run concurrently without waiting.\nA travel booking website retrieves flight and hotel data from various APIs simultaneously, reducing user wait times.\n\n\nAutomatic Interactive Documentation\nGenerates API documentation automatically, making it easy to understand and test the API.\nA developer building a payment processing API uses FastAPI‚Äôs auto-generated docs to help external developers integrate quickly.\n\n\nRequest and Response Models with Pydantic\nDefines the structure of incoming requests and validates them against specified models.\nAn online learning platform ensures all course registration requests include valid student names and emails, preventing errors.\n\n\nPath and Query Parameters\nSimplifies the extraction of parameters from the URL, making it easy to handle dynamic requests.\nA ride-sharing app allows users to filter their ride history using path and query parameters for user IDs and ride statuses.\n\n\nDependency Injection System\nFacilitates the management of external dependencies in a clean and modular way.\nA blogging platform manages user authentication and database connections through dependency injection, keeping the code organized.\n\n\nPerformance and ASGI Integration\nLeverages ASGI for high concurrency and efficient handling of web requests.\nA streaming service can handle thousands of concurrent video uploads without delays, ensuring a smooth user experience.\n\n\nHandling JSON, Headers, and Forms\nProvides intuitive methods for extracting and validating JSON data, headers, and form submissions.\nAn online food delivery app manages order submissions and user feedback through well-structured handling of JSON and forms.\n\n\nData Validation with Pydantic\nValidates incoming data against defined schemas, ensuring data integrity and reducing errors.\nA financial services company verifies that loan applications meet specific criteria (e.g., income, credit score) before processing.\n\n\n\nFastAPI stands out in the world of web frameworks, offering a unique blend of speed, efficiency, and user-friendliness.\nBy leveraging modern Python features, it simplifies API development while ensuring high performance and reliability.\nEach key feature‚Äîfrom asynchronous programming to automatic documentation‚Äîcontributes to a seamless development experience that can adapt to the growing demands of modern applications.",
    "crumbs": [
      "Lectures",
      "1. Introduction to FastAPI & Development Setup"
    ]
  },
  {
    "objectID": "00_Lectures/01_Lecture.html#in-summary",
    "href": "00_Lectures/01_Lecture.html#in-summary",
    "title": "Lecture 1 - Introduction to FastAPI & Development Setup",
    "section": "In Summary",
    "text": "In Summary\n\n\n\n\nAPIs: The Digital Bridge\nAPIs are the essential link between clients and servers, enabling smooth communication. Every time you check your email or log into an app, APIs are handling the requests and responses in the background, ensuring everything works seamlessly.\n\n\nHTTP: The Web‚Äôs Mail Carrier\nHTTP acts like the postman of the web, delivering requests from the client to the server and bringing responses back, complete with headers, status codes, and content. Mastering HTTP is key to mastering APIs.\n\n\nFastAPI: The Supercharged Framework\nFastAPI takes API development to the next level:\n\nSpeed & Performance: Thanks to asynchronous programming with async/await, FastAPI can handle high loads of requests efficiently.\nAuto-Generated Documentation: FastAPI automatically creates clear and interactive API docs with Swagger UI and ReDoc, so you don‚Äôt have to.\nType Safety & Validation: By leveraging Python‚Äôs type hints, FastAPI keeps your code clean, safe, and easy to maintain, while handling data validation without extra hassle.\n\nIn short, FastAPI is built for performance, simplicity, and productivity‚Äîespecially for API-heavy projects.\n\nNow that we‚Äôve got the essentials covered, let‚Äôs dive into the Lab 1",
    "crumbs": [
      "Lectures",
      "1. Introduction to FastAPI & Development Setup"
    ]
  },
  {
    "objectID": "00_Lectures/03_Lecture.html",
    "href": "00_Lectures/03_Lecture.html",
    "title": "Lecture 3 - Deployment and Production Considerations",
    "section": "",
    "text": "If you‚Äôre short on time, tune into the cosmic highlights of our course in this audio summary:\n\n\n\nListen to the Audio Overview:\n\n\n\n Download audio\n\n\n\nIn this course, we embark on a stellar journey to master the deployment of machine learning applications:\n\nContainerization with Docker: Your starship for consistent and portable deployments.\nCI/CD Pipelines using GitHub Actions: Automate your deployment journey like a seasoned Jedi.\nHeroku Deployment: Launch your applications into the cloud galaxy with ease.\nBest Practices: Optimize, scale, and secure your deployments for interstellar performance.\nAdvanced Tools: Explore the vast universe of cloud platforms and orchestration tools.\n\n\nYour deployment is a starship.\nEach component is a crucial part of your mission, from the engines (Docker) to the navigation system (GitHub Actions).\n\n\n\nContainerization is like building a reliable starship that can travel across different galaxies (environments) without a hitch. CI/CD Pipelines are your autopilot, ensuring smooth and automated journeys through the deployment cosmos.\nHeroku is your launchpad, propelling your applications into the cloud with the grace of a Jedi starfighter. Best Practices are your navigational charts, guiding you through optimization, scaling, and security challenges.\nAdvanced Tools are the hyperdrive enhancements, allowing you to explore new frontiers in cloud deployment and orchestration.\n\nAre you ready to launch your machine learning applications into the cloud galaxy?\n\nLet‚Äôs get started on this epic adventure!",
    "crumbs": [
      "Lectures",
      "3. Deployment and Production Considerations"
    ]
  },
  {
    "objectID": "00_Lectures/03_Lecture.html#tldr",
    "href": "00_Lectures/03_Lecture.html#tldr",
    "title": "Lecture 3 - Deployment and Production Considerations",
    "section": "",
    "text": "If you‚Äôre short on time, tune into the cosmic highlights of our course in this audio summary:\n\n\n\nListen to the Audio Overview:\n\n\n\n Download audio\n\n\n\nIn this course, we embark on a stellar journey to master the deployment of machine learning applications:\n\nContainerization with Docker: Your starship for consistent and portable deployments.\nCI/CD Pipelines using GitHub Actions: Automate your deployment journey like a seasoned Jedi.\nHeroku Deployment: Launch your applications into the cloud galaxy with ease.\nBest Practices: Optimize, scale, and secure your deployments for interstellar performance.\nAdvanced Tools: Explore the vast universe of cloud platforms and orchestration tools.\n\n\nYour deployment is a starship.\nEach component is a crucial part of your mission, from the engines (Docker) to the navigation system (GitHub Actions).\n\n\n\nContainerization is like building a reliable starship that can travel across different galaxies (environments) without a hitch. CI/CD Pipelines are your autopilot, ensuring smooth and automated journeys through the deployment cosmos.\nHeroku is your launchpad, propelling your applications into the cloud with the grace of a Jedi starfighter. Best Practices are your navigational charts, guiding you through optimization, scaling, and security challenges.\nAdvanced Tools are the hyperdrive enhancements, allowing you to explore new frontiers in cloud deployment and orchestration.\n\nAre you ready to launch your machine learning applications into the cloud galaxy?\n\nLet‚Äôs get started on this epic adventure!",
    "crumbs": [
      "Lectures",
      "3. Deployment and Production Considerations"
    ]
  },
  {
    "objectID": "00_Lectures/03_Lecture.html#introduction-to-deploying-machine-learning-applications",
    "href": "00_Lectures/03_Lecture.html#introduction-to-deploying-machine-learning-applications",
    "title": "Lecture 3 - Deployment and Production Considerations",
    "section": "1. Introduction to Deploying Machine Learning Applications",
    "text": "1. Introduction to Deploying Machine Learning Applications\n\n1.1. The Challenges of Deploying Machine Learning Models\nDeploying machine learning models can sometimes feel like trying to fit a square peg into a round hole. Unlike traditional software, these models are like your favorite rock band‚Äîdynamic, unpredictable, and requiring lots of fine-tuning for each performance.\nLet‚Äôs explore these challenges in detail:\nEnvironment Mismatch: Imagine your model is a Broadway star, rehearsed and fine-tuned in one environment, but on opening night, the stage looks completely different.\nThis mismatch is one of the most common issues faced during deployment.\nDifferent machines might have various operating systems, library versions, or hardware configurations, causing unexpected behavior when the model is deployed. This is akin to a musician arriving at a venue only to find their instruments are tuned differently or missing entirely.\nTo mitigate this, it‚Äôs essential to maintain a consistent environment across development and production stages. This can be achieved through environment management tools like virtualenv for Python or using containerization technologies like Docker, which we will explore later.\nScalability Issues: Picture a concert where more fans show up than the venue can handle. Your model should be ready to handle the crowd, scaling up or down as needed. Scalability is crucial, especially in cloud-based applications where the user base can grow unpredictably.\nWithout proper scalability, applications can suffer from slow response times or crashes under heavy load.\nTo address scalability, load testing tools like Apache JMeter or Locust can be used to simulate a range of traffic conditions. Additionally, cloud platforms like AWS, Azure, and Google Cloud offer auto-scaling features that automatically adjust resources based on demand.\nVersion Control: Like a band releasing multiple albums, tracking different versions of your models is crucial to know which one hits the right note. Imagine if every time a band played, they had to remember which version of their song arrangement they were supposed to perform. Similarly, in machine learning, keeping track of model versions ensures that you can revert to previous versions if a new model does not perform as expected.\nTools like DVC (Data Version Control) and MLflow provide mechanisms to manage and version control models, datasets, and experiments, making it easier to reproduce results and manage model lifecycle.\nPerformance Optimization: Ensuring your model performs efficiently is like ensuring the lead singer hits all the right notes during a live performance. Performance can be influenced by factors such as model complexity, data input size, and computational resources. Optimizing performance is crucial for providing a seamless user experience and can also reduce computational costs.\nTechniques such as quantization, pruning, and knowledge distillation can be applied to reduce model size and improve inference speed without significantly sacrificing accuracy. Profiling tools like TensorBoard and PyTorch‚Äôs profiler can help identify performance bottlenecks in your model.\n\n\n1.2. Different Deployment Approaches\nDeploying models isn‚Äôt a one-size-fits-all approach.\nIt‚Äôs more like choosing between a solo acoustic set or a full-on rock concert. Each deployment strategy has its pros and cons, depending on the specific requirements and constraints of the application.\nLet‚Äôs explore these different paths in detail:\nLocal Deployment: It‚Äôs like playing music for your friends in your garage. Quick and easy, but not scalable. Local deployment is suitable for testing and development purposes, allowing you to quickly iterate and debug models on your local machine. However, it lacks the scalability and reliability needed for production environments.\nFor local deployment, tools like Jupyter Notebooks or local Flask servers can be used to serve models and test their endpoints. This approach is ideal for prototyping and learning but not for handling production-scale traffic.\nServer-Based Deployment: Imagine booking a local venue. More organized and can handle a decent crowd, but may require manual tuning when issues arise. Server-based deployment involves hosting your model on dedicated servers, either on-premises or in the cloud. This approach provides more control over the environment and resources.\nServers can be configured using web frameworks like Flask or Django in combination with WSGI servers like Gunicorn. This setup provides flexibility and control, but requires manual management of scalability, load balancing, and failover mechanisms.\nCloud Deployment: Now, we‚Äôre talking major festival level. Your model gets the flexibility and power of cloud resources, scaling up and down with ease. Cloud deployment is the go-to solution for applications requiring high availability and scalability. Cloud platforms like AWS SageMaker, Azure Machine Learning, and Google AI Platform offer managed services for deploying and scaling models effortlessly.\nWith cloud deployment, you can leverage features like auto-scaling, load balancing, and continuous integration/continuous deployment (CI/CD) pipelines to ensure your model is always available and up-to-date. Additionally, cloud providers offer a variety of instance types, allowing you to choose the best resources for your model‚Äôs needs.\nEdge Deployment: Think of it as a secret pop-up concert. Models are deployed closer to where the action happens, reducing latency and bandwidth use. Edge deployment is ideal for applications requiring real-time inference or operating in environments with limited connectivity.\nEdge devices, such as IoT devices, smartphones, or embedded systems, can run machine learning models using frameworks like TensorFlow Lite or ONNX Runtime. This approach minimizes data transmission to central servers, reducing latency and improving privacy and security. Edge deployment is popular in industries like autonomous vehicles, healthcare, and smart cities.\n\n\n1.3. Introduction to Containerization with Docker\nEnter Docker, the magical tour bus for your model, ensuring it arrives at each destination ready to rock without missing a beat. Containerization has revolutionized the way applications are developed, shipped, and deployed, offering a standardized approach to packaging applications and their dependencies.\n\n\n\nWhat is Docker? Docker is like your model‚Äôs private dressing room, encapsulating all its dependencies, libraries, and code into a neat package called a ‚Äúcontainer.‚Äù This ensures that wherever your model goes, it performs consistently. Containers are lightweight, portable, and can run on any machine that supports Docker, eliminating the ‚Äúworks on my machine‚Äù problem.\nDocker containers are built from images, which are read-only templates describing how to create a container. These images can be shared and versioned, making it easy to distribute and update your application.\nWhy Docker?\n\nPortability: Containers are like your model‚Äôs passport, allowing it to travel seamlessly across different environments. Docker ensures your application runs the same way on a developer‚Äôs laptop, a test server, or a production cloud environment.\nConsistency: Just as a band needs the same instruments wherever they play, Docker ensures your model has everything it needs. Containers include all dependencies, libraries, and configuration files required to run an application, ensuring consistency across deployments.\nEfficiency: Docker containers are lightweight, meaning you can run multiple containers on a single machine without hogging resources. Unlike traditional virtual machines, containers share the host system‚Äôs kernel, reducing overhead and improving resource utilization.\nIsolation: Just as each band member needs their space, Docker provides isolated environments, ensuring no conflicts between models. Containers run in their own isolated environment, preventing interference from other applications or processes on the host system.\n\nBuilding a Docker Image: To create a Docker image, you need to write a Dockerfile, which is a plain text file containing instructions on how to build the image. Here‚Äôs a simple example of a Dockerfile for a Python application:\n# Use an official Python runtime as a parent image\nFROM python:3.8-slim\n\n# Set the working directory in the container\nWORKDIR /app\n\n# Copy the current directory contents into the container at /app\nCOPY . /app\n\n# Install any needed packages specified in requirements.txt\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Make port 80 available to the world outside this container\nEXPOSE 80\n\n# Define environment variable\nENV NAME World\n\n# Run app.py when the container launches\nCMD [\"python\", \"app.py\"]\nThis Dockerfile specifies a base image (python:3.8-slim), sets up a working directory, copies the application code, installs dependencies, exposes a port, and defines the command to run the application.\n\n\n1.4. Benefits of Using Docker for Deployment\nUsing Docker for deployment is akin to having a trusted roadie crew‚Äîeverything runs smoother, faster, and with less hassle. Docker offers several benefits that make it an ideal choice for deploying machine learning models/\n\n\n\nKey Benefits:\n\nIsolation: Just as each band member needs their space, Docker provides isolated environments, ensuring no conflicts between models. Containers run in their own sandbox, separated from the host system and other containers, preventing interference from other applications or processes. This isolation also enhances security by limiting the attack surface and potential vulnerabilities.\nReproducibility: Docker guarantees that ‚Äúwhat happens in rehearsal stays in rehearsal,‚Äù meaning your model will work anywhere it‚Äôs deployed. This reproducibility is crucial for machine learning workflows, as it ensures that the same environment used during development and testing is preserved in production. By encapsulating all dependencies and configurations in a Docker image, you can easily share and replicate your setup across different machines or teams.\nScalability: When your model‚Äôs performance becomes a hit, Docker allows you to scale up effortlessly, ensuring it reaches audiences far and wide. Docker containers can be deployed and managed using orchestration tools like Kubernetes, which automates the scaling, distribution, and management of containerized applications. This enables you to efficiently handle varying workloads by adding or removing containers based on demand.\nSimplified Management: Docker streamlines the deployment process, letting you focus on the music (or in this case, the model). With Docker, you can use a single command to build, ship, and run your application, simplifying the deployment pipeline and reducing the risk of errors. Additionally, Docker Hub, a cloud-based registry service, allows you to store and distribute your images, making it easy to manage updates and versioning.\nResource Efficiency: Docker containers are lightweight and share the host system‚Äôs kernel, allowing you to run multiple containers on a single machine without incurring the overhead of traditional virtual machines. This efficient use of resources reduces infrastructure costs and improves performance, especially in environments with limited hardware capacity.\nCross-Platform Compatibility: Docker containers can run on any system that supports Docker, regardless of the underlying operating system. This cross-platform compatibility ensures that your application behaves consistently across different environments, from local development machines to cloud servers and edge devices.\n\nReal-World Applications of Docker:\nDocker is widely used across various industries to streamline the deployment and management of machine learning models. Here are a few examples:\n\nFinTech: Financial technology companies use Docker to deploy models for fraud detection, risk assessment, and automated trading. Docker‚Äôs isolation and security features ensure that sensitive data and algorithms are protected, while its scalability allows for real-time processing of large volumes of financial transactions.\nHealthcare: In healthcare, Docker enables the deployment of models for medical imaging analysis, predictive diagnostics, and personalized treatment recommendations. By using containers, healthcare providers can ensure compliance with data privacy regulations and easily share models across different hospitals and research institutions.\nE-commerce: E-commerce platforms leverage Docker to deploy recommendation engines, customer segmentation models, and demand forecasting algorithms. Docker‚Äôs resource efficiency and scalability allow these platforms to handle peak traffic during sales events and provide personalized experiences to millions of users.\nAutonomous Vehicles: The automotive industry uses Docker to deploy machine learning models for autonomous driving, object detection, and route planning. Docker‚Äôs portability and cross-platform compatibility facilitate testing and deployment across various hardware and software configurations, accelerating the development of self-driving technologies.",
    "crumbs": [
      "Lectures",
      "3. Deployment and Production Considerations"
    ]
  },
  {
    "objectID": "00_Lectures/03_Lecture.html#getting-started-with-docker",
    "href": "00_Lectures/03_Lecture.html#getting-started-with-docker",
    "title": "Lecture 3 - Deployment and Production Considerations",
    "section": "2. Getting Started with Docker",
    "text": "2. Getting Started with Docker\n\n2.1. Installing and Configuring Docker\nBefore we can start containerizing applications, we need to install Docker on our system.\nDocker provides a seamless installation process across various platforms, including Windows, macOS, and Linux.\nHere‚Äôs a comprehensive guide on installing Docker across different platforms and ensuring it‚Äôs ready for containerizing applications:\n\n\nInstalling Docker\nBefore diving into containerization, you need to install Docker on your system. Docker offers a straightforward installation process across various operating systems, including Windows, macOS, and Linux.\n\n\nInstallation Steps\n\n1. Docker Desktop (Windows & macOS)\nFor users on Windows and macOS, Docker Desktop is the most convenient option. It provides a graphical user interface (GUI) and integrates seamlessly with your system for efficient container management.\n\nDownload: Visit the official Docker website to download Docker Desktop.\nInstallation:\n\nFollow the installation instructions provided on the website.\nDuring the installation, you may need to enable WSL 2 (Windows Subsystem for Linux) for Windows users, as this is required for Docker to run smoothly.\n\n\n\n\n2. Linux Installation\nFor Linux users, Docker can be installed using package managers specific to your distribution.\n\nUbuntu:\nsudo apt update\nsudo apt install apt-transport-https ca-certificates curl software-properties-common\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\nsudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\nsudo apt update\nsudo apt install docker-ce\nCentOS:\nsudo yum install -y yum-utils\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\nsudo yum install docker-ce\nFor detailed installation instructions for different Linux distributions, refer to the official Docker documentation.\n\n\n\n3. Configuration\nAfter installation, you may need to configure Docker to suit your development environment:\n\nStart Docker on Boot: Ensure Docker starts automatically when your system boots up.\nNetwork Settings: Configure any specific network settings as required for your applications.\nUser Permissions: Manage user permissions to allow specific users to run Docker commands without needing sudo.\n\nYou can find guidance on these configurations in the Docker documentation.\n\n\n4. Verify Installation\nOnce you‚Äôve completed the installation, it‚Äôs important to verify that Docker is working correctly:\n\nOpen your terminal and run the following command:\ndocker --version\nIf Docker is installed properly, this command will display the installed Docker version, confirming that Docker is ready for use.\n\n\n\n\n2.2. Key Concepts: Images, Containers, Dockerfile\nUnderstanding Docker‚Äôs core concepts is crucial for effectively using this powerful tool. Let‚Äôs break down these concepts:\nImages: Docker images are the blueprints for containers. They contain everything needed to run an application, including the code, runtime, libraries, and environment variables. Images are built from a set of instructions defined in a Dockerfile and can be shared via Docker Hub or private registries.\nContainers: Containers are the running instances of Docker images. They encapsulate an application and its environment, ensuring consistent behavior across different systems. Containers are lightweight and can be started, stopped, and scaled independently, making them ideal for microservices architectures.\nDockerfile: A Dockerfile is a text file containing a series of instructions on how to build a Docker image. It specifies the base image, application code, dependencies, and any additional configuration needed. Writing a Dockerfile is the first step in containerizing an application.\n\n\n2.3. Creating a Simple Docker Image for a FastAPI Application\nLet‚Äôs create a simple Docker image for a FastAPI application. This hands-on example will guide you through the process of writing a Dockerfile and building an image.\nStep-by-Step Guide:\n\nCreate a FastAPI Application: Start by creating a simple FastAPI application. For this example, we‚Äôll use a basic FastAPI app:\n\n# app.py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def read_root():\n    return {\"Hello\": \"Docker\"}\n\nWrite a Dockerfile: Create a Dockerfile in the same directory as your FastAPI application. Here‚Äôs a simple example:\n\n# Use an official Python runtime as a parent image\nFROM python:3.8-slim\n\n# Set the working directory in the container\nWORKDIR /app\n\n# Copy the current directory contents into the container at /app\nCOPY . /app\n\n# Install FastAPI and Uvicorn\nRUN pip install --no-cache-dir fastapi uvicorn\n\n# Make port 80 available to the world outside this container\nEXPOSE 80\n\n# Run app.py when the container launches\nCMD [\"uvicorn\", \"app:app\", \"--host\", \"0.0.0.0\", \"--port\", \"80\"]\n\nBuild the Docker Image: Open your terminal, navigate to the directory containing the Dockerfile, and run the following command to build the image:\n\ndocker build -t my-fastapi-app .\nThis command tells Docker to build an image named my-fastapi-app using the current directory as the build context.\n\nVerify the Image: Once the build is complete, verify that the image was created successfully by running:\n\ndocker images\nYou should see my-fastapi-app listed among the available images.\n\n\n2.4. Running and Managing Docker Containers\nNow that we have a Docker image, let‚Äôs run it as a container and explore how to manage it.\nRunning a Container:\n\nStart the Container: Use the docker run command to start a container from the image we just built:\n\ndocker run -d -p 4000:80 my-fastapi-app\nThis command runs the container in detached mode (-d) and maps port 4000 on your host to port 80 in the container, allowing you to access the application via http://localhost:4000.\n\nVerify the Container: Check that the container is running by listing all active containers:\n\ndocker ps\nYou should see my-fastapi-app in the list, along with its container ID and status.\nManaging Containers:\n\nStopping a Container: To stop a running container, use the docker stop command followed by the container ID or name:\n\ndocker stop &lt;container_id&gt;\n\nRemoving a Container: Once a container is stopped, you can remove it using the docker rm command:\n\ndocker rm &lt;container_id&gt;\n\nViewing Logs: To view the logs of a running container, use the docker logs command:\n\ndocker logs &lt;container_id&gt;\nThis is useful for debugging and monitoring your application‚Äôs output.\n\nAccessing a Container‚Äôs Shell: If you need to interact with a container‚Äôs file system or execute commands inside it, use the docker exec command to open a shell session:\n\ndocker exec -it &lt;container_id&gt; /bin/bash",
    "crumbs": [
      "Lectures",
      "3. Deployment and Production Considerations"
    ]
  },
  {
    "objectID": "00_Lectures/03_Lecture.html#dockerizing-a-machine-learning-application",
    "href": "00_Lectures/03_Lecture.html#dockerizing-a-machine-learning-application",
    "title": "Lecture 3 - Deployment and Production Considerations",
    "section": "3. Dockerizing a Machine Learning Application",
    "text": "3. Dockerizing a Machine Learning Application\n\n3.1 Introduction to the Example Machine Learning Application (Boston Housing Pricing)\nImagine you‚Äôre a real estate wizard üßô, and you have a magical tool that can predict house prices in Boston based on various features.\nThat‚Äôs exactly what we‚Äôre building‚Äîa machine learning model that predicts housing prices. But we‚Äôre not stopping there! We‚Äôll wrap this model in a FastAPI application so others can use it to make predictions.\nThink of it as building a crystal ball üîÆ that anyone can access via the internet!\n\n\n3.1.1 About the Boston Housing Dataset\n\nDataset: Contains information about Boston house prices, such as crime rate, number of rooms, and distance to employment centers.\nGoal: Predict the median value of owner-occupied homes (in $1000‚Äôs) based on these features.\n\n\n\n\nProject Structure\nLet‚Äôs outline the structure of our project:\nboston_housing_app/\n‚îú‚îÄ‚îÄ app.py\n‚îú‚îÄ‚îÄ model.joblib\n‚îú‚îÄ‚îÄ requirements.txt\n‚îú‚îÄ‚îÄ Dockerfile\n‚îî‚îÄ‚îÄ README.md\n\n\n3.1.2 Training the Machine Learning Model\nFirst, we‚Äôll train our model and save it for later use in our FastAPI app.\n# train_model.py\nimport pandas as pd\nfrom sklearn.datasets import load_boston\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nimport joblib\n\n# Load the dataset\nboston = load_boston()\nX = pd.DataFrame(boston.data, columns=boston.feature_names)\ny = boston.target\n\n# Split the data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Train the model\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# Save the model\njoblib.dump(model, 'model.joblib')\nprint(\"Model trained and saved!\")\nüî•Explanation: We load the dataset, split it, train a Linear Regression model, and save it using joblib.\nRun the Training Script\npython train_model.py\nAfter running this script, you‚Äôll have a model.joblib file saved in your directory.\n\n\n\n3.1.3 Building the FastAPI Application\nNow, let‚Äôs create a FastAPI application that loads this model and provides an endpoint to make predictions.\nAdd fastapi and uvicorn to your requirements.txt:\n# requirements.txt\nfastapi\nuvicorn[standard]\npandas\nscikit-learn\njoblib\n# app.py\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\nimport joblib\nimport pandas as pd\n\n# Initialize the app\napp = FastAPI(title=\"Boston Housing Price Prediction API\")\n\n# Load the model\nmodel = joblib.load('model.joblib')\n\n# Define the request body\nclass PredictionRequest(BaseModel):\n    CRIM: float\n    ZN: float\n    INDUS: float\n    CHAS: float\n    NOX: float\n    RM: float\n    AGE: float\n    DIS: float\n    RAD: float\n    TAX: float\n    PTRATIO: float\n    B: float\n    LSTAT: float\n\n# Define the response\nclass PredictionResponse(BaseModel):\n    price: float\n\n# Root path\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Welcome to the Boston Housing Price Prediction API!\"}\n\n# Prediction endpoint\n@app.post(\"/predict\", response_model=PredictionResponse)\ndef predict(request: PredictionRequest):\n    data = request.dict()\n    df = pd.DataFrame([data])\n    prediction = model.predict(df)[0]\n    return {\"price\": prediction}\nüî•Explanation:\n\nFastAPI App: We initialize a FastAPI app.\nModel Loading: We load the pre-trained model.\nRequest and Response Models: Using Pydantic‚Äôs BaseModel to define the expected input and output data structures.\nEndpoints:\n\nGET /: A welcome message.\nPOST /predict: Accepts house features and returns the predicted price.\n\n\nRunning the FastAPI App Locally\nTo run the app locally, you can use Uvicorn:\nuvicorn app:app --host 0.0.0.0 --port 8000\nOpen your browser and navigate to http://localhost:8000/docs to see the interactive API docs provided by FastAPI! üéâ\n\n\n\n3.2 Creating a Dockerfile for the Application\nNow that we have our FastAPI app ready, let‚Äôs containerize it using Docker so we can deploy it anywhere.\n\n3.2.1 Understanding the Dockerfile\nA Dockerfile is like a recipe for creating a Docker image. It tells Docker what base image to use, what files to copy, what commands to run, and which ports to expose.\nWriting the Dockerfile\n# Dockerfile\n\n# Use an official Python runtime as a parent image\nFROM python:3.9-slim\n\n# Set the working directory in the container\nWORKDIR /app\n\n# Copy the requirements file into the container\nCOPY requirements.txt .\n\n# Install dependencies\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy the rest of the code into the container\nCOPY . .\n\n# Expose port 8000\nEXPOSE 8000\n\n# Run the application\nCMD [\"uvicorn\", \"app:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n\n\n3.2.2 Explanation of the Dockerfile\n\nFROM python:3.9-slim: We start from a slim version of Python 3.9 to keep the image lightweight.\nWORKDIR /app: Sets the working directory inside the container to /app.\nCOPY requirements.txt .: Copies requirements.txt into the container.\nRUN pip install --no-cache-dir -r requirements.txt: Installs the dependencies without caching to save space.\nCOPY . .: Copies all files from the current directory into the container.\nEXPOSE 8000: Exposes port 8000 for the app.\nCMD [...]: The command to run when the container starts. Here, we start the Uvicorn server.\n\n\n\n\n\n3.3 Defining Dependencies and Configurations\nDependencies are crucial. They ensure that our application has everything it needs to run correctly inside the container.\n\n3.3.1 The requirements.txt File\nWe‚Äôve already defined our dependencies in the requirements.txt file:\nfastapi\nuvicorn[standard]\npandas\nscikit-learn\njoblib\n\n\n3.3.2 Environment Variables (Optional)\nIf your application requires environment variables (like API keys, database URLs), you can define them in the Dockerfile using ENV or pass them at runtime.\nExample in Dockerfile:\nENV MODEL_NAME=\"Boston Housing Predictor\"\nIn app.py, you can access it:\nimport os\n\nmodel_name = os.getenv(\"MODEL_NAME\", \"Default Model\")\nBut be cautious! For sensitive information like API keys, it‚Äôs better to pass them at runtime or use Docker secrets.\n\n\n\n\n3.4 Exposing Ports and Setting the Run Command\nExposing ports is like opening the door üö™ of your container to the outside world so that others can interact with your application.\n\n3.4.1 Exposing Ports\nIn the Dockerfile:\nEXPOSE 8000\nThis tells Docker that the container listens on port 8000 during runtime.\n\n\n3.4.2 Setting the Run Command\nThe CMD instruction specifies the command to run when the container starts:\nCMD [\"uvicorn\", \"app:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n\nuvicorn app:app: Runs the app object from app.py using Uvicorn.\n--host 0.0.0.0: Makes the server accessible externally.\n--port 8000: Runs the server on port 8000.\n\n\n\n\n\n3.5 Building and Running the Docker Container\nTime to bring everything together and see the magic happen! üé©‚ú®\n\n3.5.1 Build the Docker Image\nIn your terminal, navigate to the project directory and run:\ndocker build -t boston-housing-api .\n\ndocker build: Builds an image from a Dockerfile.\n-t boston-housing-api: Tags the image with the name boston-housing-api.\n.: Specifies the build context (current directory).\n\n\n\n3.5.2 Run the Docker Container\ndocker run -d -p 8000:8000 boston-housing-api\n\n-d: Runs the container in detached mode (in the background).\n-p 8000:8000: Maps port 8000 of your local machine to port 8000 of the container.\nboston-housing-api: The name of the image to run.\n\n\n\n3.5.3 Verify the Application is Running\nOpen your browser and go to http://localhost:8000/docs. You should see the interactive API documentation.\n\nClick on the /predict endpoint.\nClick Try it out.\nEnter sample data. For example:\n\n{\n  \"CRIM\": 0.1,\n  \"ZN\": 18.0,\n  \"INDUS\": 2.31,\n  \"CHAS\": 0.0,\n  \"NOX\": 0.538,\n  \"RM\": 6.575,\n  \"AGE\": 65.2,\n  \"DIS\": 4.09,\n  \"RAD\": 1.0,\n  \"TAX\": 296.0,\n  \"PTRATIO\": 15.3,\n  \"B\": 396.9,\n  \"LSTAT\": 4.98\n}\n\nClick Execute.\nYou should receive a predicted price in the response!\n\n\n\n\n\n3.6 Deploying the Docker Image\nNow that our application is containerized, we can deploy it anywhere Docker is supported‚Äîbe it a cloud service like AWS, Azure, Google Cloud, or even on a Raspberry Pi! Let‚Äôs go over a simple deployment to a cloud service.\n\n\n\n\n\n3.6.1 Deploy to Heroku (Using Container Registry)\nHeroku is a cloud platform that supports Docker deployments via its Container Registry.\nPrerequisites:\n\nInstall the Heroku CLI.\nCreate a Heroku account.\n\nSteps:\n\nLogin to Heroku Container Registry:\nheroku login\nheroku container:login\nCreate a New Heroku App:\nheroku create boston-housing-api-app\nPush the Docker Image to Heroku:\nheroku container:push web -a boston-housing-api-app\nRelease the Image:\nheroku container:release web -a boston-housing-api-app\nOpen the App:\nheroku open -a boston-housing-api-app\n\nNow your API is live on the internet! üåê\n\n\n3.6.2 Deploy to AWS Elastic Container Service (ECS)\nDeploying to AWS ECS involves more steps but offers robust scalability.\nHigh-Level Steps:\n\nCreate a Docker Repository in Amazon Elastic Container Registry (ECR).\nPush Your Docker Image to ECR.\nCreate a Task Definition in ECS using your image.\nRun a Service with the task definition.\nSet Up a Load Balancer to route traffic to your service.\n\nDue to the complexity, consider following AWS‚Äôs detailed documentation or use AWS Fargate for serverless container deployment.\n\n\nRecap and Project Structure\nLet‚Äôs revisit our project structure:\nboston_housing_app/\n‚îú‚îÄ‚îÄ app.py\n‚îú‚îÄ‚îÄ model.joblib\n‚îú‚îÄ‚îÄ requirements.txt\n‚îú‚îÄ‚îÄ Dockerfile\n‚îú‚îÄ‚îÄ train_model.py\n‚îî‚îÄ‚îÄ README.md\n\napp.py: The FastAPI application.\nmodel.joblib: The saved machine learning model.\nrequirements.txt: Lists all Python dependencies.\nDockerfile: Instructions to build the Docker image.\ntrain_model.py: Script to train and save the model.\nREADME.md: Documentation for your project.",
    "crumbs": [
      "Lectures",
      "3. Deployment and Production Considerations"
    ]
  },
  {
    "objectID": "00_Lectures/03_Lecture.html#introduction-to-github-actions",
    "href": "00_Lectures/03_Lecture.html#introduction-to-github-actions",
    "title": "Lecture 3 - Deployment and Production Considerations",
    "section": "4. Introduction to GitHub Actions",
    "text": "4. Introduction to GitHub Actions\nThe goal of this section is to introduce you to the powerful world of Continuous Integration (CI) and Continuous Delivery (CD). By the end of this chapter, you‚Äôll have a fully automated pipeline, pushing your FastAPI app from your codebase straight to production (we‚Äôll use Heroku as an example deployment platform).\nBut don‚Äôt let the technical jargon scare you‚ÄîGitHub Actions is just like setting up a bunch of automated robot assistants to take care of the nitty-gritty, so you can focus on coding cool stuff!\n\n4.1 Principles of Continuous Integration and Continuous Delivery (CI/CD)\nLet‚Äôs start with the big picture: CI/CD.\nThese are the magic words behind modern software development.\nIt‚Äôs what allows big companies like Google and Netflix to deploy thousands of changes every day. So, what are they?\n\n4.1.1 Continuous Integration (CI)\nThink of CI as your safety net.\nIt‚Äôs the practice of automatically testing and integrating small changes into your codebase.\nImagine you‚Äôre writing your FastAPI app and every time you push your code to GitHub, all your tests automatically run.\nIf something breaks, you get notified instantly, instead of finding out when the app is already deployed (which we all know is a nightmare).\nKey Benefits of CI:\n\nInstant feedback: CI helps catch bugs early.\nStable codebase: Your main branch is always deployable.\nDeveloper collaboration: Multiple people can work on the same codebase without conflicts.\n\n\n\n4.1.2 Continuous Delivery (CD)\nCD is the natural extension of CI. It automates the release process so that your application is always in a deployable state. With CD, once your code passes the tests, it‚Äôs automatically pushed to a staging or production environment‚Äîwithout any manual steps.\nKey Benefits of CD:\n\nFrequent releases: You can deploy to production multiple times a day.\nFewer bugs: Smaller, more frequent releases mean less complexity.\nImproved confidence: Developers are less afraid of deploying code since it‚Äôs automated and tested.\n\n\n\n\n4.2 Overview of GitHub Actions and Its Components\nNow that you‚Äôre familiar with CI/CD, let‚Äôs talk about GitHub Actions‚Äîyour tool to automate everything from running tests to deploying applications. GitHub Actions are workflows that are triggered by events like a pull request, a new commit, or even a scheduled time.\n**Key Components of GitHub Actions:\n\nWorkflow: A series of actions (tasks) defined in YAML format that runs when a specific event occurs.\nEvent: The trigger that starts the workflow (e.g., a push to the repository, a pull request).\nJob: A workflow contains one or more jobs. A job contains multiple steps and runs on its own virtual machine or container.\nStep: A step can be a shell command, a script, or a reusable action. Multiple steps make up a job.\nAction: A predefined task that can be used in steps (e.g., actions/checkout@v2 checks out your code).\n\nThink of GitHub Actions as your very own robot assistants (like WALL-E) that automatically clean up after you every time you make a mess (push code). Each assistant (job) has its own task (test the app, create a Docker image, deploy it), and they all report back to you when their tasks are done.\n\n\n4.3 Creating a Basic GitHub Actions Workflow\nLet‚Äôs dive into the fun part‚Äîcreating our first CI pipeline using GitHub Actions. We‚Äôll start by setting up a workflow that runs tests on our FastAPI app whenever we push changes to GitHub.\n\n4.3.1 Step 1: Creating the Workflow File\nYou‚Äôll need to create a file in your repository at .github/workflows/ci.yml. GitHub will automatically detect this file and run the instructions inside whenever the specified events occur.\nHere‚Äôs a simple workflow that: - Triggers on every push and pull_request to the main branch. - Runs a set of Python unit tests.\nname: CI for FastAPI Application\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.9'\n\n      - name: Install dependencies\n        run: |\n          pip install -r requirements.txt\n\n      - name: Run tests\n        run: |\n          pytest\n\n\n4.3.2 Breakdown of Workflow\n\non: This defines when the workflow will be triggered. In our case, it will trigger on a push or a pull_request to the main branch.\njobs: Defines what jobs will run. Here we have a test job that runs on ubuntu-latest (a virtual machine provided by GitHub).\nsteps: Steps are the individual tasks for each job. In this case, we:\n\nCheckout the code using actions/checkout@v2.\nSet up Python 3.9 using actions/setup-python@v2.\nInstall dependencies from the requirements.txt file.\nRun tests using pytest.\n\n\nThis is your basic CI pipeline. Each time you push code, it automatically runs tests, letting you know if anything is broken before you deploy. Easy-peasy!\n\n\n\n4.4 Defining Triggers and Jobs for Deployment\nNow, let‚Äôs go a step further. Testing is important, but what if you could deploy your app every time your tests pass? Enter CD.\nWe‚Äôll now define a trigger that not only runs tests but also deploys our FastAPI app.\nHere‚Äôs how you do it:\nname: CI/CD for FastAPI Application\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.9'\n\n      - name: Install dependencies\n        run: |\n          pip install -r requirements.txt\n\n      - name: Run tests\n        run: |\n          pytest\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: test  # Ensures deploy only runs if the tests pass\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Deploy to Heroku\n        run: |\n          heroku login\n          git push heroku main\nüî•Explanation:\n\ndeploy job: Runs after the test job (needs: test ensures that deployment only happens if tests pass).\nDeploy to Heroku: Uses git push heroku main to deploy the application.\n\n\n\n4.5 Creating a Deployment Workflow for Heroku\nNow let‚Äôs build a dedicated deployment workflow for Heroku using GitHub Actions. We‚Äôll assume you already have a Heroku account and a deployed FastAPI app.\n\n4.5.1 Setup Heroku CLI\nBefore running the deployment commands, ensure you install the Heroku CLI:\n- name: Install Heroku CLI\n  run: curl https://cli-assets.heroku.com/install.sh | sh\n\n\n4.5.2 Authenticating Heroku in GitHub Actions\nYou‚Äôll need to authenticate GitHub Actions to access your Heroku app. For this, we‚Äôll use Heroku API keys (don‚Äôt worry, we‚Äôll cover how to keep these secure in the next section).\n- name: Authenticate Heroku\n  env:\n    HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}\n  run: |\n    echo \"machine api.heroku.com\" &gt; ~/.netrc\n    echo \"  login ${{ secrets.HEROKU_EMAIL }}\" &gt;&gt; ~/.netrc\n    echo \"  password ${{ secrets.HEROKU_API_KEY }}\" &gt;&gt; ~/.netrc\nThis authentication step uses the Heroku API Key and email (stored securely in GitHub Secrets‚Äîmore on this soon).\n\n\n4.5.3 Deploy Your FastAPI App\nThe final step is to deploy your app with Heroku:\n- name: Deploy to Heroku\n  run: git push heroku main\n\n\n\n4.6 Using Secrets for Sensitive Information\nWe‚Äôve mentioned GitHub Secrets, which is how we securely store sensitive information like API keys, credentials, or access tokens.\n\nGo to your repository on GitHub.\nNavigate to Settings -&gt; Secrets -&gt; Actions.\nAdd the following secrets:\n\nHEROKU_API_KEY: Your Heroku API key.\nHEROKU_EMAIL: The email associated with your Heroku account.\n\n\nNow, your workflow can use these secrets securely by referencing them as secrets.HEROKU_API_KEY and secrets.HEROKU_EMAIL.",
    "crumbs": [
      "Lectures",
      "3. Deployment and Production Considerations"
    ]
  },
  {
    "objectID": "00_Lectures/03_Lecture.html#advanced-tools-and-technologies",
    "href": "00_Lectures/03_Lecture.html#advanced-tools-and-technologies",
    "title": "Lecture 3 - Deployment and Production Considerations",
    "section": "5. Advanced Tools and Technologies",
    "text": "5. Advanced Tools and Technologies\nWelcome to the final chapter of your FastAPI journey!\nAt this point, you‚Äôve learned how to build, containerize, and deploy your machine learning app using Docker, GitHub Actions, and Heroku. Now, let‚Äôs explore the next level of deployment tools and technologies.\nThis is where you unlock the door to scalability, flexibility, and enterprise-grade cloud infrastructure.\n\n5.1 Exploring Other Cloud Platforms for Deployment (AWS, GCP, Azure)\nIn the previous section, we deployed our FastAPI app to Heroku‚Äîa popular platform for fast deployments. But, as your app grows, you might need more flexibility and control over the infrastructure. That‚Äôs where the big players‚ÄîAWS, GCP, and Azure‚Äîcome into play. These platforms offer a wide range of services tailored for enterprise applications.\n\nAWS (Amazon Web Services)\nAmazon Web Services is the largest cloud provider in the world. AWS has Elastic Beanstalk, which simplifies deploying FastAPI apps. It abstracts much of the underlying infrastructure, but if you need full control, you can use EC2 instances, S3 for storage, and RDS for databases.\nHere‚Äôs how you can deploy a FastAPI app using AWS Elastic Beanstalk:\n\nInstall the AWS CLI:\npip install awsebcli\nInitialize Your Application: Inside your project directory:\neb init -p python-3.8 fastapi-app --region &lt;your-region&gt;\nCreate and Deploy the Application:\neb create fastapi-env\neb deploy\n\nAWS gives you deep control over the configuration, security, and scaling of your application, which is perfect for enterprise-scale apps.\n\n\nGoogle Cloud Platform (GCP)\nGCP offers App Engine, Compute Engine, and Cloud Run for deploying FastAPI applications. App Engine is the easiest way to deploy apps without managing servers, while Cloud Run allows you to deploy containerized applications.\nDeploying your FastAPI app using Google App Engine:\n\nInstall the Google Cloud SDK:\ncurl https://sdk.cloud.google.com | bash\nCreate the App Engine Configuration File (app.yaml):\nruntime: python38\nentrypoint: uvicorn main:app --host 0.0.0.0 --port $PORT\nDeploy the Application:\ngcloud app deploy\n\nGCP is known for its powerful machine learning services and data analytics tools, making it a great choice for apps that require heavy data processing.\n\n\nAzure\nAzure App Service and Azure Kubernetes Service (AKS) are the primary deployment platforms in the Microsoft cloud ecosystem. Azure App Service simplifies the deployment process while AKS offers enterprise-grade scalability for containerized applications.\nSteps to deploy using Azure App Service:\n\nInstall the Azure CLI:\naz login\nCreate an App Service Plan and Web App:\naz webapp up --runtime \"PYTHON:3.8\" --name &lt;app-name&gt;\nDeploy the Application: Simply push your changes to the web app using Git or the Azure CLI.\n\nAzure offers deep integration with Microsoft‚Äôs other tools and services, which is useful if you‚Äôre working in an enterprise environment already using Microsoft products.\n\n\n\n5.2 Using Container Orchestration Tools like Kubernetes\nDeploying individual Docker containers is great, but what if you want to scale up? That‚Äôs where Kubernetes comes into play. Kubernetes is the king of container orchestration. It helps you manage, scale, and maintain containerized applications across multiple servers (nodes).\nImagine Kubernetes as the traffic manager of your container city. It ensures that all traffic goes to the right containers (pods), scales the number of containers up or down based on demand, and keeps everything running smoothly.\n\nWhy Use Kubernetes?\n\nScalability: Kubernetes automatically scales your application based on the number of requests.\nSelf-Healing: If one of your containers crashes, Kubernetes automatically restarts it.\nLoad Balancing: Kubernetes balances traffic across your containers so no one pod is overwhelmed.\nDeployment Rollbacks: You can easily roll back to a previous version if something goes wrong.\n\n\n\nDeploying FastAPI on Kubernetes\nHere‚Äôs a basic overview of how to get your FastAPI app running on Kubernetes:\n\nCreate a Docker Image for your FastAPI app (we‚Äôve done this earlier).\nCreate a Kubernetes Deployment:\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: fastapi-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: fastapi\n  template:\n    metadata:\n      labels:\n        app: fastapi\n    spec:\n      containers:\n      - name: fastapi-container\n        image: &lt;your-docker-image&gt;\n        ports:\n        - containerPort: 80\nCreate a Service to expose your app to the internet:\napiVersion: v1\nkind: Service\nmetadata:\n  name: fastapi-service\nspec:\n  selector:\n    app: fastapi\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 80\n  type: LoadBalancer\nDeploy on Kubernetes:\nkubectl apply -f deployment.yaml\nkubectl apply -f service.yaml\n\nYou can deploy Kubernetes clusters on AWS (EKS), GCP (GKE), or Azure (AKS), giving you the power to scale across the cloud.\n\n\n\n5.3 Integrating with Managed Machine Learning Services\nAs data professionals, one of the coolest things you can do is integrate your FastAPI app with managed machine learning services. These cloud services take care of the heavy lifting, allowing you to scale and deploy machine learning models seamlessly.\n\nWhy Use Managed ML Services?\n\nSimplified Infrastructure: You don‚Äôt have to worry about setting up complex machine learning environments.\nAuto-Scaling: Cloud providers automatically scale your ML models based on usage.\nIntegrations: These platforms come with tools for deploying, monitoring, and managing models in production.\n\nLet‚Äôs look at how you can integrate with the big three: AWS, GCP, and Azure.\n\n\nAWS SageMaker\nSageMaker is AWS‚Äôs fully managed machine learning service. You can build, train, and deploy ML models directly from SageMaker, and integrate the deployed model into your FastAPI app.\nSteps to integrate SageMaker with FastAPI: 1. Train and Deploy Your Model on SageMaker. ```python import sagemaker from sagemaker import get_execution_role\n# Define the session and role session = sagemaker.Session() role = get_execution_role()\n# Train a model estimator = sagemaker.estimator.Estimator(‚Ä¶) estimator.fit(‚Ä¶)\n# Deploy the model predictor = estimator.deploy(initial_instance_count=1, instance_type=‚Äòml.m4.xlarge‚Äô) ```\n\nInvoke the Model from FastAPI: You can invoke the deployed model in your FastAPI app using the SageMaker Runtime API:\nimport boto3\n\n@app.post(\"/predict\")\ndef predict(data: YourDataSchema):\n    sagemaker_client = boto3.client('sagemaker-runtime')\n    response = sagemaker_client.invoke_endpoint(\n        EndpointName='&lt;your-endpoint&gt;',\n        ContentType='application/json',\n        Body=json.dumps(data.dict())\n    )\n    return response\n\n\n\nGoogle AI Platform\nGCP‚Äôs AI Platform offers tools for training and serving machine learning models. You can train a model in AI Platform and deploy it to a managed endpoint.\n\nDeploy Your Model to AI Platform:\ngcloud ai-platform models create model_name\ngcloud ai-platform versions create version_name \\\n    --model model_name \\\n    --origin gs://path-to-your-model\nIntegrate with FastAPI: Use the GCP API to make predictions from your FastAPI app.\nfrom google.cloud import aiplatform\n\n@app.post(\"/predict\")\ndef predict(data: YourDataSchema):\n    client = aiplatform.gapic.PredictionServiceClient()\n    response = client.predict(endpoint='&lt;your-endpoint&gt;', ...)\n    return response\n\n\n\nAzure Machine Learning (AML)\nAzure Machine Learning (AML) is another managed service that allows you to train and deploy ML models at scale.\n\nDeploy Your Model to Azure:\naz ml model deploy -n model_name -m model.pkl --ic inference_config.json --dc deployment_config.json\nCall the Model from FastAPI:\nimport requests\n\n@app.post(\"/predict\")\ndef predict(data: YourDataSchema):\n    response = requests.post('&lt;your-aml-endpoint&gt;', json=data.dict())\n    return response.json()",
    "crumbs": [
      "Lectures",
      "3. Deployment and Production Considerations"
    ]
  },
  {
    "objectID": "00_Lectures/03_Lecture.html#in-summary",
    "href": "00_Lectures/03_Lecture.html#in-summary",
    "title": "Lecture 3 - Deployment and Production Considerations",
    "section": "In Summary",
    "text": "In Summary\nCongratulations on completing the course!üéâ\nYou‚Äôve just navigated through an exciting journey of deploying machine learning applications.\nHere‚Äôs a recap of what you‚Äôve mastered:\n\nContainerization with Docker: You learned how to package your applications into Docker containers, ensuring consistent and portable deployments across different environments.\nCI/CD Pipelines with GitHub Actions: You explored the principles of Continuous Integration and Continuous Delivery (CI/CD), leveraging GitHub Actions to automate your deployment workflows and streamline your development process.\nHeroku Deployment: You successfully deployed your applications to Heroku, making it simple to launch your projects into the cloud and manage them effortlessly.\nBest Practices for Deployment: You discovered essential best practices to optimize, scale, and secure your deployments, ensuring that your applications perform well under pressure.\nAdvanced Tools and Technologies: You explored various cloud platforms like AWS, GCP, and Azure, delved into container orchestration with Kubernetes, and integrated with managed machine learning services to enhance your applications.\n\nWith this knowledge, you are now equipped to deploy robust, scalable machine learning applications and take on any challenge in the tech universe. The journey doesn‚Äôt end here; keep experimenting, learning, and pushing the boundaries of what‚Äôs possible! üöÄ\nIt‚Äôs time to apply everything you‚Äôve learned, take your applications to the next level, and impress the world with your data science skills.\nNow, let‚Äôs dive into the Lab 3",
    "crumbs": [
      "Lectures",
      "3. Deployment and Production Considerations"
    ]
  },
  {
    "objectID": "01_Exercises/01_Lab.html",
    "href": "01_Exercises/01_Lab.html",
    "title": "Lab1 - Introduction to FastAPI & Development Setup",
    "section": "",
    "text": "In this lab, you‚Äôll set up your environment and create foundational API endpoints. Follow these steps to become proficient in building APIs using FastAPI.\nIf you have any questions or need further assistance, feel free to reach out. May the code be with you! üåå",
    "crumbs": [
      "Exercices",
      "Lab 1"
    ]
  },
  {
    "objectID": "01_Exercises/01_Lab.html#overview",
    "href": "01_Exercises/01_Lab.html#overview",
    "title": "Lab1 - Introduction to FastAPI & Development Setup",
    "section": "",
    "text": "In this lab, you‚Äôll set up your environment and create foundational API endpoints. Follow these steps to become proficient in building APIs using FastAPI.\nIf you have any questions or need further assistance, feel free to reach out. May the code be with you! üåå",
    "crumbs": [
      "Exercices",
      "Lab 1"
    ]
  },
  {
    "objectID": "01_Exercises/01_Lab.html#goals",
    "href": "01_Exercises/01_Lab.html#goals",
    "title": "Lab1 - Introduction to FastAPI & Development Setup",
    "section": "Goals",
    "text": "Goals\nBy the end of this lab, you should be able to:\n\nSet up a virtual environment for Python projects.\nInstall FastAPI and Uvicorn.\nCreate a basic FastAPI application.\nImplement path parameters in your API endpoints.\nExplore Pydantic models for data validation.\nDevelop CRUD operations for resource management.\nCustomize your FastAPI documentation.",
    "crumbs": [
      "Exercices",
      "Lab 1"
    ]
  },
  {
    "objectID": "01_Exercises/01_Lab.html#prerequisites",
    "href": "01_Exercises/01_Lab.html#prerequisites",
    "title": "Lab1 - Introduction to FastAPI & Development Setup",
    "section": "Prerequisites",
    "text": "Prerequisites\nEnsure you have Python and a terminal or command line interface available on your computer.\nYou‚Äôll be working through practical exercises, so consider how each step can be applied to real-world projects.",
    "crumbs": [
      "Exercices",
      "Lab 1"
    ]
  },
  {
    "objectID": "01_Exercises/01_Lab.html#exercises",
    "href": "01_Exercises/01_Lab.html#exercises",
    "title": "Lab1 - Introduction to FastAPI & Development Setup",
    "section": "Exercises",
    "text": "Exercises\n\n1. Environment Setup\n\nCreate and Activate a Virtual Environment\n\n\nOpen your terminal or command line interface.\nCreate a virtual environment with the following command:\n\npython3 -m venv env\nActivate the virtual environment:\nOn Linux and macOS:\nsource env/bin/activate\nOn Windows:\nenv\\Scripts\\activate\n\nInstall FastAPI and Uvicorn using pip:\n\npip install fastapi[standard]\npip install uvicorn[standard]\nVerify the installation by checking the FastAPI version:\nfastapi --version\nSave the installed packages to a requirements.txt file so others can replicate your setup:\npip freeze &gt; requirements.txt\n\n\n2. Write and Test Your First FastAPI Application\n\nCreate a new file and name it app.py. This will be your main application file.\nAt the top of your app.py file, import the FastAPI class to initialize your application.\nInitialize a FastAPI application by creating an instance of the FastAPI class. This instance will be used to define your API endpoints.\nUse the @app.get(\"/\") decorator to define a function that handles GET requests to the root path (/).\nInside the function, return a dictionary that includes a key-value pair where the key is \"message\" and the value is \"Hello World\". This will automatically be converted to a JSON response.\nOpen your terminal and navigate to the directory containing your app.py file.\nUse the following command to start the FastAPI application with Uvicorn:\n\nuvicorn app:app --reload\n\nIn this command, app:app specifies the module name (app) and the FastAPI instance (app).\nOpen a web browser and navigate to http://127.0.0.1:8000.\nYou should see a JSON response displaying {\"message\": \"Hello World\"}.\nVisit http://127.0.0.1:8000/docs to view the automatically generated documentation for your API.\n\n\n\n3. Adding Path Parameters\n\nIn your app.py file, add two new endpoints that utilize path parameters.\nCreate a function named read_message that accepts a message string parameter and returns it.\nCreate another function named read_number that accepts a number integer parameter and returns it.\nFor each endpoint, define a function that takes the path parameter as an argument. Ensure the function processes this parameter and includes it in the response.\nUse type hints (e.g., str for text, int for numbers) to specify the expected data type of each path parameter.\nUse Python‚Äôs enum module to define an Enum class.\nDefine your Enum class, PeopleName, which inherits from both str and Enum. This allows your Enum members to behave like strings.\nInside the class, define each family member as a class variable, setting its value to the respective string : ‚ÄúMarc,‚Äù ‚ÄúMarie,‚Äù and ‚ÄúJosette.‚Äù\nCreate an endpoint that accepts a path parameter of type PeopleName.\nUse the @app.get() decorator to define the endpoint path, incorporating the Enum as a path parameter.\nDefine the function get_person to handle the request, using PeopleName as the type for the path parameter.\nInside the function, use if statements to compare the parameter against Enum members and return corresponding messages.\n\n\n\n4. Data Validation with Pydantic Models\n\nSimple Model\n\n\nIn your app.py file, define a Pydantic model named User to structure incoming data.The model should include the following fields:\n\nname: a string representing the user‚Äôs name.\nemail: an email string, using Pydantic‚Äôs BaseModel and EmailStr types for validation.\nage: an integer representing the user‚Äôs age.\n\nUse the @app.post(\"/users/\") decorator to create a POST endpoint.\nImplement a function named create_user that accepts a User model instance as the request body.\nReturn a JSON response confirming the creation of the user, including the validated user data.\n\n\nNested Models\n\n\nIn your app.py file, define a BaseModel class named Address with fields for street, city, state, and zip_code.\nCreate another BaseModel class named UserWithAddress that includes fields for name (string), email (string), age (integer), and an address field of type Address to nest the address model within the user model.\nUse the @app.post(\"/users-with-address/\") decorator to define a POST endpoint.\nImplement a function named create_user_with_address that accepts a UserWithAddress model instance as the request body.\nReturn a JSON response confirming the creation of the user with the nested address data.\n\n\nUsing Default Values\n\n\nIn your app.py file, create a Pydantic model named Item with fields: name (string), price (float), and is_available (boolean) with a default value of True.\nUse the @app.post(\"/items/\") decorator to define a POST endpoint.\nImplement a function named create_item that accepts an Item model instance.\nReturn a JSON response confirming the creation of the item, including the default is_available field if not provided.\n\n\nValidating Data with Constraints\n\n\nIn your app.py file, create a Pydantic model named Product with fields: name (use constr to specify a minimum and maximum length), price (float), and quantity (integer).\nUse the @app.post(\"/products/\") decorator to define a POST endpoint.\nImplement a function named create_product that accepts a Product model instance.\nReturn a JSON response confirming the creation of the product, ensuring that the name adheres to the specified length constraints.\n\n\nUsing Lists and Optional Fields\n\n\nIn your app.py file, create a Pydantic model named Order with fields: item_name (string), quantity (integer), and an optional notes (string) field.\nCreate another model named Cart with fields: user_id (integer) and items (list of Order instances).\nUse the @app.post(\"/carts/\") decorator to define a POST endpoint.\nImplement a function named create_cart that accepts a Cart model instance.\nReturn a JSON response confirming the creation of the cart with the list of orders.\n\n\nComplex Data Types\n\n\nIn your app.py file, create a Pydantic model named Configuration with fields: setting_name (string) and value (string).\nCreate another model named System with fields: name (string) and configurations (dictionary with string keys and Configuration values).\nUse the @app.post(\"/systems/\") decorator to define a POST endpoint.\nImplement a function named create_system that accepts a System model instance.\nReturn a JSON response confirming the creation of the system with its configurations.\n\n\n\n5. Simulate a Database and Implement CRUD Operations for Cars\n\nSimulate a Database:\n\nIn your app.py file, create a dictionary named cars_db to simulate a database for storing car data.\nEnsure that each car entry is indexed by a unique identifier (e.g., an integer ID).\n\nDefine a Pydantic Model for Cars:\n\nCreate a Pydantic model named Car with the following fields:\n\nbrand: a string representing the car‚Äôs brand.\nmodel: a string representing the car‚Äôs model.\ndate: a datetime object representing the car‚Äôs manufacture date.\nprice: a float representing the car‚Äôs price.\n\n\nImplement CRUD Operations:\n\nCreate (POST Endpoint):\n\nUse the @app.post(\"/cars/\") decorator to define a POST endpoint.\nImplement a function named add_car that:\n\nAccepts a Car model instance.\nAssigns a unique ID to each new car by calculating the length of cars_db plus one.\nStores the car in cars_db using the assigned ID.\nReturns a JSON response confirming the addition of the car.\n\n\nRead (GET Endpoints):\n\nGet All Cars:\n\nUse the @app.get(\"/cars/\") decorator with response_model=List[Car] to define an endpoint that returns all cars.\nImplement a function named get_all_cars that returns a list of all values in cars_db.\n\nGet a Specific Car by ID:\n\nUse the @app.get(\"/cars/{car_id}\") decorator to define an endpoint that retrieves a car by its ID.\nImplement a function named get_car that:\n\nAccepts car_id as a path parameter.\nChecks if the car exists in cars_db.\nReturns the car if found, or raises an HTTP 404 exception if not found.\n\n\n\nUpdate (PUT Endpoint):\n\nUse the @app.put(\"/cars/{car_id}\") decorator to define an endpoint for updating car details.\nImplement a function named update_car_price that:\n\nAccepts car_id and a Car model instance.\nChecks if the car exists in cars_db.\nUpdates the price of the car (e.g., increases it by 10%).\nReturns a JSON response confirming the update, or raises an HTTP 404 exception if not found.\n\n\nDelete (DELETE Endpoint):\n\nUse the @app.delete(\"/cars/{car_id}\") decorator to define an endpoint for deleting a car.\nImplement a function named delete_car that:\n\nAccepts car_id as a path parameter.\nChecks if the car exists in cars_db.\nDeletes the car if found and returns a confirmation message, or raises an HTTP 404 exception if not found.\n\n\n\n\n\n\n6. Customizing FastAPI API Documentation\n1. Customize API Metadata\n\nSet Title, Description, and Version:\n\nWhen initializing your FastAPI instance, you can define a custom title, description, and version for your API. This information will be displayed prominently on your API‚Äôs documentation page.\n\nfrom fastapi import FastAPI\n\napp = FastAPI(\n    title=\"Recipe and Movie Collection API\",  # Custom API title\n    description=\"An API for managing recipes and movie collections. Manage, retrieve, and share your favorite items!\",  # Custom description\n    version=\"1.0.0\",  # Version of your API\n)\nAdd Tags with Descriptions:\n\nUse the openapi_tags parameter to categorize endpoints and add descriptions. This helps users understand different sections of your API.\n\ntags_metadata = [\n    {\n        \"name\": \"Introduction\",\n        \"description\": \"Basic introduction endpoints to get started.\",\n    },\n    {\n        \"name\": \"Recipe Management\",\n        \"description\": \"Endpoints for managing recipes including adding, retrieving, and deleting recipes.\",\n    },\n    {\n        \"name\": \"Movie Collection\",\n        \"description\": \"Endpoints for managing movie collections, including adding, retrieving, and deleting movies.\",\n    },\n]\n\napp = FastAPI(\n    openapi_tags=tags_metadata  # Apply tags metadata to FastAPI instance\n)\n\n2. Enhance Endpoint Documentation\n\nAdd Detailed Docstrings:\n\nFor each endpoint, provide comprehensive docstrings that explain the endpoint‚Äôs purpose, input parameters, and expected responses. This enhances the auto-generated documentation and helps users understand how to interact with your API.\n\n@app.get(\"/\", tags=[\"Introduction\"])\nasync def index():\n    \"\"\"\n    Returns a welcome message to introduce users to the API.\n\n    **Response:**\n    - `200`: A welcome message string.\n    \"\"\"\n    return {\"message\": \"Welcome to the Recipe and Movie Collection API!\"}\n@app.post(\"/recipes/\", tags=[\"Recipe Management\"])\nasync def add_recipe(recipe: Recipe):\n    \"\"\"\n    Add a new recipe to the collection.\n\n    **Request Body:**\n    - `title`: (string) The title of the recipe.\n    - `ingredients`: (list) The ingredients required.\n    - `instructions`: (string) The steps to prepare the recipe.\n\n    **Response:**\n    - `200`: Success message and the new recipe.\n    \"\"\"\n    # Recipe handling logic here\n    pass\n\n3. Further Customization\n\nAdd Contact, License, and Terms of Service Information:\n\nProvide additional context about your API by including contact details, licensing information, and terms of service. This is especially useful for public or enterprise APIs.\n\napp = FastAPI(\n    title=\"Recipe and Movie Collection API\",\n    description=\"An API for managing recipes and movie collections.\",\n    version=\"1.0.0\",\n    contact={\n        \"name\": \"API Support Team\",\n        \"email\": \"support@example.com\",\n        \"url\": \"https://example.com/support\"\n    },\n    license_info={\n        \"name\": \"MIT License\",\n        \"url\": \"https://opensource.org/licenses/MIT\",\n    },\n    terms_of_service=\"https://example.com/terms/\"\n)\n\n\n\n7. Putting It All Together\n\n  Your browser does not support the video tag. \n\n\nSetting Up the Project:\n\n\nCreate a Python file where you will define your FastAPI application (e.g., main.py).\nSet up a virtual environment and install FastAPI and Uvicorn if you haven‚Äôt already. This is essential for running your application.\n\n\nDefine Data Models:\n\n\nCreate Pydantic Models for data validation:\n\nDefine a Recipe model with fields such as title, ingredients, instructions, and cook_time.\nDefine a Movie model with fields like title, director, year, and genre.\n\n\n\nSimulate a Database:\n\n\nUse Python dictionaries to simulate a database for storing recipes and movies:\n\nCreate a dictionary named recipes_db for storing recipes.\nCreate another dictionary named movies_db for storing movies.\nEnsure that each entry is indexed by a unique identifier.\n\n\n\nImplement CRUD Operations:\n\n\nCreate (POST Endpoint):\n\nDefine a POST endpoint to add a new recipe. Validate the input data using the Recipe model, assign a unique ID, and store the recipe in recipes_db.\nSimilarly, create a POST endpoint for adding a new movie using the Movie model, storing it in movies_db.\n\nRead (GET Endpoints):\n\nImplement a GET endpoint to retrieve all recipes from recipes_db. Return a list of all stored recipes.\nCreate another GET endpoint to fetch a specific recipe by its ID, returning the data if found, or an appropriate error if not.\nImplement similar GET endpoints for movies, allowing retrieval of all movies or a specific movie by its ID.\n\nUpdate (PUT Endpoint):\n\nDefine a PUT endpoint to update an existing recipe. Check if the recipe exists in recipes_db. If it does, update its details and return a success message; if not, return an error.\nImplement a PUT endpoint for updating movie details, using a similar approach with movies_db.\n\nDelete (DELETE Endpoint):\n\nCreate a DELETE endpoint to remove a recipe by its ID. Check for its existence in recipes_db, delete it if found, and return a confirmation message; otherwise, return an error.\nSimilarly, implement a DELETE endpoint for movies, allowing deletion by ID with appropriate checks.\n\n\n\nEnhance API Documentation:\n\n\nUse Detailed Docstrings:\n\nFor each endpoint, provide a clear and concise docstring that describes the endpoint‚Äôs purpose, parameters, expected responses, and possible errors. This enhances the auto-generated documentation at /docs.\n\n\n\nRun the Application:\n\n\nStart the FastAPI Server:\n\nUse Uvicorn to run your application locally. This will enable you to test the CRUD operations and access the documentation.\n\n\nBy following these instructions, you will have a fully functional FastAPI application capable of managing a collection of recipes and movies, complete with CRUD operations and well-documented endpoints.",
    "crumbs": [
      "Exercices",
      "Lab 1"
    ]
  },
  {
    "objectID": "01_Exercises/03_Lab.html",
    "href": "01_Exercises/03_Lab.html",
    "title": "Lab 3 - Deployment and Production Considerations",
    "section": "",
    "text": "In this notebook, you will develop a strong foundational understanding of FastAPI and its capabilities in various contexts, including machine learning, image processing, and social media interaction.",
    "crumbs": [
      "Exercices",
      "Lab 3"
    ]
  },
  {
    "objectID": "01_Exercises/03_Lab.html#overview",
    "href": "01_Exercises/03_Lab.html#overview",
    "title": "Lab 3 - Deployment and Production Considerations",
    "section": "",
    "text": "In this notebook, you will develop a strong foundational understanding of FastAPI and its capabilities in various contexts, including machine learning, image processing, and social media interaction.",
    "crumbs": [
      "Exercices",
      "Lab 3"
    ]
  },
  {
    "objectID": "01_Exercises/03_Lab.html#goals",
    "href": "01_Exercises/03_Lab.html#goals",
    "title": "Lab 3 - Deployment and Production Considerations",
    "section": "Goals",
    "text": "Goals\nBy the end of this lab, you should be able to:\n\nUnderstand the process of deploying a FastAPI application on Heroku, including setting up environment configurations, creating necessary files, and troubleshooting deployment issues.\nLearn to add new endpoints to an existing FastAPI application, allowing for image uploads and processing.\nGain practical experience in handling images within a web application, including uploading, processing, and generating outputs based on user input.\nGain experience in fetching and processing data from external APIs, specifically fetching tweets based on search queries.",
    "crumbs": [
      "Exercices",
      "Lab 3"
    ]
  },
  {
    "objectID": "01_Exercises/03_Lab.html#prerequisites",
    "href": "01_Exercises/03_Lab.html#prerequisites",
    "title": "Lab 3 - Deployment and Production Considerations",
    "section": "Prerequisites",
    "text": "Prerequisites\nEnsure you have FastAPI, SQLAlchemy (or SQLModel), Pydantic, and other necessary libraries installed. You‚Äôll also need access to Python and a terminal",
    "crumbs": [
      "Exercices",
      "Lab 3"
    ]
  },
  {
    "objectID": "01_Exercises/03_Lab.html#build-an-api-for-predictions-and-deploy-on-heroku",
    "href": "01_Exercises/03_Lab.html#build-an-api-for-predictions-and-deploy-on-heroku",
    "title": "Lab 3 - Deployment and Production Considerations",
    "section": "1. Build an API for Predictions and Deploy on Heroku",
    "text": "1. Build an API for Predictions and Deploy on Heroku\n\nStep 1: Set Up Your Environment\n\nCreate a New Directory: Open your terminal and create a new directory for your project.\n\nmkdir fastapi_prediction_api\ncd fastapi_prediction_api\n\nSet Up a Virtual Environment: It‚Äôs a good practice to use a virtual environment for your projects. You can use venv for this.\n\npython3 -m venv venv\nsource venv/bin/activate  # For Linux or Mac\nvenv\\Scripts\\activate  # For Windows\n\nInstall Required Libraries: Install FastAPI, Uvicorn, and libraries for machine learning.\n\npip install fastapi uvicorn scikit-learn joblib numpy\n\n\nStep 2: Prepare Your Machine Learning Model\n\nChoose a Dataset: For this exercise, we will use the classic Iris dataset, which is commonly used for classification tasks. You can download it from UCI Machine Learning Repository or directly use it from sklearn.\nTrain a Simple Model: Create a new Python file named train_model.pyto train a logistic regression model on the Iris dataset\nRun the Model Training Script: Execute the script to train the model and save it.\n\npython train_model.py\n\n\nStep 3: Create the FastAPI Application\n\nCreate the FastAPI App: Create a new Python file named main.py to define your FastAPI application.\nLoad Your Model: load the trained model and create an API endpoint for predictions.\nDefine Input Format: The input format for the /predict endpoint should be a list of four numeric values representing the features of the Iris flower: sepal length, sepal width, petal length, and petal width.\n\n\n\nStep 4: Test Your API Locally\n\nRun Your FastAPI Application: Start your FastAPI app using Uvicorn.\n\nuvicorn main:app --reload\n\nAccess the Interactive API Documentation: Open your browser and navigate to http://127.0.0.1:8000/docs. This will open the Swagger UI, where you can test your API.\nSend a Test Request:\n\n\nClick on the /predict endpoint in the Swagger UI.\nClick on ‚ÄúTry it out‚Äù and input the following sample data:\n\n[5.1, 3.5, 1.4, 0.2]\n\nClick ‚ÄúExecute‚Äù to send the request. You should get a response like this:\n\n{\"prediction\": 0}\nThis indicates that the API predicts the flower belongs to class 0 (Iris Setosa).\n\n\nStep 5: Prepare for Heroku Deployment\n\nCreate a requirements.txt File: This file lists all the dependencies your application needs. You can generate it automatically using:\n\npip freeze &gt; requirements.txt\n\nCreate a Procfile: This file tells Heroku how to run your application. Create a new file named Procfile (with no extension) in your project directory and add the following line:\n\nweb: uvicorn main:app --host 0.0.0.0 --port ${PORT}\n\nCreate a runtime.txt File: Specify the Python version by creating a file named runtime.txt and adding your desired version, for example:\n\npython-3.9.10\n\n\nStep 6: Deploy to Heroku\n\nInstall the Heroku CLI: If you haven‚Äôt already, install the Heroku CLI from Heroku‚Äôs official website.\nLog in to Heroku: Open your terminal and log into your Heroku account.\n\nheroku login\n\nCreate a New Heroku App: Create a new Heroku app by running the following command. Replace your-app-name with a unique name for your app.\n\nheroku create your-app-name\n\nDeploy Your App:\n\n\nFirst, initialize a Git repository if you haven‚Äôt already:\n\ngit init\ngit add .\ngit commit -m \"Initial commit\"\n\nThen, deploy your application to Heroku:\n\ngit push heroku master\n\nOpen Your App: Once the deployment is complete, you can open your app in the browser using:\n\nheroku open\n\n\nStep 7: Test Your API on Heroku\n\nAccess the Heroku API URL: Your FastAPI application will now be accessible at the URL provided by Heroku. You can access the interactive API documentation by navigating to:\n\nhttps://your-app-name.herokuapp.com/docs\n\nSend a Test Request:\n\n\nClick on the /predict endpoint in the Swagger UI on Heroku.\nClick on ‚ÄúTry it out‚Äù and input the following sample data:\n\n[5.1, 3.5, 1.4, 0.2]\n\nClick ‚ÄúExecute‚Äù to send the request. You should receive a response similar to:\n\n{\"prediction\": 0}\n\n\nStep 8: Additional Challenges\n\nExpand the Model: Train a more complex model using additional features or different algorithms (e.g., Random Forest, SVM).\nAdd Error Handling: Implement error handling to manage invalid inputs and return meaningful error messages.\nEnhance the API: Add more endpoints for different functionalities, such as model evaluation or data visualization.\nImplement Logging: Integrate logging to monitor requests and track performance. Let‚Äôs construct a detailed notebook for the first module on the FastAPI framework, specifically focusing on working with a FastAPI application that serves a Stable Diffusion model. This will guide your students through the process while providing the necessary code examples and project structure.",
    "crumbs": [
      "Exercices",
      "Lab 3"
    ]
  },
  {
    "objectID": "02_Instructors/01_Lab_Solutions.html",
    "href": "02_Instructors/01_Lab_Solutions.html",
    "title": "Lab 1 - Introduction to FastAPI & Development Setup",
    "section": "",
    "text": "In this lab, you will guide your students through setting up their development environment and creating foundational API endpoints using FastAPI.\nThese exercises are designed to build proficiency in constructing robust APIs. Encourage students to ask questions and explore, as they embark on their coding journey. May the code be with them!"
  },
  {
    "objectID": "02_Instructors/01_Lab_Solutions.html#overview",
    "href": "02_Instructors/01_Lab_Solutions.html#overview",
    "title": "Lab 1 - Introduction to FastAPI & Development Setup",
    "section": "",
    "text": "In this lab, you will guide your students through setting up their development environment and creating foundational API endpoints using FastAPI.\nThese exercises are designed to build proficiency in constructing robust APIs. Encourage students to ask questions and explore, as they embark on their coding journey. May the code be with them!"
  },
  {
    "objectID": "02_Instructors/01_Lab_Solutions.html#goals",
    "href": "02_Instructors/01_Lab_Solutions.html#goals",
    "title": "Lab 1 - Introduction to FastAPI & Development Setup",
    "section": "Goals",
    "text": "Goals\nYou will help students achieve the following:\n\nSet up a Virtual Environment: Ensure students understand how to create and activate a virtual environment for Python projects, emphasizing the importance of isolated environments for dependency management.\nInstall FastAPI and Uvicorn: Guide students through installing FastAPI and Uvicorn, explaining their roles in API development and serving applications.\nCreate a Basic FastAPI Application: Walk students through building a simple FastAPI app, introducing key concepts like asynchronous endpoints and request handling.\nImplement Path Parameters: Demonstrate how to make API endpoints dynamic by using path parameters, enhancing functionality and allowing variable input.\nExplore Pydantic Models: Highlight the power of Pydantic models for data validation, showing students how to define and use models to ensure data integrity.\nDevelop CRUD Operations: Teach students how to implement Create, Read, Update, and Delete operations, emphasizing the importance of these operations in resource management.\nCustomize API Documentation: Explore FastAPI‚Äôs auto-generated documentation feature, showing students how to customize API metadata, categorize endpoints using tags, and add detailed descriptions."
  },
  {
    "objectID": "02_Instructors/01_Lab_Solutions.html#terminal-setup",
    "href": "02_Instructors/01_Lab_Solutions.html#terminal-setup",
    "title": "Lab 1 - Introduction to FastAPI & Development Setup",
    "section": "1. Terminal Setup",
    "text": "1. Terminal Setup\n\nCreate and Activate a Virtual Environment\n\nVirtual Environment Creation:\n\nTo create a virtual environment, use the command:\npython3 -m venv env\nActivate on Linux and macOS:\nsource env/bin/activate\nActivate on Windows:\nenv\\Scripts\\activate"
  },
  {
    "objectID": "02_Instructors/01_Lab_Solutions.html#install-fastapi-and-uvicorn",
    "href": "02_Instructors/01_Lab_Solutions.html#install-fastapi-and-uvicorn",
    "title": "Lab 1 - Introduction to FastAPI & Development Setup",
    "section": "2. Install FastAPI and Uvicorn",
    "text": "2. Install FastAPI and Uvicorn\n\nInstallation Commands:\n\nInstall FastAPI and Uvicorn using pip:\npip install fastapi[standard]\npip install uvicorn[standard]\nCheck Installation:\n\nVerify the installation by checking the FastAPI version:\nfastapi --version\n\nFreeze Requirements:\n\nSave the installed packages to a requirements.txt file:\npip freeze &gt; requirements.txt"
  },
  {
    "objectID": "02_Instructors/01_Lab_Solutions.html#write-and-test-your-first-fastapi-hello-world-endpoint",
    "href": "02_Instructors/01_Lab_Solutions.html#write-and-test-your-first-fastapi-hello-world-endpoint",
    "title": "Lab 1 - Introduction to FastAPI & Development Setup",
    "section": "3. Write and Test Your First FastAPI ‚ÄúHello, World!‚Äù Endpoint",
    "text": "3. Write and Test Your First FastAPI ‚ÄúHello, World!‚Äù Endpoint\n\nBasic FastAPI Application:\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}"
  },
  {
    "objectID": "02_Instructors/01_Lab_Solutions.html#run-a-local-fastapi-development-server",
    "href": "02_Instructors/01_Lab_Solutions.html#run-a-local-fastapi-development-server",
    "title": "Lab 1 - Introduction to FastAPI & Development Setup",
    "section": "4. Run a Local FastAPI Development Server",
    "text": "4. Run a Local FastAPI Development Server\n\nUsing Uvicorn:\n\nRun the server with the command:\nuvicorn app1:app\nHere, app1 is the name of the file, and app is the FastAPI object."
  },
  {
    "objectID": "02_Instructors/01_Lab_Solutions.html#path-parameters-in-queries",
    "href": "02_Instructors/01_Lab_Solutions.html#path-parameters-in-queries",
    "title": "Lab 1 - Introduction to FastAPI & Development Setup",
    "section": "5. Path Parameters in Queries",
    "text": "5. Path Parameters in Queries\n\nAdding Parameters:\n\nDefine endpoints with path parameters:\n@app.get(\"/text/{message}\")\nasync def read_message(message: str):\n    return {\"message\": message}\n\n@app.get(\"/number/{number}\")\nasync def read_number(number: int):\n    return {\"number\": number}\n6. Using Enums and Models\n\nEnum Example:\n\nfrom enum import Enum\n\n# Using Enums with FastAPI\nclass PeopleName(str, Enum):\n    \"\"\"Enum for family members' names.\"\"\"\n    brother = \"Marc\"\n    sister = \"Marie\"\n    mother = \"Josette\"\n\n@app.get(\"/people/{person_name}\")\nasync def get_person(person_name: PeopleName):\n    \"\"\"Get details based on the family member's name.\"\"\"\n    if person_name == PeopleName.brother:\n        return {\"person_name\": person_name, \"message\": \"He's the best brother!\"}\n    if person_name == PeopleName.sister:\n        return {\"person_name\": person_name, \"message\": \"She's the best sister!\"}\n    if person_name == PeopleName.mother:\n        return {\"person_name\": person_name, \"message\": \"She's the best mother!\"}\n    \n    return {\"person_name\": person_name, \"message\": \"This person is not in our family!\"}"
  },
  {
    "objectID": "02_Instructors/01_Lab_Solutions.html#pydantic-models-for-data-validation",
    "href": "02_Instructors/01_Lab_Solutions.html#pydantic-models-for-data-validation",
    "title": "Lab 1 - Introduction to FastAPI & Development Setup",
    "section": "7. Pydantic Models for Data Validation",
    "text": "7. Pydantic Models for Data Validation\nHere are several examples showcasing how to use Pydantic with FastAPI, demonstrating its capabilities for data validation, serialization, and complex data structures.\n\n1. Basic Model Example\nThis example shows how to define a simple Pydantic model for a user and validate the data.\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n# Define a Pydantic model for a User\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n\n@app.post(\"/users/\")\nasync def create_user(user: User):\n    return {\"message\": \"User created successfully!\", \"user\": user}\n\n\n2. Nested Models\nYou can define nested Pydantic models to represent more complex data structures.\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import List\n\napp = FastAPI()\n\n# Define a model for an Address\nclass Address(BaseModel):\n    street: str\n    city: str\n    state: str\n    zip_code: str\n\n# Define a model for a User with an Address\nclass UserWithAddress(BaseModel):\n    name: str\n    email: str\n    age: int\n    address: Address  # Nesting Address model\n\n@app.post(\"/users-with-address/\")\nasync def create_user_with_address(user: UserWithAddress):\n  return {\"message\": \"User with address created successfully!\", \"user\": user}\n\n\n3. Using Default Values\nPydantic allows you to set default values for model fields.\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n# Define a model with default values\nclass Item(BaseModel):\n    name: str\n    price: float\n    is_available: bool = True  # Default value\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    return {\"message\": \"Item created successfully!\", \"item\": item}\n\n\n4. Validating Data with Constraints\nYou can add constraints to model fields using Pydantic‚Äôs built-in validators.\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, constr\n\napp = FastAPI()\n\n# Define a model with constraints\nclass Product(BaseModel):\n    name: constr(min_length=1, max_length=100)  # Name must be 1-100 characters\n    price: float\n    quantity: int\n\n@app.post(\"/products/\")\nasync def create_product(product: Product):\n    return {\"message\": \"Product created successfully!\", \"product\": product}\n\n\n5. Using Lists and Optional Fields\nPydantic can handle lists of items and optional fields.\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\napp = FastAPI()\n\n# Define a model for an Order\nclass Order(BaseModel):\n    item_name: str\n    quantity: int\n    notes: Optional[str] = None  # Optional field\n\n# Define a model for a Cart\nclass Cart(BaseModel):\n    user_id: int\n    items: List[Order]  # List of Order items\n\n@app.post(\"/carts/\")\nasync def create_cart(cart: Cart):\n    return {\"message\": \"Cart created successfully!\", \"cart\": cart}\n\n\n6. Complex Data Types\nYou can use Pydantic to define more complex types, such as dictionaries.\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import Dict\n\napp = FastAPI()\n\n# Define a model for a Configuration\nclass Configuration(BaseModel):\n    setting_name: str\n    value: str\n\n# Define a model for a System\nclass System(BaseModel):\n    name: str\n    configurations: Dict[str, Configuration]  # Dictionary of configurations\n\n@app.post(\"/systems/\")\nasync def create_system(system: System):\n    return {\"message\": \"System created successfully!\", \"system\": system}"
  },
  {
    "objectID": "02_Instructors/01_Lab_Solutions.html#crud-operations-with-fastapi",
    "href": "02_Instructors/01_Lab_Solutions.html#crud-operations-with-fastapi",
    "title": "Lab 1 - Introduction to FastAPI & Development Setup",
    "section": "8. CRUD Operations with FastAPI",
    "text": "8. CRUD Operations with FastAPI\n\nManage Cars Database:\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nclass Car(BaseModel):\n    brand: str\n    model: str\n    date: datetime\n    price: float\n\ncars_db = {}\n\n# Get all cars\n@app.get(\"/cars/\", response_model=List[Car])\nasync def get_all_cars():\n    return list(cars_db.values())\n\n# Get a car by ID\n@app.get(\"/cars/{car_id}\")\nasync def get_car(car_id: int):\n    if car_id not in cars_db:\n        raise HTTPException(status_code=404, detail=\"Car not found\")\n    return cars_db[car_id]\n\n# Add a new car\n@app.post(\"/cars/\")\nasync def add_car(car: Car):\n    car_id = len(cars_db) + 1\n    cars_db[car_id] = car.dict()\n    return {\"message\": \"Car added successfully\", \"car\": car.dict()}\n\n# Update an existing car\n@app.put(\"/cars/{car_id}\")\nasync def update_car_price(car_id: int, car: Car):\n    if car_id not in cars_db:\n        raise HTTPException(status_code=404, detail=\"Car not found\")\n    car.price *= 1.10  # Augment the price by 10%\n    cars_db[car_id] = car.dict()\n    return {\"message\": \"Car updated successfully with a 10% price increase\", \"car\": car.dict()}\n\n# Delete a car\n@app.delete(\"/cars/{car_id}\")\nasync def delete_car(car_id: int):\n    if car_id not in cars_db:\n        raise HTTPException(status_code=404, detail=\"Car not found\")\n    del cars_db[car_id]\n    return {\"message\": \"Car deleted successfully\"}"
  },
  {
    "objectID": "02_Instructors/01_Lab_Solutions.html#customizing-fastapi-documentation",
    "href": "02_Instructors/01_Lab_Solutions.html#customizing-fastapi-documentation",
    "title": "Lab 1 - Introduction to FastAPI & Development Setup",
    "section": "9. Customizing FastAPI Documentation",
    "text": "9. Customizing FastAPI Documentation\n\n1. Customize the API Metadata\nModify the title, description, and version of the API when initializing the FastAPI instance. This helps in presenting important details about the API on the documentation page.\nfrom fastapi import FastAPI\n\napp = FastAPI(\n    title=\"üçΩÔ∏è Recipe and Movie Collection API\",  # Custom API title\n    description=\"An API for managing recipes and movie collections. Manage, retrieve, and share your favorite items!\",  # Custom description\n    version=\"1.0.0\",  # Version of your API\n)\n\n\n2. Add Tags with Descriptions\nUse the tags_metadata parameter to categorize endpoints and add descriptions. This allows users to easily understand different parts of your API.\ntags_metadata = [\n    {\n        \"name\": \"Introduction\",\n        \"description\": \"Basic introduction endpoints to get started.\",\n    },\n    {\n        \"name\": \"Recipe Management\",\n        \"description\": \"Endpoints for managing recipes including adding, retrieving, and deleting recipes.\",\n    },\n    {\n        \"name\": \"Movie Collection\",\n        \"description\": \"Endpoints for managing movie collections, including adding, retrieving, and deleting movies.\",\n    },\n]\n\napp = FastAPI(\n    openapi_tags=tags_metadata  # Apply tags metadata to FastAPI instance\n)\n\n\n3. Document Each Endpoint\nAdd detailed docstrings to each endpoint. This enhances the auto-generated documentation and helps API users understand each endpoint‚Äôs functionality, parameters, and responses.\n@app.get(\"/\", tags=[\"Introduction\"])\nasync def index():\n    \"\"\"\n    Returns a welcome message to introduce users to the API.\n\n    **Response:**\n    - `200`: A welcome message string.\n    \"\"\"\n    return {\"message\": \"Welcome to the Recipe and Movie Collection API!\"}\n\n@app.post(\"/recipes/\", tags=[\"Recipe Management\"])\nasync def add_recipe(recipe: Recipe):\n    \"\"\"\n    Add a new recipe to the collection.\n\n    **Request Body:**\n    - `title`: (string) The title of the recipe.\n    - `ingredients`: (list) The ingredients required.\n    - `instructions`: (string) The steps to prepare the recipe.\n\n    **Response:**\n    - `200`: Success message and the new recipe.\n    \"\"\"\n    # Recipe handling logic here\n    pass\n\n\n4. Customizing OpenAPI Schema\nYou can customize the OpenAPI schema further by adding terms of service, license, or contact information. This is useful for providing more context about your API, especially for enterprise or public APIs.\napp = FastAPI(\n    title=\"üçΩÔ∏è Recipe and Movie Collection API\",\n    description=\"An API for managing recipes and movie collections.\",\n    version=\"1.0.0\",\n    contact={\n        \"name\": \"API Support Team\",\n        \"email\": \"support@example.com\",\n        \"url\": \"https://example.com/support\"\n    },\n    license_info={\n        \"name\": \"MIT License\",\n        \"url\": \"https://opensource.org/licenses/MIT\",\n    },\n    terms_of_service=\"https://example.com/terms/\"\n)\nHere‚Äôs the updated code with enhanced documentation customization:\nimport uvicorn\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom typing import List\n\n# Description for the API\ndescription = \"\"\"\nWelcome to the Combined Recipe and Movie Collection API! \n\n## Recipe Management\nManage and share your favorite recipes. Users can add, update, delete, and retrieve recipes, along with their ingredients and instructions.\n\n## Movie Collection\nKeep track of your favorite movies. Users can manage their movie collection, including details like the title, director, and release year.\n\nCheck out documentation below üëá for more information on each endpoint.\n\"\"\"\n\n# Tags metadata for the API documentation\ntags_metadata = [\n    {\n        \"name\": \"Introduction Endpoints\",\n        \"description\": \"Simple endpoints to try out!\",\n    },\n    {\n        \"name\": \"Recipe Management\",\n        \"description\": \"Manage and share your favorite recipes.\",\n    },\n    {\n        \"name\": \"Movie Collection\",\n        \"description\": \"Keep track of your favorite movies.\",\n    },\n]\n\napp = FastAPI(\n    title=\"üìö Recipe and Movie Collection API\",\n    description=description,\n    version=\"0.1\",\n    contact={\n        \"name\": \"M√©nyssa Cherifa-Luron\",\n        \"email\": \"cmenyssa@live.fr\",\n        \"url\": \"menyssacherifaluron.com\",\n    },\n    license_info={\n        \"name\": \"MIT License\",\n        \"url\": \"https://opensource.org/licenses/MIT\"\n    },\n    openapi_tags=tags_metadata\n)\n\n# Recipe Model\nclass Recipe(BaseModel):\n    title: str\n    ingredients: List[str]\n    instructions: str\n    cook_time: int  # in minutes\n\n# Database simulation\nrecipes_db = {}\n\n# Movie Model\nclass Movie(BaseModel):\n    title: str\n    director: str\n    year: int\n    genre: str\n\n# Movie Database\nmovies_db = {}\n\n@app.get(\"/\", tags=[\"Introduction Endpoints\"])\nasync def index():\n    \"\"\"\n    Simply returns a welcome message!\n    \"\"\"\n    message = \"Hello world! This `/` is the most simple and default endpoint. If you want to learn more, check out documentation of the api at `/docs`\"\n    return message\n\n# Recipe Endpoints\n\n@app.get(\"/recipes/\", response_model=List[Recipe], tags=[\"Recipe Management\"])\nasync def get_all_recipes():\n    \"\"\"\n    Retrieve a list of all recipes.\n    \"\"\"\n    return list(recipes_db.values())\n\n@app.get(\"/recipes/{recipe_id}\", tags=[\"Recipe Management\"])\nasync def get_recipe(recipe_id: int):\n    \"\"\"\n    Retrieve details of a specific recipe by ID.\n    \"\"\"\n    if recipe_id not in recipes_db:\n        raise HTTPException(status_code=404, detail=\"Recipe not found\")\n    return recipes_db[recipe_id]\n\n@app.post(\"/recipes/\", tags=[\"Recipe Management\"])\nasync def add_recipe(recipe: Recipe):\n    \"\"\"\n    Add a new recipe.\n    \"\"\"\n    recipe_id = len(recipes_db) + 1\n    recipes_db[recipe_id] = recipe.dict()\n    return {\"message\": \"Recipe added successfully\", \"recipe\": recipe.dict()}\n\n@app.put(\"/recipes/{recipe_id}\", tags=[\"Recipe Management\"])\nasync def update_recipe(recipe_id: int, recipe: Recipe):\n    \"\"\"\n    Update an existing recipe by ID.\n    \"\"\"\n    if recipe_id not in recipes_db:\n        raise HTTPException(status_code=404, detail=\"Recipe not found\")\n    recipes_db[recipe_id] = recipe.dict()\n    return {\"message\": \"Recipe updated successfully\", \"recipe\": recipe.dict()}\n\n@app.delete(\"/recipes/{recipe_id}\", tags=[\"Recipe Management\"])\nasync def delete_recipe(recipe_id: int):\n    \"\"\"\n    Delete a recipe by ID.\n    \"\"\"\n    if recipe_id not in recipes_db:\n        raise HTTPException(status_code=404, detail=\"Recipe not found\")\n    del recipes_db[recipe_id]\n    return {\"message\": \"Recipe deleted successfully\"}\n\n# Movie Endpoints\n\n@app.get(\"/movies/\", response_model=List[Movie], tags=[\"Movie Collection\"])\nasync def get_all_movies():\n    \"\"\"\n    Retrieve a list of all movies.\n    \"\"\"\n    return list(movies_db.values())\n\n@app.get(\"/movies/{movie_id}\", tags=[\"Movie Collection\"])\nasync def get_movie(movie_id: int):\n    \"\"\"\n    Retrieve details of a specific movie by ID.\n    \"\"\"\n    if movie_id not in movies_db:\n        raise HTTPException(status_code=404, detail=\"Movie not found\")\n    return movies_db[movie_id]\n\n@app.post(\"/movies/\", tags=[\"Movie Collection\"])\nasync def add_movie(movie: Movie):\n    \"\"\"\n    Add a new movie.\n    \"\"\"\n    movie_id = len(movies_db) + 1\n    movies_db[movie_id] = movie.dict()\n    return {\"message\": \"Movie added successfully\", \"movie\": movie.dict()}\n\n@app.put(\"/movies/{movie_id}\", tags=[\"Movie Collection\"])\nasync def update_movie(movie_id: int, movie: Movie):\n    \"\"\"\n    Update an existing movie by ID.\n    \"\"\"\n    if movie_id not in movies_db:\n        raise HTTPException(status_code=404, detail=\"Movie not found\")\n    movies_db[movie_id] = movie.dict()\n    return {\"message\": \"Movie updated successfully\", \"movie\": movie.dict()}\n\n@app.delete(\"/movies/{movie_id}\", tags=[\"Movie Collection\"])\nasync def delete_movie(movie_id: int):\n    \"\"\"\n    Delete a movie by ID.\n    \"\"\"\n    if movie_id not in movies_db:\n        raise HTTPException(status_code=404, detail=\"Movie not found\")\n    del movies_db[movie_id]\n    return {\"message\": \"Movie deleted successfully\"}\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)"
  },
  {
    "objectID": "02_Instructors/03_Lab_Solutions.html",
    "href": "02_Instructors/03_Lab_Solutions.html",
    "title": "Lab 3 - Deployment and Production Considerations",
    "section": "",
    "text": "In this lab, students will delve into the deployment and enhancement of FastAPI applications, focusing on practical applications in machine learning, image processing, and social media interaction.\nThis lab will not only teach students how to build and deploy an API but also how to extend its functionality and make it robust and scalable.\nMay the code be with them! üåü"
  },
  {
    "objectID": "02_Instructors/03_Lab_Solutions.html#overview",
    "href": "02_Instructors/03_Lab_Solutions.html#overview",
    "title": "Lab 3 - Deployment and Production Considerations",
    "section": "",
    "text": "In this lab, students will delve into the deployment and enhancement of FastAPI applications, focusing on practical applications in machine learning, image processing, and social media interaction.\nThis lab will not only teach students how to build and deploy an API but also how to extend its functionality and make it robust and scalable.\nMay the code be with them! üåü"
  },
  {
    "objectID": "02_Instructors/03_Lab_Solutions.html#goals",
    "href": "02_Instructors/03_Lab_Solutions.html#goals",
    "title": "Lab 3 - Deployment and Production Considerations",
    "section": "Goals",
    "text": "Goals\nYou will help students achieve the following:\n\nUnderstand the deployment process of a FastAPI application on Heroku, including environment setup, file creation, and troubleshooting.\nLearn to extend an existing FastAPI application with new endpoints for functionalities such as image uploads and processing.\nGain hands-on experience with handling images in a web application environment, including uploading, processing, and generating outputs.\nAcquire skills in fetching and processing data from external APIs, focusing on tasks such as retrieving tweets based on specific queries."
  },
  {
    "objectID": "02_Instructors/03_Lab_Solutions.html#iris-api",
    "href": "02_Instructors/03_Lab_Solutions.html#iris-api",
    "title": "Lab 3 - Deployment and Production Considerations",
    "section": "IRIS API",
    "text": "IRIS API\nThe full project solution is available here"
  },
  {
    "objectID": "02_Instructors/03_Lab_Solutions.html#twitter-api",
    "href": "02_Instructors/03_Lab_Solutions.html#twitter-api",
    "title": "Lab 3 - Deployment and Production Considerations",
    "section": "Twitter API",
    "text": "Twitter API\nThe full project solution folder will be available soon"
  },
  {
    "objectID": "02_Instructors/index.html",
    "href": "02_Instructors/index.html",
    "title": "üìë Instructors",
    "section": "",
    "text": "Detailed notes on lecture content",
    "crumbs": [
      "Instructors",
      "Notes"
    ]
  },
  {
    "objectID": "02_Instructors/index.html#instructor-notes",
    "href": "02_Instructors/index.html#instructor-notes",
    "title": "üìë Instructors",
    "section": "",
    "text": "Detailed notes on lecture content",
    "crumbs": [
      "Instructors",
      "Notes"
    ]
  },
  {
    "objectID": "02_Instructors/index.html#solution-guides",
    "href": "02_Instructors/index.html#solution-guides",
    "title": "üìë Instructors",
    "section": "Solution Guides",
    "text": "Solution Guides\n\nLab 1\nLab 2\n\nLab 3",
    "crumbs": [
      "Instructors",
      "Notes"
    ]
  },
  {
    "objectID": "02_Instructors/index.html#assessment-materials",
    "href": "02_Instructors/index.html#assessment-materials",
    "title": "üìë Instructors",
    "section": "Assessment Materials",
    "text": "Assessment Materials\nFinal project : HealthPredictor: A Healthcare Machine Learning Application",
    "crumbs": [
      "Instructors",
      "Notes"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "üëã Welcome to the FastAPI Course!",
    "section": "",
    "text": "We‚Äôre thrilled to have you here on this journey into the world of FastAPI!\nWhether you‚Äôre a curious beginner or a seasoned developer looking to upskill, this course will equip you with the knowledge and hands-on experience to master building APIs like a pro.\nTogether, we‚Äôll dive into key concepts like asynchronous programming, data validation, and API deployment‚Äîhelping you sharpen your skills every step of the way.\nEach lecture brings theory to life with live coding demos üé•, and our exercises will give you the chance to apply what you‚Äôve learned in real-world scenarios. üí°\nEverything you need is neatly organized into:\n\nüìö Lectures: Theory and live coding examples to boost your understanding.\nüõ†Ô∏è Exercises: Hands-on tasks to solidify your skills.\nüéì Instructor Files: Teaching resources, including solutions and assessments.",
    "crumbs": [
      "Course information",
      "Getting Started"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "üëã Welcome to the FastAPI Course!",
    "section": "",
    "text": "We‚Äôre thrilled to have you here on this journey into the world of FastAPI!\nWhether you‚Äôre a curious beginner or a seasoned developer looking to upskill, this course will equip you with the knowledge and hands-on experience to master building APIs like a pro.\nTogether, we‚Äôll dive into key concepts like asynchronous programming, data validation, and API deployment‚Äîhelping you sharpen your skills every step of the way.\nEach lecture brings theory to life with live coding demos üé•, and our exercises will give you the chance to apply what you‚Äôve learned in real-world scenarios. üí°\nEverything you need is neatly organized into:\n\nüìö Lectures: Theory and live coding examples to boost your understanding.\nüõ†Ô∏è Exercises: Hands-on tasks to solidify your skills.\nüéì Instructor Files: Teaching resources, including solutions and assessments.",
    "crumbs": [
      "Course information",
      "Getting Started"
    ]
  },
  {
    "objectID": "index.html#new-feature-audio-overview",
    "href": "index.html#new-feature-audio-overview",
    "title": "üëã Welcome to the FastAPI Course!",
    "section": "‚ú® New Feature: Audio Overview",
    "text": "‚ú® New Feature: Audio Overview\nNow, we‚Äôre taking your learning experience to the next level!\nIntroducing Audio Overview, where you can turn your course materials into engaging audio discussions.\nWith just one click, two AI hosts will dive deep into your lecture content, summarizing key points, making insightful connections, and even adding some light banter to keep you hooked. üéß\nYou can also download the conversation and listen on the go ‚Äî perfect for when you‚Äôre multitasking or need a hands-free study session!\n\n\n\n\n\n\nNote\n\n\n\nThese discussions stem from the lectures I‚Äôve uploaded, offering you an interactive method to revisit the course material.\nThey‚Äôre not a complete analysis but will help you reinforce what you‚Äôve learned while keeping things fun! More info here\n\n\nLet‚Äôs get started and build something amazing together! üíªüéâ",
    "crumbs": [
      "Course information",
      "Getting Started"
    ]
  },
  {
    "objectID": "Prerequisites.html",
    "href": "Prerequisites.html",
    "title": "üìã Prerequisites for the FastAPI Course",
    "section": "",
    "text": "Basic Knowledge of Python Programming\n\nYou‚Äôve danced with Python 3 before, right? Make sure you‚Äôre comfortable with:\n\nVariables, loops, and conditionals: The bread and butter of any Python script.\nFunctions, modules, and packages: Your toolkit for building reusable code.\nData structures: Lists, dictionaries, sets, and tuples‚Äîyour data‚Äôs best friends.\nError handling: Mastering the art of try-except to keep your code running smoothly.\n\nAnd of course, you know your way around pip for installing those nifty Python packages.\n\nUnderstanding of Web Development Concepts\n\nGet cozy with the web‚Äôs lingua franca:\n\nHTTP: Know your GETs from your POSTs, and how the web talks back and forth.\nREST APIs: The secret handshake of web services‚Äîunderstand the principles and how they connect with clients.\nJSON: The universal data format‚Äîlike the Esperanto of the web!\n\n\nBasic Command Line Skills:\n\nThe command line is your command center:\n\nNavigate directories and run scripts like a pro.\nManage virtual environments with venv or virtualenv‚Äîyour sandbox for Python projects.\n\n\nFamiliarity with Version Control (Git):\n\nGit is your time machine for code:\n\nClone, commit, and push your way through repositories.\nBranching and pull requests? You‚Äôve got this at a basic level.\n\n\nBasic Knowledge of Databases:\n\nSQL and relational databases are your data‚Äôs home:\n\nUnderstand tables, relationships, and basic queries (SELECT, INSERT, UPDATE, DELETE).\n\nSchemas and migrations? Nice to know, but not a dealbreaker.\n\nExposure to Docker and Containers (Optional but recommended):\n\nDocker is your ship for deploying apps:\n\nGrasp the basics of containerization and commands like docker build and docker run.\n\nDeployment practices (Heroku, AWS)? Handy, but not essential.\n\nMachine Learning (for specific modules):\n\nIf you‚Äôre eyeing the Machine Learning module, brush up on:\n\nThe ML workflow: training, testing, and deploying models.\nPython ML libraries like scikit-learn, PyCaret, or MLflow.",
    "crumbs": [
      "Course information",
      "Prerequisites"
    ]
  },
  {
    "objectID": "Prerequisites.html#must-have-skills",
    "href": "Prerequisites.html#must-have-skills",
    "title": "üìã Prerequisites for the FastAPI Course",
    "section": "",
    "text": "Basic Knowledge of Python Programming\n\nYou‚Äôve danced with Python 3 before, right? Make sure you‚Äôre comfortable with:\n\nVariables, loops, and conditionals: The bread and butter of any Python script.\nFunctions, modules, and packages: Your toolkit for building reusable code.\nData structures: Lists, dictionaries, sets, and tuples‚Äîyour data‚Äôs best friends.\nError handling: Mastering the art of try-except to keep your code running smoothly.\n\nAnd of course, you know your way around pip for installing those nifty Python packages.\n\nUnderstanding of Web Development Concepts\n\nGet cozy with the web‚Äôs lingua franca:\n\nHTTP: Know your GETs from your POSTs, and how the web talks back and forth.\nREST APIs: The secret handshake of web services‚Äîunderstand the principles and how they connect with clients.\nJSON: The universal data format‚Äîlike the Esperanto of the web!\n\n\nBasic Command Line Skills:\n\nThe command line is your command center:\n\nNavigate directories and run scripts like a pro.\nManage virtual environments with venv or virtualenv‚Äîyour sandbox for Python projects.\n\n\nFamiliarity with Version Control (Git):\n\nGit is your time machine for code:\n\nClone, commit, and push your way through repositories.\nBranching and pull requests? You‚Äôve got this at a basic level.\n\n\nBasic Knowledge of Databases:\n\nSQL and relational databases are your data‚Äôs home:\n\nUnderstand tables, relationships, and basic queries (SELECT, INSERT, UPDATE, DELETE).\n\nSchemas and migrations? Nice to know, but not a dealbreaker.\n\nExposure to Docker and Containers (Optional but recommended):\n\nDocker is your ship for deploying apps:\n\nGrasp the basics of containerization and commands like docker build and docker run.\n\nDeployment practices (Heroku, AWS)? Handy, but not essential.\n\nMachine Learning (for specific modules):\n\nIf you‚Äôre eyeing the Machine Learning module, brush up on:\n\nThe ML workflow: training, testing, and deploying models.\nPython ML libraries like scikit-learn, PyCaret, or MLflow.",
    "crumbs": [
      "Course information",
      "Prerequisites"
    ]
  },
  {
    "objectID": "Prerequisites.html#tools-and-software-requirements",
    "href": "Prerequisites.html#tools-and-software-requirements",
    "title": "üìã Prerequisites for the FastAPI Course",
    "section": "üõ†Ô∏è Tools and Software Requirements",
    "text": "üõ†Ô∏è Tools and Software Requirements\n\nPython 3.7+: Your trusty Python interpreter.\nText Editor/IDE: Whether it‚Äôs Visual Studio Code, PyCharm, or another favorite, make sure it‚Äôs ready to go.\nDocker: For those deployment adventures.\nGit: Installed and ready, with a GitHub account for version control.",
    "crumbs": [
      "Course information",
      "Prerequisites"
    ]
  },
  {
    "objectID": "Prerequisites.html#additional-resources",
    "href": "Prerequisites.html#additional-resources",
    "title": "üìã Prerequisites for the FastAPI Course",
    "section": "‚ûï Additional Resources",
    "text": "‚ûï Additional Resources\nTo reinforce your understanding of the FastAPI course prerequisites, here are some valuable resources:\n\nPython Programming\n\nOfficial Python Tutorial: https://docs.python.org/3/tutorial/\nReal Python: https://realpython.com/\nLearn Python: https://learnpythonthehardway.org/\n\n\n\nWeb Development Concepts\n\nMDN Web Docs: https://developer.mozilla.org/en-US/\nREST API Tutorial: https://m.youtube.com/watch?v=BRdcRFvuqsE\nJSON Tutorial: https://www.tutorialspoint.com/org_json/org_json_quick_guide.htm\n\n\n\nCommand Line Skills\n\nLinux Foundation‚Äôs Command Line Heroes: https://www.redhat.com/en/command-line-heroes\nThe Linux Command Line: https://linuxcommand.org/tlcl.php\n\n\n\nVersion Control (Git)\n\nGitHub Guides: https://github.com/git-guides\nGit Tutorial: https://www.atlassian.com/git/tutorials\n\n\n\nDatabases\n\nW3Schools SQL Tutorial: https://www.w3schools.com/sql/\nSQLBolt: https://sqlbolt.com/\n\n\n\nDocker\n\nDocker Documentation: https://docs.docker.com/\nDocker Tutorial: https://docs.docker.com/get-started/\n\n\n\nMachine Learning\n\nScikit-learn Tutorials: https://scikit-learn.org/\nMachine Learning Crash Course: https://developers.google.com/machine-learning/crash-course\n\nRemember:\nThese prerequisites are your ticket to a smooth ride through the FastAPI course.\nIf you‚Äôre missing any of these skills, consider a quick refresher to get up to speed.",
    "crumbs": [
      "Course information",
      "Prerequisites"
    ]
  }
]